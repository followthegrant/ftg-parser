<article article-type="article" specific-use="production" xml:lang="en" xmlns:hw="org.highwire.hpp" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ali="http://www.niso.org/schemas/ali/1.0/" xmlns:ref="http://schema.highwire.org/Reference" xmlns:hwp="http://schema.highwire.org/Journal" xmlns:l="http://schema.highwire.org/Linking" xmlns:r="http://schema.highwire.org/Revision" xmlns:x="http://www.w3.org/1999/xhtml" xmlns:app="http://www.w3.org/2007/app" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:nlm="http://schema.highwire.org/NLM/Journal" xmlns:a="http://www.w3.org/2005/Atom" xmlns:c="http://schema.highwire.org/Compound" xmlns:hpp="http://schema.highwire.org/Publishing"><front><journal-meta><journal-id journal-id-type="hwp">biorxiv</journal-id><journal-id journal-id-type="publisher-id">BIORXIV</journal-id><journal-title>bioRxiv</journal-title><abbrev-journal-title abbrev-type="publisher">bioRxiv</abbrev-journal-title><publisher><publisher-name>Cold Spring Harbor Laboratory</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="doi">10.1101/051409</article-id><article-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;051409v1</article-id><article-id pub-id-type="other" hwp:sub-type="pisa-master">biorxiv;051409</article-id><article-id pub-id-type="other" hwp:sub-type="slug">051409</article-id><article-id pub-id-type="other" hwp:sub-type="tag">051409</article-id><article-version>1.1</article-version><article-categories><subj-group subj-group-type="author-type"><subject>Regular Article</subject></subj-group><subj-group subj-group-type="heading"><subject>New Results</subject></subj-group><subj-group subj-group-type="hwp-journal-coll" hwp:journal-coll-id="Bioinformatics" hwp:journal="biorxiv"><subject>Bioinformatics</subject></subj-group></article-categories><title-group><article-title hwp:id="article-title-1">A Graph Extension of the Positional Burrows-Wheeler Transform and its Applications</article-title></title-group><contrib-group hwp:id="contrib-group-1"><contrib contrib-type="author" hwp:id="contrib-1"><contrib-id contrib-id-type="orcid" authenticated="false">http://orcid.org/0000-0001-5828-047X</contrib-id><name name-style="western" hwp:sortable="Novak Adam M."><surname>Novak</surname><given-names>Adam M.</given-names></name><xref ref-type="aff" rid="a1" hwp:id="xref-aff-1-1" hwp:rel-id="aff-1">1</xref><object-id pub-id-type="other" hwp:sub-type="orcid" xlink:href="http://orcid.org/0000-0001-5828-047X"/></contrib><contrib contrib-type="author" hwp:id="contrib-2"><name name-style="western" hwp:sortable="Garrison Erik"><surname>Garrison</surname><given-names>Erik</given-names></name><xref ref-type="aff" rid="a2" hwp:id="xref-aff-2-1" hwp:rel-id="aff-2">2</xref></contrib><contrib contrib-type="author" hwp:id="contrib-3"><name name-style="western" hwp:sortable="Paten Benedict"><surname>Paten</surname><given-names>Benedict</given-names></name><xref ref-type="aff" rid="a1" hwp:id="xref-aff-1-2" hwp:rel-id="aff-1">1</xref></contrib><aff id="a1" hwp:id="aff-1" hwp:rev-id="xref-aff-1-1 xref-aff-1-2"><label>1</label><institution hwp:id="institution-1">Genomics Institute, University of California Santa Cruz</institution>, Santa Cruz, CA 95064, <country>USA</country></aff><aff id="a2" hwp:id="aff-2" hwp:rev-id="xref-aff-2-1"><label>2</label><institution hwp:id="institution-2">Wellcome Trust Sanger Institute</institution>, Cambridge, <country>UK</country></aff></contrib-group><pub-date pub-type="epub-original" hwp:start="2016"><year>2016</year></pub-date><pub-date pub-type="hwp-created" hwp:start="2016-05-02T16:03:14-07:00">
    <day>2</day><month>5</month><year>2016</year>
  </pub-date><pub-date pub-type="hwp-received" hwp:start="2016-05-02T16:03:14-07:00">
    <day>2</day><month>5</month><year>2016</year>
  </pub-date><pub-date pub-type="epub" hwp:start="2016-05-02T16:40:21-07:00">
    <day>2</day><month>5</month><year>2016</year>
  </pub-date><pub-date pub-type="epub-version" hwp:start="2016-05-02T16:40:21-07:00">
    <day>2</day><month>5</month><year>2016</year>
  </pub-date><elocation-id>051409</elocation-id><history hwp:id="history-1">
<date date-type="received" hwp:start="2016-05-02"><day>02</day><month>5</month><year>2016</year></date>
<date date-type="accepted" hwp:start="2016-05-02"><day>02</day><month>5</month><year>2016</year></date>
</history><permissions><copyright-statement hwp:id="copyright-statement-1">© 2016, Posted by Cold Spring Harbor Laboratory</copyright-statement><copyright-year>2016</copyright-year><license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by/4.0/" hwp:id="license-1"><p hwp:id="p-1">This pre-print is available under a Creative Commons License (Attribution 4.0 International), CC BY 4.0, as described at <ext-link l:rel="related" l:ref-type="uri" l:ref="http://creativecommons.org/licenses/by/4.0/" ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/" hwp:id="ext-link-1">http://creativecommons.org/licenses/by/4.0/</ext-link></p></license></permissions><self-uri xlink:href="051409.pdf" content-type="pdf" xlink:role="full-text"/><self-uri l:ref="forthcoming:yes" c:role="http://schema.highwire.org/variant/abstract" xlink:role="abstract" content-type="xhtml+xml" hwp:variant="yes"/><self-uri l:ref="forthcoming:yes" c:role="http://schema.highwire.org/variant/full-text" xlink:href="file:/content/biorxiv/vol0/issue2019/pdf/051409v1.pdf" hwp:variant="yes" content-type="pdf" xlink:role="full-text"/><self-uri l:ref="forthcoming:yes" c:role="http://schema.highwire.org/variant/full-text" xlink:role="full-text" content-type="xhtml+xml" hwp:variant="yes"/><self-uri l:ref="forthcoming:yes" c:role="http://schema.highwire.org/variant/source" xlink:role="source" content-type="xml" xlink:show="none" hwp:variant="yes"/><self-uri l:ref="forthcoming:yes" c:role="http://schema.highwire.org/variant/original" xlink:role="original" content-type="xml" xlink:show="none" hwp:variant="yes" xlink:href="051409.xml"/><self-uri content-type="abstract" xlink:href="file:/content/biorxiv/vol0/issue2019/abstracts/051409v1/051409v1.htslp"/><self-uri content-type="fulltext" xlink:href="file:/content/biorxiv/vol0/issue2019/fulltext/051409v1/051409v1.htslp"/><abstract hwp:id="abstract-1"><label>1</label><title hwp:id="title-1">Abstract</title><p hwp:id="p-2">We present a generalization of the Positional Burrows-Wheeler Transform (PBWT) to genome graphs, which we call the gPBWT. A genome graph is a collapsed representation of a set of genomes described as a graph. In a genome graph, a haplotype corresponds to a restricted form of walk. The gPBWT is a compressible representation of a set of these graph-encoded haplotypes that allows for efficient subhaplotype match queries. We give efficient algorithms for gPBWT construction and query operations. We describe our implementation, showing the compression and search of 1000 Genomes data. As a demonstration, we use the gPBWT to quickly count the number of haplotypes consistent with random walks in a genome graph, and with the paths taken by mapped reads; results suggest that haplotype consistency information can be practically incorporated into graph-based read mappers.</p></abstract><counts><page-count count="11"/></counts></article-meta></front><body><sec id="s1" hwp:id="sec-1"><label>2</label><title hwp:id="title-2">Introduction</title><p hwp:id="p-3">The PBWT is a compressable data structure for storing haplotypes that provides an efficient search operation for subhaplotype matches [<xref rid="c2" ref-type="bibr" hwp:id="xref-ref-2-1" hwp:rel-id="ref-2">2</xref>]. Implementations, such as BGT (<ext-link l:rel="related" l:ref-type="uri" l:ref="https://github.com/lh3/bgt" ext-link-type="uri" xlink:href="https://github.com/lh3/bgt" hwp:id="ext-link-2">https://github.com/lh3/bgt</ext-link>), can be used to compactly store and query thousands of samples. The PBWT can also allow existing haplotype-based algorithms to work on much larger collections of haplotypes than would otherwise be practical [<xref rid="c4" ref-type="bibr" hwp:id="xref-ref-4-1" hwp:rel-id="ref-4">4</xref>]. In the PBWT, each site (corresponding to a genetic variant) is a binary feature and the sites are totally ordered. The input haplotypes to the PBWT are binary strings, with each element in the string indicating the state of a site. In the generalization we present, each input haplotype is a walk in a general bidirected graph. This allows haplotypes to be partial (they can start and end at arbitrary nodes) and to traverse arbitrary structural variation. It does not require the sites (nodes in the graph) to have a biologically relevant ordering in order to provide compression. However, despite these generalizations, the core data structures are similar, the compression still exploits genetic linkage and the haplotype matching algorithm is essentially the same.</p></sec><sec id="s2" hwp:id="sec-2"><label>3</label><title hwp:id="title-3">Definitions</title><p hwp:id="p-4">We define <italic toggle="yes">G</italic> = (<italic toggle="yes">V, E</italic>) as a <bold>genome graph</bold> in a bidirected formulation [<xref rid="c5" ref-type="bibr" hwp:id="xref-ref-5-1" hwp:rel-id="ref-5">5</xref>,<xref rid="c6" ref-type="bibr" hwp:id="xref-ref-6-1" hwp:rel-id="ref-6">6</xref>]. Each node in <italic toggle="yes">V</italic> has a DNA-sequence label; a left, or 5′, <bold>side;</bold> and a right, or 3′, side. Each edge in <italic toggle="yes">E</italic> is a pairset of sides. The graph is not a multigraph: only one edge may connect a given pair of sides and thus only one <bold>self-loop</bold> can be present on any given side.</p><p hwp:id="p-5">We consider all the sides in the graph to be (arbitrarily) ordered relative to one another. We also define the idea of the <bold>opposite</bold> of a side <italic toggle="yes">s</italic>, with the notation <inline-formula hwp:id="inline-formula-1"><alternatives hwp:id="alternatives-1"><inline-graphic xlink:href="051409_inline1.gif" hwp:id="inline-graphic-1"/></alternatives></inline-formula> meaning the side of s’s node which is not <italic toggle="yes">s</italic> (i.e. the left side of the node if <italic toggle="yes">s</italic> is the right side, and the right side of the node if <italic toggle="yes">s</italic> is the left side). Finally, we use the notation <italic toggle="yes">n</italic>(<italic toggle="yes">s</italic>) to denote the node to which a side <italic toggle="yes">s</italic> belongs.</p><p hwp:id="p-6">Within the graph <italic toggle="yes">G</italic>, we define the concept of a <bold>thread</bold>, which can be used to represent a haplotype or haplotype fragment. A thread <italic toggle="yes">t</italic> on <italic toggle="yes">G</italic> is a reversible nonempty sequence of sides, such that for 0 ≤ <italic toggle="yes">i</italic> &lt; <italic toggle="yes">N</italic> sides <italic toggle="yes">t</italic><sub>2<italic toggle="yes">i</italic></sub> and <italic toggle="yes">t</italic><sub>2<italic toggle="yes">i</italic>+1</sub> are opposites of each other, and such that <italic toggle="yes">G</italic> contains an edge connecting every pair of sides <italic toggle="yes">t</italic><sub>2<italic toggle="yes">i</italic>+1</sub> and <italic toggle="yes">t</italic><sub>2<italic toggle="yes">i</italic>+1</sub>. In other words, a thread is a walk through the sides of the graph that alternates traversing nodes and traversing edges and which starts and ends with nodes. Note that a thread is reversible: exactly reversing the sequence of sides making up a thread produces an equivalent thread. We call a thread traversed in a certain direction an <bold>orientation</bold>.</p><p hwp:id="p-7">We consider <italic toggle="yes">G</italic> to have associated with it a collection of <bold>embedded</bold> threads, denoted as <italic toggle="yes">T</italic>. We propose an efficient storage and query mechanism for <italic toggle="yes">T</italic> given <italic toggle="yes">G</italic>.</p><p hwp:id="p-8">We call an instance of side in a thread a <bold>visit</bold>; a thread may visit a given side multiple times. Consider all visits of threads in <italic toggle="yes">T</italic> to a side <italic toggle="yes">s</italic> where the thread arrives at <italic toggle="yes">s</italic> either by traversing an edge incident to <italic toggle="yes">s</italic> (and not by traversing <italic toggle="yes">n</italic>(<italic toggle="yes">s</italic>)) or by beginning at <italic toggle="yes">s</italic>. For each such visit, take the sequence of sides coming before this arrival at <italic toggle="yes">s</italic> in the thread and reverse it, and then sort the visits lexicographically by these sequences of sides, breaking ties by an arbitrary global ordering of the threads. Then, for each visit, look two steps ahead in its thread (past <italic toggle="yes">s</italic> and <inline-formula hwp:id="inline-formula-2"><alternatives hwp:id="alternatives-2"><inline-graphic xlink:href="051409_inline2.gif" hwp:id="inline-graphic-2"/></alternatives></inline-formula>), and note what side comes next (or the null side if the thread ends). After repeating for all the sorted visits to <italic toggle="yes">s</italic>, take all the noted sides in order and produce the array <italic toggle="yes">B</italic><sub><italic toggle="yes">s</italic></sub>[] for side <italic toggle="yes">s</italic>. An example <italic toggle="yes">B</italic>[] array and its interpretation are shown in <xref ref-type="fig" rid="fig1" hwp:id="xref-fig-1-1" hwp:rel-id="F1">Figure 1</xref>. (Note that, throughout, arrays are indexed from 0 and can produce their lengths trivially upon demand.)</p><fig id="fig1" position="float" fig-type="figure" orientation="portrait" hwp:id="F1" hwp:rev-id="xref-fig-1-1"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;051409v1/FIG1</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F1</object-id><object-id pub-id-type="publisher-id">fig1</object-id><label>Fig. 1.</label><caption hwp:id="caption-1"><p hwp:id="p-9">An illustration of the <italic toggle="yes">B</italic><sub>0</sub>[] array for a single side numbered 0. Threads visiting this side may enter their next nodes on sides 1, 2, or 3. The <italic toggle="yes">B</italic><sub>0</sub>[] array records, for each visit of a thread to side 0, the side on which it enters its next node. This determines through which of the available edges it should leave the current node. Because threads tend to be similar to each other, they are likely to run in “ribbons” of multiple threads that both enter and leave together. These ribbons cause the <italic toggle="yes">B</italic><sub><italic toggle="yes">s</italic></sub> [] arrays to contain runs of identical values, which may be compressed.</p></caption><graphic xlink:href="051409_fig1" position="float" orientation="portrait" hwp:id="graphic-1"/></fig><p hwp:id="p-10">Each unoriented edge {s,<italic toggle="yes">s’</italic>} in <italic toggle="yes">E</italic> has two orientations (<italic toggle="yes">s, s’</italic>) and (<italic toggle="yes">s’, s</italic>). Let c() be a function of these oriented edges, such that for an oriented edge (<italic toggle="yes">s’, s</italic>), <italic toggle="yes">c(s, s')</italic> is the smallest index in <italic toggle="yes">B</italic><sub><italic toggle="yes">s’</italic></sub> [] of a visit of <italic toggle="yes">s’</italic> that arrives at <italic toggle="yes">s’</italic> by traversing {<italic toggle="yes">s,s’</italic>}. Note that, because of the global ordering of sides and the sorting rules defined for <italic toggle="yes">B</italic><sub>s’</sub>[] above, <italic toggle="yes">c</italic>(<italic toggle="yes">s</italic><sub>0</sub>, <italic toggle="yes">s’</italic>) will be less than or equal to <italic toggle="yes">c</italic>(<italic toggle="yes">s</italic><sub>1</sub>, <italic toggle="yes">s’</italic>) for <italic toggle="yes">s</italic><sub>0</sub> &lt;<italic toggle="yes">s</italic><sub>1</sub> both adjacent to <italic toggle="yes">s’</italic>.</p><p hwp:id="p-11">For a given <italic toggle="yes">G</italic>, we call the combination of the <italic toggle="yes">c</italic>() function and the <italic toggle="yes">B</italic>[] arrays a <bold>graph Positional Burrows Wheeler Transform</bold> (<bold>gPBWT</bold>). We submit that a gPBWT is sufficient to represent <italic toggle="yes">T</italic>, and, moreover, that it allows efficient counting of the number of threads in <italic toggle="yes">T</italic> that contain a given new thread as a subthread. <xref ref-type="fig" rid="fig2" hwp:id="xref-fig-2-1" hwp:rel-id="F2">Figure 2</xref> and <xref ref-type="table" rid="tbl1" hwp:id="xref-table-wrap-1-1" hwp:rel-id="T1">Table 1</xref> give a worked example.</p><fig id="fig2" position="float" fig-type="figure" orientation="portrait" hwp:id="F2" hwp:rev-id="xref-fig-2-1 xref-fig-2-2"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;051409v1/FIG2</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F2</object-id><object-id pub-id-type="publisher-id">fig2</object-id><label>Fig. 2.</label><caption hwp:id="caption-2"><p hwp:id="p-12">A diagram of a graph containing two embedded threads. The graph consists of nodes [1, 2, 3,4,5], with sides [1<italic toggle="yes">L</italic>, 1<italic toggle="yes">R</italic>, 2<italic toggle="yes">L</italic>, 2<italic toggle="yes">R</italic>,…], connected by edges [1<italic toggle="yes">R</italic>, 3<italic toggle="yes">L</italic>], [2<italic toggle="yes">R</italic>, 3<italic toggle="yes">L</italic>], [3<italic toggle="yes">R</italic>, 4<italic toggle="yes">L</italic>], [3<italic toggle="yes">R</italic>, 5<italic toggle="yes">L</italic>], [4<italic toggle="yes">R</italic>,4<italic toggle="yes">R</italic>], and [5<italic toggle="yes">R</italic>, 5<italic toggle="yes">L</italic>]. Embedded threads travel on the right-hand side of the nodes they are traveling through. Each thread here corresponds to a pair of “lanes” running in opposite directions. Visits are ordered from top to bottom, with “lanes” for lesser visits above those for greater ones. the “lanes” on the top half of each node are ordered in correspondence with the <italic toggle="yes">B</italic><sub><italic toggle="yes">s</italic></sub>[] entries for the right side of the node, and those on the bottom half are ordered in correspondence with the <italic toggle="yes">B</italic><sub><italic toggle="yes">s</italic></sub>[] entries for the right side of the node. The threads shown here are [1<italic toggle="yes">L</italic>, 1<italic toggle="yes">R</italic>, 3<italic toggle="yes">L</italic>, 3<italic toggle="yes">R</italic>, 5<italic toggle="yes">L</italic>, 5<italic toggle="yes">R</italic>, 5<italic toggle="yes">L</italic>, 5<italic toggle="yes">R</italic>] and [2<italic toggle="yes">L</italic>, 2<italic toggle="yes">R</italic>, 3<italic toggle="yes">L</italic>,3<italic toggle="yes">R</italic>, 4<italic toggle="yes">L</italic>,4<italic toggle="yes">R</italic>, 4<italic toggle="yes">R</italic>, 4<italic toggle="yes">L</italic>].</p></caption><graphic xlink:href="051409_fig2" position="float" orientation="portrait" hwp:id="graphic-2"/></fig><table-wrap id="tbl1" orientation="portrait" position="float" hwp:id="T1" hwp:rev-id="xref-table-wrap-1-1"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;051409v1/TBL1</object-id><object-id pub-id-type="other" hwp:sub-type="slug">T1</object-id><object-id pub-id-type="publisher-id">tbl1</object-id><label>Table 1.</label><caption hwp:id="caption-3"><p hwp:id="p-13"><italic toggle="yes">B</italic><sub><italic toggle="yes">s</italic></sub>[] and <italic toggle="yes">c</italic>() values for the embedding of threads illustrated in <xref ref-type="fig" rid="fig2" hwp:id="xref-fig-2-2" hwp:rel-id="F2">Figure 2</xref>.</p></caption><graphic xlink:href="051409_tbl1" position="float" orientation="portrait" hwp:id="graphic-3"/></table-wrap></sec><sec id="s3" hwp:id="sec-3"><label>4</label><title hwp:id="title-4">Extracting Threads</title><p hwp:id="p-14">To reproduce <italic toggle="yes">T</italic> from <italic toggle="yes">G</italic>, and the gPBWT, consider each side <italic toggle="yes">s</italic> in <italic toggle="yes">G</italic> in turn. Establish how many threads begin (or, equivalently, end) at <italic toggle="yes">s</italic> by taking the minimum of <italic toggle="yes">c</italic>(<italic toggle="yes">x, s</italic>) for all sides <italic toggle="yes">x</italic> adjacent to <italic toggle="yes">s</italic>. If <italic toggle="yes">s</italic> has no incident edges, take the length of <italic toggle="yes">B</italic><sub><italic toggle="yes">s</italic></sub>[] instead. Call this number <italic toggle="yes">b</italic>. Then, for <italic toggle="yes">i</italic> running from 0 to <italic toggle="yes">b</italic>, exclusive, begin a new thread at <italic toggle="yes">n</italic>(<italic toggle="yes">s</italic>) with the sides [<italic toggle="yes">s</italic>, <inline-formula hwp:id="inline-formula-3"><alternatives hwp:id="alternatives-3"><inline-graphic xlink:href="051409_inline3.gif" hwp:id="inline-graphic-3"/></alternatives></inline-formula>]. Next, we traverse from <italic toggle="yes">n</italic>(<italic toggle="yes">s</italic>) to the next node. Consult the <italic toggle="yes">B</italic><sub><italic toggle="yes">s</italic></sub>[<italic toggle="yes">i</italic>] entry. If it is the null side, stop traversing, yield the thread, and start again from the original node <italic toggle="yes">s</italic> with the next <italic toggle="yes">i</italic> value less than <italic toggle="yes">b</italic>. Otherwise, traverse to side <italic toggle="yes">s’</italic> = <italic toggle="yes">B</italic><sub><italic toggle="yes">s</italic></sub>[<italic toggle="yes">i</italic>]. Calculate the arrival index <italic toggle="yes">i’</italic> as <italic toggle="yes">c</italic>(<inline-formula hwp:id="inline-formula-4"><alternatives hwp:id="alternatives-4"><inline-graphic xlink:href="051409_inline4.gif" hwp:id="inline-graphic-4"/></alternatives></inline-formula>, <italic toggle="yes">s’</italic>) plus the number of entries in <italic toggle="yes">B</italic><sub><italic toggle="yes">s</italic></sub>[] before entry <italic toggle="yes">i</italic> that are also equal to <italic toggle="yes">s’</italic>. This gives the index in <inline-formula hwp:id="inline-formula-5"><alternatives hwp:id="alternatives-5"><inline-graphic xlink:href="051409_inline5.gif" hwp:id="inline-graphic-5"/></alternatives></inline-formula> of the thread being extracted. Then append <italic toggle="yes">s’</italic> and <inline-formula hwp:id="inline-formula-6"><alternatives hwp:id="alternatives-6"><inline-graphic xlink:href="051409_inline6.gif" hwp:id="inline-graphic-6"/></alternatives></inline-formula> to the growing thread, and repeat the traversal process with <italic toggle="yes">i</italic> ← <italic toggle="yes">i’</italic> and <italic toggle="yes">s</italic> ← <italic toggle="yes">s’</italic>, until the end of the thread is reached.</p><p hwp:id="p-15">This process will enumerate all threads in the graph, and will enumerate each such thread twice (once from each end). The threads merely need to be deduplicated (such that two enumerated threads produce one actual thread, as the original collection of embedded threads may have had duplicates) in order to produce the collection of embedded threads <italic toggle="yes">T</italic>. Pseudocode for thread extraction is shown in Algorithm 1.</p><statement hwp:id="statement-1"><label>Algorithm 1</label><title hwp:id="title-5">Algorithm for extracting threads from a graph.</title><p hwp:id="p-16"><bold>function</bold> starting_AT(<italic toggle="yes">Side, G, B</italic>[], <italic toggle="yes">c</italic>())</p><p hwp:id="p-17">▹ Count instances of threads starting at <italic toggle="yes">Side</italic>.</p><p hwp:id="p-18">▹ Replace by an access to a partial sum data structure if appropriate.</p><p hwp:id="p-19"><bold>if</bold> <italic toggle="yes">Side</italic> has incident edges <bold>then</bold></p><p hwp:id="p-20"><bold>return</bold> <italic toggle="yes">c</italic>(<italic toggle="yes">s,Side</italic>) for minimum <italic toggle="yes">s</italic> over all sides adjacent to <italic toggle="yes">Side</italic>.</p><p hwp:id="p-21"><bold>else</bold></p><p hwp:id="p-22"><bold>return</bold> LENGTH(<italic toggle="yes">B</italic><sub><italic toggle="yes">Side</italic></sub>[])</p><p hwp:id="p-23"><bold>function</bold> RANK(<italic toggle="yes">b</italic>[], <italic toggle="yes">Index, Item</italic>)</p><p hwp:id="p-24">▹ Count instances of <italic toggle="yes">Item</italic> before <italic toggle="yes">Index</italic> in <italic toggle="yes">b</italic>[].</p><p hwp:id="p-25">▹ Replace by RANK of a rank-select data structure if appropriate.</p><p hwp:id="p-26"><italic toggle="yes">Rank</italic> ⟵;0</p><p hwp:id="p-27"><bold>for</bold> <italic toggle="yes">i</italic> ⟵ 0; <italic toggle="yes">i</italic> &lt; <italic toggle="yes">Indec i</italic> ⟵ <italic toggle="yes">i</italic> + 1 <bold>do</bold></p><p hwp:id="p-28"><bold>if</bold> <italic toggle="yes">b</italic>[<italic toggle="yes">i</italic>] = <italic toggle="yes">Item</italic> <bold>then</bold></p><p hwp:id="p-29"><italic toggle="yes">Rank</italic> ⟵; <italic toggle="yes">Rank</italic> + 1</p><p hwp:id="p-30"><bold>return</bold> <italic toggle="yes">RANK</italic></p><p hwp:id="p-31"><bold>function</bold> WHERE_TO(<italic toggle="yes">Side, Index, B</italic>[], <italic toggle="yes">c</italic>())</p><p hwp:id="p-32">▹ For thread visiting <italic toggle="yes">Side</italic> with <italic toggle="yes">Index</italic> in the reverse prefix sort order, get the corresponding sort index of the thread for the next side in the thread.</p><p hwp:id="p-33"><bold>return</bold> <italic toggle="yes">c</italic>(<inline-formula hwp:id="inline-formula-7"><alternatives hwp:id="alternatives-7"><inline-graphic xlink:href="051409_inline7.gif" hwp:id="inline-graphic-7"/></alternatives></inline-formula>, <italic toggle="yes">B</italic><sub><italic toggle="yes">Sid</italic></sub> [<italic toggle="yes">Index</italic>]) + R<sc>ank</sc>(<italic toggle="yes">B</italic><sub><italic toggle="yes">Side</italic></sub>[], <italic toggle="yes">Index, B</italic><sub><italic toggle="yes">Side</italic></sub>[<italic toggle="yes">Index</italic>])</p><p hwp:id="p-34"><bold>function</bold> EXTRACT(<italic toggle="yes">G, c</italic>(), <italic toggle="yes">B</italic>[])</p><p hwp:id="p-35">▹ Extract all oriented threads from graph <italic toggle="yes">G</italic>.</p><p hwp:id="p-36"><bold>for all</bold> Side <italic toggle="yes">s</italic> in <italic toggle="yes">G</italic> <bold>do</bold>
<italic toggle="yes">TotalStarting</italic> ⟵ STARTING_AT(<italic toggle="yes">s</italic>, <italic toggle="yes">G, B</italic>[], <italic toggle="yes">c</italic>())</p><p hwp:id="p-37"><bold>for</bold> <italic toggle="yes">i</italic> ⟵ 0; <italic toggle="yes">i</italic> &lt; <italic toggle="yes">TotalStarting</italic>; <italic toggle="yes">i</italic> ⟵ <italic toggle="yes">i</italic> + 1 <bold>do</bold></p><p hwp:id="p-38"><italic toggle="yes">Side</italic> ⟵ <italic toggle="yes">s</italic></p><p hwp:id="p-39"><italic toggle="yes">Index</italic> ⟵ <italic toggle="yes">i</italic></p><p hwp:id="p-40"><italic toggle="yes">Thread</italic> ⟵ [<italic toggle="yes">s</italic>, <inline-formula hwp:id="inline-formula-8"><alternatives hwp:id="alternatives-8"><inline-graphic xlink:href="051409_inline8.gif" hwp:id="inline-graphic-8"/></alternatives></inline-formula>]</p><p hwp:id="p-41"><bold>loop</bold></p><p hwp:id="p-42"><italic toggle="yes">NextSide ⟵ <italic toggle="yes">B</italic><sub><italic toggle="yes">Side</italic></sub> [<italic toggle="yes">Index</italic>]</italic></p><p hwp:id="p-43"><bold>if</bold> <italic toggle="yes">NextSide</italic> = null <bold>then</bold></p><p hwp:id="p-44"><bold>yield</bold> <italic toggle="yes">Thread</italic></p><p hwp:id="p-45"><bold>break</bold></p><p hwp:id="p-46"><italic toggle="yes">Thread</italic> ⟵ <italic toggle="yes">Thread</italic> + [<italic toggle="yes">NextSide</italic>, <inline-formula hwp:id="inline-formula-9"><alternatives hwp:id="alternatives-9"><inline-graphic xlink:href="051409_inline9.gif" hwp:id="inline-graphic-9"/></alternatives></inline-formula>]</p><p hwp:id="p-47"><italic toggle="yes">Index</italic> ⟵ WHERE_TO(<italic toggle="yes">Side, Index, B</italic>[], <italic toggle="yes">c</italic>())</p><p hwp:id="p-48"><italic toggle="yes">Side</italic> ⟵ <italic toggle="yes">NextSide</italic></p></statement></sec><sec id="s4" hwp:id="sec-4"><label>5</label><title hwp:id="title-6">Succinct Storage</title><p hwp:id="p-49">For the case of storing haplotype threads specifically, we can assume that, because of linkage, many threads in <italic toggle="yes">T</italic> are identical local haplotypes for long runs, diverging from each other only at relatively rare crossovers or mutations. Because of the reverse prefix sorting of the visits to each side, successive entries in the <italic toggle="yes">B</italic>[] arrays are thus quite likely to refer to locally identical haplotypes, and thus to contain the same value for the side to enter the next node on. Thus, the <italic toggle="yes">B</italic>[] arrays should benefit from run-length compression. Moreover, since (as will be seen below) one of the most common operations on the <italic toggle="yes">B</italic>[] arrays will be expected to be rank queries, a succinct representation, such as a collection of bit vectors or a dynamic wavelet tree, would be appropriate. To keep the alphabet of symbols in the <italic toggle="yes">B</italic>[] arrays small, it is possible to replace the stored sides for each <italic toggle="yes">B</italic>[] with numbers referring to the nodes adjacent to <inline-formula hwp:id="inline-formula-10"><alternatives hwp:id="alternatives-10"><inline-graphic xlink:href="051409_inline10.gif" hwp:id="inline-graphic-10"/></alternatives></inline-formula></p><p hwp:id="p-50">We note that, for contemporary variant collections (e.g. the 1000 Genomes Project), the underlying graph <italic toggle="yes">G</italic> may be very large, while there may be relatively few threads (of the order of thousands) [<xref rid="c1" ref-type="bibr" hwp:id="xref-ref-1-1" hwp:rel-id="ref-1">1</xref>]. Implementers should thus consider combining multiple <italic toggle="yes">B</italic>[] arrays into a single data structure to minimize overhead.</p></sec><sec id="s5" hwp:id="sec-5"><label>6</label><title hwp:id="title-7">Embedding Threads</title><p hwp:id="p-51">A trivial construction algorithm for the gPBWT is to independently construct <italic toggle="yes">B</italic><sub><italic toggle="yes">s</italic></sub>[] and <italic toggle="yes">c</italic>(<italic toggle="yes">s, s’</italic>) for all sides <italic toggle="yes">s</italic> and oriented edges (<italic toggle="yes">s, s’</italic>) according to their definitions above. However, this would be very inefficient. Here we present an efficient algorithm for gPBWT construction, in which the problem of constructing the gPBWT is reduced to the problem of embedding an additional thread.</p><p hwp:id="p-52">Each thread is embedded by embedding its two orientations, one after the other. To embed a thread orientation <italic toggle="yes">t</italic> = [<italic toggle="yes">t</italic><sub>0</sub>, <italic toggle="yes">t</italic><sub>1</sub>,…<italic toggle="yes">t</italic><sub>2<italic toggle="yes">N</italic></sub>, <italic toggle="yes">t</italic><sub>2<italic toggle="yes">N</italic></sub>+1] we first look at node <italic toggle="yes">n</italic>(<italic toggle="yes">t</italic><sub>0</sub>), entering by <italic toggle="yes">t</italic><sub>0</sub>. We insert a new entry for this visit into <italic toggle="yes">B</italic><sub><italic toggle="yes">t</italic>0</sub>[], lengthening the array by one. The location of the new entry is near the beginning, before all the entries for visits arriving by edges, with the exact location determined by the arbitrary order imposed on thread orientations. Thus, its addition necessitates incrementing <italic toggle="yes">c</italic>(<italic toggle="yes">s,t</italic><sub>0</sub>) by one for all oriented edges (<italic toggle="yes">s,t</italic><sub>0</sub>) incident on <italic toggle="yes">t</italic><sub>0</sub> from sides <italic toggle="yes">s</italic> in <italic toggle="yes">G</italic>. If no other order of thread orientations suggests itself, the order created by their addition to the graph will suffice, in which case the new entry can be placed at the beginning of <italic toggle="yes">B</italic><sub><italic toggle="yes">t</italic>0</sub>[]. We call the location of this entry <italic toggle="yes">k</italic>. The value of the entry will be <italic toggle="yes">t</italic><sub>2</sub>, or, if <italic toggle="yes">t</italic> is not sufficiently long, the null side, in which case we have finished.</p><p hwp:id="p-53">If we have not finished the thread, we first increment <italic toggle="yes">c</italic>(<italic toggle="yes">s,t</italic><sub>2</sub>) by one for each side <italic toggle="yes">s</italic> adjacent to <italic toggle="yes">t</italic><sub>2</sub> and after <italic toggle="yes">t</italic><sub>1</sub> in the global ordering of sides. This updates the <italic toggle="yes">c</italic>() function to account for the insertion into <italic toggle="yes">B</italic><sub><italic toggle="yes">t</italic>2</sub>[] we are about to make. We then find the index at which the next visit in <italic toggle="yes">t</italic> ought to have its entry in <italic toggle="yes">B</italic><sub><italic toggle="yes">t</italic>2</sub>[], given that the entry of the current visit in <italic toggle="yes">t</italic> falls at index <italic toggle="yes">k</italic> in <italic toggle="yes">B</italic><sub><italic toggle="yes">t</italic>0</sub>[]. This is given by the same procedure used to calculate the arrival index when extracting threads, denoted as <italic toggle="yes">WHERE_TO</italic>(<italic toggle="yes">t</italic><sub>1</sub>, <italic toggle="yes">k</italic>) (see Alg. 1). Setting <italic toggle="yes">k</italic> to this value, we can then repeat the preceding steps to embed <italic toggle="yes">t</italic><sub>2</sub>, <italic toggle="yes">t</italic><sub>3</sub>, etc. until <italic toggle="yes">t</italic> is exhausted and its embedding terminated with a null-side entry. Pseudocode for this process is shown in Algorithm 2.</p><p hwp:id="p-54">Assuming that the <italic toggle="yes">B</italic>[] array information is both indexed for <italic toggle="yes">O</italic>(<italic toggle="yes">log</italic>(<italic toggle="yes">n</italic>)) rank queries and stored in such a way as to allow <italic toggle="yes">O</italic>(<italic toggle="yes">log</italic>(<italic toggle="yes">n</italic>)) insertion and update (in the length of the array <italic toggle="yes">n</italic>), this insertion algorithm is <italic toggle="yes">O</italic>(<italic toggle="yes">N</italic> · <italic toggle="yes">log</italic>(<italic toggle="yes">N</italic> + <italic toggle="yes">E</italic>)) in the length of the thread to be inserted (<italic toggle="yes">N</italic>) and the total length of existing threads (<italic toggle="yes">E</italic>). Inserting <italic toggle="yes">M</italic> threads of length <italic toggle="yes">N</italic> will take <italic toggle="yes">O</italic>(<italic toggle="yes">M</italic> · <italic toggle="yes">N</italic> · <italic toggle="yes">log</italic>(<italic toggle="yes">M · N</italic>)) time.</p><statement hwp:id="statement-2"><label>Algorithm 2</label><title hwp:id="title-8">Algorithm for embedding a thread in a graph.</title><p hwp:id="p-55"><bold>procedure</bold> INSERT(<italic toggle="yes">b</italic>[], <italic toggle="yes">Index, Item)</italic></p><p hwp:id="p-56">▹ Insert <italic toggle="yes">Item</italic> at <italic toggle="yes">Index</italic> in <italic toggle="yes">b</italic>[].</p><p hwp:id="p-57">▹ Replace by insert of a rank-select-insert data structure if appropriate.</p><p hwp:id="p-58">LENGTH(<italic toggle="yes">b</italic>[]) ⟵ LENGTH(<italic toggle="yes">b</italic>[]) + 1 ▹ Increase length of the array by 1</p><p hwp:id="p-59"><bold>for</bold> <italic toggle="yes">i</italic> ⟵ LENGTH(<italic toggle="yes">b</italic>[]) − 1; <italic toggle="yes">i</italic> &gt; <italic toggle="yes">Index; i</italic> ⟵ <italic toggle="yes">i</italic> − 1 <bold>do</bold></p><p hwp:id="p-60"><italic toggle="yes">b</italic>[<italic toggle="yes">i</italic>] ⟵ <italic toggle="yes">b</italic>[<italic toggle="yes">i</italic> − 1]</p><p hwp:id="p-61"><italic toggle="yes">b</italic>[<italic toggle="yes">Index</italic>] = <italic toggle="yes">Item</italic></p><p hwp:id="p-62"><bold>procedure</bold> INCREMENT_C(<italic toggle="yes">Side, NextSide, c</italic>())</p><p hwp:id="p-63">▹ Modify <italic toggle="yes">c</italic>() to reflect the addition of a visit to the edge (<italic toggle="yes">Side, NextSide</italic>).</p><p hwp:id="p-64"><bold>for all</bold> side <italic toggle="yes">s</italic> adjacent to <italic toggle="yes">NextSide</italic> in <italic toggle="yes">G</italic> <bold>do</bold></p><p hwp:id="p-65">if <italic toggle="yes">s</italic> &gt; <italic toggle="yes">Side</italic> in side ordering <bold>then</bold></p><p hwp:id="p-66"><italic toggle="yes">c</italic>(<italic toggle="yes">s, NextSide</italic>) ⟵ <italic toggle="yes">c</italic>(<italic toggle="yes">s, NextSide</italic>) + 1</p><p hwp:id="p-67"><bold>procedure</bold> EMBED(<italic toggle="yes">t, G, B</italic>[], <italic toggle="yes">c</italic>())</p><p hwp:id="p-68">▹ Embed an oriented thread <italic toggle="yes">t</italic> in graph <italic toggle="yes">G</italic>.</p><p hwp:id="p-69">▹ Call this twice to embed it for search in both directions.</p><p hwp:id="p-70"><italic toggle="yes">k</italic> ⟵ 0 ▹ Index we are at in <italic toggle="yes">B</italic><sub>t<sub>2i</sub></sub> []</p><p hwp:id="p-71"><bold>for</bold> <italic toggle="yes">i</italic> ⟵ 0; 2<italic toggle="yes">i</italic> &lt; LENGTH(<italic toggle="yes">t</italic>); <italic toggle="yes">i ⟵ <italic toggle="yes">i</italic> + 1 <bold>do</bold></italic></p><p hwp:id="p-72"><bold>if</bold> 2<italic toggle="yes">i</italic> + 2 &lt; LENGTH(<italic toggle="yes">t</italic>) <bold>then</bold></p><p hwp:id="p-73">▹ The thread has somewhere to go next.</p><p hwp:id="p-74">INSERT(<italic toggle="yes">B</italic><sub>t<sub>2i</sub></sub>[], <italic toggle="yes">k,t</italic><sub>2i</sub>+a2)</p><p hwp:id="p-75">INCREMENT_C(<italic toggle="yes">t</italic><sub>2i</sub>+1, <italic toggle="yes">t</italic><sub>2i</sub>+2, <italic toggle="yes">c</italic>())</p><p hwp:id="p-76"><italic toggle="yes">k</italic> ⟵ WHERE_TO(<italic toggle="yes">t</italic><sub>2i</sub>, <italic toggle="yes">k</italic>, <italic toggle="yes">B</italic>[], <italic toggle="yes">c</italic>())</p><p hwp:id="p-77"><bold>else</bold></p><p hwp:id="p-78">INSERT(<italic toggle="yes">B</italic><sub>t<sub>2i</sub></sub> [], <italic toggle="yes">k</italic>, null)</p></statement></sec><sec id="s6" hwp:id="sec-6"><label>7</label><title hwp:id="title-9">Counting Occurrences of Subthreads</title><p hwp:id="p-79">The generalized PBWT data structure presented here preserves some of the original PBWT’s efficient haplotype search properties [<xref rid="c2" ref-type="bibr" hwp:id="xref-ref-2-2" hwp:rel-id="ref-2">2</xref>]. The algorithm for counting all subthread instances in <italic toggle="yes">T</italic> of a new thread orientation <italic toggle="yes">t</italic> runs as follows.</p><p hwp:id="p-80">We define ƒ<sub><italic toggle="yes">i</italic></sub> and <italic toggle="yes">g</italic><sub><italic toggle="yes">i</italic></sub> as the first and past-the-last indexes for the range of visits of threads in <italic toggle="yes">T</italic> to side <italic toggle="yes">t</italic><sub>2i</sub>, ordered as in <italic toggle="yes">B</italic><sub>t<sub>2i</sub></sub>[].</p><p hwp:id="p-81">For the first step of the algorithm, ƒ<sub>0</sub> and <italic toggle="yes">g</italic><sub><italic toggle="yes">0</italic></sub> are initialized to 0 and the length of <italic toggle="yes">B</italic><sub>t<sub>0</sub></sub>[], respectively, so that they select all visits to node <italic toggle="yes">n</italic>(<italic toggle="yes">t</italic><sub>0</sub>), seen as entering through <italic toggle="yes">t</italic><sub>0</sub>. On subsequent steps, ƒ<sub>i+1</sub> and <italic toggle="yes">g</italic><sub>i+1</sub>, are calculated from ƒ<italic toggle="yes">i</italic> and <italic toggle="yes">g</italic><sub>i</sub> merely by applying the <italic toggle="yes">WHERE_TO</italic>() function (see Alg. 1). We calculate ƒ<sub>i+</sub>1 = WHERE_TO(<italic toggle="yes">t</italic><sub>2i</sub>, ƒ<sub>i</sub>) and <italic toggle="yes">g</italic><sub><italic toggle="yes">i</italic>+1</sub> = WHERE_TO(<italic toggle="yes">t</italic><sub>2i</sub>, <italic toggle="yes">g</italic><sub><italic toggle="yes">i</italic></sub>).</p><p hwp:id="p-82">This process can be repeated until either ƒ<sub>i+1</sub> ≥ <italic toggle="yes">g</italic><sub><italic toggle="yes">i</italic>+1</sub>, in which case we can conclude that the threads in the graph have no matches to <italic toggle="yes">t</italic> in its entirety, or until <italic toggle="yes">t</italic><sub>2<italic toggle="yes">N</italic></sub>, the last entry in <italic toggle="yes">t</italic>, has its range ƒ<italic toggle="yes">N</italic> and <italic toggle="yes">g</italic><sub><italic toggle="yes">N</italic></sub> calculated, in which case <italic toggle="yes">g</italic><sub>N</sub> — ƒ<italic toggle="yes">N</italic> gives the number of occurrences of <italic toggle="yes">t</italic> as a subthread in threads in <italic toggle="yes">T</italic>. Moreover, given the final range from counting the occurrences for a thread <italic toggle="yes">t</italic>, we can count the occurrences of any longer thread that begins with <italic toggle="yes">t</italic>, merely by continuing the algorithm with the additional entries in the longer thread.</p><p hwp:id="p-83">Assuming that the <italic toggle="yes">B</italic>[] arrays have been indexed for <italic toggle="yes">O</italic>(1) rank queries, the algorithm is <italic toggle="yes">O</italic>(<italic toggle="yes">N</italic>) in the length of the subthread <italic toggle="yes">t</italic> to be searched for, and has a runtime independent of the number of occurrences of <italic toggle="yes">t</italic>. Pseudocode is shown in Algorithm 3.</p><statement hwp:id="statement-3"><label>Algorithm 3</label><title hwp:id="title-10">Algorithm for searching for a subthread in the graph.</title><p hwp:id="p-84"><bold>function</bold> COUNT(<italic toggle="yes">t, G, B</italic>[], <italic toggle="yes">c</italic>())</p><p hwp:id="p-85">▹ Count occurrences of subthread <italic toggle="yes">t</italic> in graph <italic toggle="yes">G</italic>.</p><p hwp:id="p-86">ƒ ⟵ 0</p><p hwp:id="p-87"><italic toggle="yes">g</italic> ⟵ LENGTH(<italic toggle="yes">B</italic><sub>t<sub>0</sub></sub> [])</p><p hwp:id="p-88"><bold>for</bold> <italic toggle="yes">i</italic> ⟵ 0; 2(<italic toggle="yes">i</italic> + 1) &lt; LENGTH(<italic toggle="yes">t</italic>); <italic toggle="yes">i</italic> ⟵ <italic toggle="yes">i</italic> + 1 <bold>do</bold></p><p hwp:id="p-89">ƒ ⟵ WHERE_TO(<italic toggle="yes">t</italic><sub>2i</sub>, ƒ, <italic toggle="yes">B</italic>[], <italic toggle="yes">c</italic>())</p><p hwp:id="p-90"><italic toggle="yes">g</italic> ⟵ WHERE_TO(<italic toggle="yes">t</italic><sub>2i</sub>, <italic toggle="yes">g</italic>, <italic toggle="yes">B</italic>[], <italic toggle="yes">c</italic>())</p><p hwp:id="p-91"><bold>if</bold> ƒ ≥ <italic toggle="yes">g</italic> <bold>then</bold></p><p hwp:id="p-92"><bold>return</bold> 0</p><p hwp:id="p-93"><bold>return</bold> <italic toggle="yes">g</italic> − ƒ</p></statement></sec><sec id="s7" hwp:id="sec-7"><label>8</label><title hwp:id="title-11">Results</title><p hwp:id="p-94">The gPBWT was implemented within xg, the succinct graph indexing component of the vg variation graph toolkit [<xref rid="c3" ref-type="bibr" hwp:id="xref-ref-3-1" hwp:rel-id="ref-3">3</xref>]. Due to the succinct data structure libraries employed, efficient integer vector insert operations were not possible, and so a batch construction algorithm, applicable only to directed acyclic graphs, was implemented. A modified release of vg, which can be used to replicate the results shown here, is available from <ext-link l:rel="related" l:ref-type="uri" l:ref="https://github.com/adamnovak/vg/releases/tag/gpbwt-paper" ext-link-type="uri" xlink:href="https://github.com/adamnovak/vg/releases/tag/gpbwt-paper" hwp:id="ext-link-3">https://github.com/adamnovak/vg/releases/tag/gpbwt-paper</ext-link>.</p><p hwp:id="p-95">The modified vg was used to create a variation graph for human chromosome 22, using the 1000 Genomes Phase 3 VCF on the hg19 assembly, embedding information about the correspondence between VCF variants and graph elements [<xref rid="c1" ref-type="bibr" hwp:id="xref-ref-1-2" hwp:rel-id="ref-1">1</xref>]. Next, haplotype information for the 5,008 haplotypes stored in the VCF was imported and stored in a gPBWT-enabled xg index for the graph, using the batch construction algorithm mentioned above. In cases where the VCF specified self-inconsistent haplotypes (for example, a haplotype with a G to C SNP and a G to GAT insertion at the same position), they were broken apart at the inconsistent positions. The xg indexing and gPBWT construction process took 25 hours and 45 minutes using a single indexing thread on an Intel Xeon X7560 running at 2.27 GHz, and consumed 344 GB of memory. The high memory usage was a result of the decision to retain the entire data set in memory in an uncompressed format during construction. However, the resulting xg index was 662 MB on disk, of which 573 MB was used by the gPBWT. Information on the 5,008 haplotypes across the 1,103,547 variants was thus stored in about 1.7 bits per phased diploid genotype in the succinct self-indexed representation, or 0.018 bits per haplotype base. Extrapolating linearly from the 51 megabases of chromosome 22 to the entire 3.1 gigabase human reference genome, a similar index of the entire 1000 Genomes dataset would take 40 GB, with 35 GB devoted to the gPBWT. This is well within the storage and memory capacities of modern computer systems.</p><sec id="s7a" hwp:id="sec-8"><title hwp:id="title-12">Random Walks</title><p hwp:id="p-96">To evaluate query performance, 1 million random walks of 100 bp each were simulated from the graph. To remove walks covering ambiguous regions, walks that contained two or more N bases in a row were eliminated, leaving 686,897 random walks. The number of haplotypes in the gPBWT index consistent with each walk was then determined, taking 81.30 seconds in total using a single query thread on the above-mentioned Xeon system. The entire operation took a maximum of 685 MB of memory, indicating that the on-disk index did not require significant expansion during loading to be usable. Overall, the gPBWT index required 118 microseconds per count operation on the 100 bp random walks. It was found that 317,681 walks, or 46%, were not consistent with any haplotype in the graph. The distribution of of the number of haplotypes consistent with each random walk is visible in <xref ref-type="fig" rid="fig3" hwp:id="xref-fig-3-1" hwp:rel-id="F3">Figure 3</xref>.</p><fig id="fig3" position="float" fig-type="figure" orientation="portrait" hwp:id="F3" hwp:rev-id="xref-fig-3-1 xref-fig-3-2"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;051409v1/FIG3</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F3</object-id><object-id pub-id-type="publisher-id">fig3</object-id><label>Fig. 3.</label><caption hwp:id="caption-4"><p hwp:id="p-97">Distribution (top) and cumulative distribution (bottom) of the number of 1000 Genomes Phase 3 haplotypes consistent with short paths in the chromosome 22 graph. Primary mappings of 101 bp reads with scores of 90 out of 101 or above (<italic toggle="yes">n</italic> = 1, 509, 672) are the solid blue line. Secondary mappings meeting the same score criteria (<italic toggle="yes">n</italic> = 57, 115) are the dashed green line. Simulated 100 bp random walks in the graph without consecutive N characters (<italic toggle="yes">n</italic> = 686, 897) are the dotted red line. Consistent haplotypes were counted using the gPBWT support added to <monospace>vg</monospace> [<xref rid="c3" ref-type="bibr" hwp:id="xref-ref-3-2" hwp:rel-id="ref-3">3</xref>].</p></caption><graphic xlink:href="051409_fig3" position="float" orientation="portrait" hwp:id="graphic-4"/></fig></sec><sec id="s7b" hwp:id="sec-9"><title hwp:id="title-13">Read Mapping</title><p hwp:id="p-98">To further evaluate the performance of the query implementation, 1000 Genomes Low Coverage Phase 3 reads for NA12878 that were mapped in the official alignment to chromosome 22 were downloaded and re-mapped to the chromosome 22 graph, using the xg/GCSA2-based mapper in vg, allowing for up to a single secondary mapping per read. The reads which mapped with scores of at least 90 points out of a maximum of 101 points (for a perfectly-mapped 101 bp read) were selected (so filtering out alignnments highly like to be erroneous), and broken down into primary and secondary mappings. The number of haplotypes in the gPBWT index consistent with each read’s path through the graph was calculated (<xref ref-type="fig" rid="fig3" hwp:id="xref-fig-3-2" hwp:rel-id="F3">Figure 3</xref>). For 1,509,672 primary mappings, the count operation took 226.36 seconds in total, or 150 microseconds per mapping, again using 685 MB of memory. It was found that 13,918 of these primary mappings, or 0.9%, and 1,280 of 57,115 secondary mappings, or 2.2%, were not consistent with any haplotype path in the graph. These read mappings, despit having reasonable edit based scores, may represent rare recombinations, but the set is also likely to be enriched for spurious mappings.</p></sec></sec><sec id="s8" hwp:id="sec-10"><label>9</label><title hwp:id="title-14">Discussion</title><p hwp:id="p-99">We have introduced the gPBWT, a graph based generalization of the PBWT. We have demonstrated that a gPBWT can be built for a substantial genome graph (all of human chromosome 22 and the associated chromosome 22 variants in 1000 Genomes), and extrapolated that a whole-genome gPBWT could be constructed for all 5,008 haplotypes of the 1000 Genomes data and stored in the main memory of a contemporary computer. Looking forward, this combination of genome graph and gPBWT could potentially enable efficient mapping not just to one reference genome or collapsed genome graph, but simultaneously to a large set of genomes related by a genome graph.</p></sec></body><back><ack hwp:id="ack-1"><label>10</label><title hwp:id="title-15">Acknowledgements</title><p hwp:id="p-100">We would like to thank Richard Durbin for inspiration and David Haussler for his extremely helpful comments on the manuscript.</p></ack><ref-list hwp:id="ref-list-1"><title hwp:id="title-16">References</title><ref id="c1" hwp:id="ref-1" hwp:rev-id="xref-ref-1-1 xref-ref-1-2"><label>1.</label><citation publication-type="journal" citation-type="journal" ref:id="051409v1.1" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-1"><collab hwp:id="collab-1">1000 Genomes Project Consortium</collab>, <etal>et al.</etal>: <article-title hwp:id="article-title-2">A global reference for human genetic variation</article-title>. <source hwp:id="source-1">Nature</source> <volume>526</volume>(<issue>7571</issue>), <fpage>68</fpage>–<lpage>74</lpage> (<year>2015</year>)</citation></ref><ref id="c2" hwp:id="ref-2" hwp:rev-id="xref-ref-2-1 xref-ref-2-2"><label>2.</label><citation publication-type="journal" citation-type="journal" ref:id="051409v1.2" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-2"><string-name name-style="western" hwp:sortable="Durbin R."><surname>Durbin</surname>, <given-names>R.</given-names></string-name>: <article-title hwp:id="article-title-3">Efficient haplotype matching and storage using the positional Burrows– Wheeler transform (PBWT)</article-title>. <source hwp:id="source-2">Bioinformatics</source> <volume>30</volume>(<issue>9</issue>), <fpage>1266</fpage>–<lpage>1272</lpage> (<year>2014</year>)</citation></ref><ref id="c3" hwp:id="ref-3" hwp:rev-id="xref-ref-3-1 xref-ref-3-2"><label>3.</label><citation publication-type="other" citation-type="journal" ref:id="051409v1.3" ref:linkable="no" ref:use-reference-as-is="yes" hwp:id="citation-3"><string-name name-style="western" hwp:sortable="Garrison E."><surname>Garrison</surname>, <given-names>E.</given-names></string-name>: <article-title hwp:id="article-title-4">vg: the variation graph toolkit</article-title> (<year>2016</year>), <ext-link l:rel="related" l:ref-type="uri" l:ref="https://github.com/vgteam/vg/blob/80e823f5d241796f10b7af6284e0d3d3d464c18f/doc/paper/main.tex" ext-link-type="uri" xlink:href="https://github.com/vgteam/vg/blob/80e823f5d241796f10b7af6284e0d3d3d464c18f/doc/paper/main.tex" hwp:id="ext-link-4">https://github.com/vgteam/vg/blob/80e823f5d241796f10b7af6284e0d3d3d464c18f/doc/paper/main.tex</ext-link></citation></ref><ref id="c4" hwp:id="ref-4" hwp:rev-id="xref-ref-4-1"><label>4.</label><citation publication-type="journal" citation-type="journal" ref:id="051409v1.4" ref:linkable="no" ref:use-reference-as-is="yes" hwp:id="citation-4"><string-name name-style="western" hwp:sortable="Lunter G."><surname>Lunter</surname>, <given-names>G.</given-names></string-name>: <article-title hwp:id="article-title-5">Fast haplotype matching in very large cohorts using the Li and Stephens model</article-title>. <source hwp:id="source-3">bioRxiv</source> (<year>2016</year>), <ext-link l:rel="related" l:ref-type="uri" l:ref="http://biorxiv.org/content/early/2016/04/12/048280" ext-link-type="uri" xlink:href="http://biorxiv.org/content/early/2016/04/12/048280" hwp:id="ext-link-5">http://biorxiv.org/content/early/2016/04/12/048280</ext-link></citation></ref><ref id="c5" hwp:id="ref-5" hwp:rev-id="xref-ref-5-1"><label>5.</label><citation publication-type="journal" citation-type="journal" ref:id="051409v1.5" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-5"><string-name name-style="western" hwp:sortable="Medvedev P."><surname>Medvedev</surname>, <given-names>P.</given-names></string-name>, <string-name name-style="western" hwp:sortable="Brudno M."><surname>Brudno</surname>, <given-names>M.</given-names></string-name>: <article-title hwp:id="article-title-6">Maximum likelihood genome assembly</article-title>. <source hwp:id="source-4">Journal of Computational Biology</source> <volume>16</volume>(<issue>8</issue>), <fpage>1101</fpage>–<lpage>1116</lpage> (<year>2009</year>)</citation></ref><ref id="c6" hwp:id="ref-6" hwp:rev-id="xref-ref-6-1"><label>6.</label><citation publication-type="journal" citation-type="journal" ref:id="051409v1.6" ref:linkable="no" ref:use-reference-as-is="yes" hwp:id="citation-6"><string-name name-style="western" hwp:sortable="Paten B."><surname>Paten</surname>, <given-names>B.</given-names></string-name>, <string-name name-style="western" hwp:sortable="Novak A."><surname>Novak</surname>, <given-names>A.</given-names></string-name>, <string-name name-style="western" hwp:sortable="Haussler D."><surname>Haussler</surname>, <given-names>D.</given-names></string-name>: <article-title hwp:id="article-title-7">Mapping to a reference genome structure</article-title>. <source hwp:id="source-5">ArXiv e-prints</source> (<month>Apr</month> <year>2014</year>), <ext-link l:rel="related" l:ref-type="uri" l:ref="http://arxiv.org/abs/1404.5010" ext-link-type="uri" xlink:href="http://arxiv.org/abs/1404.5010" hwp:id="ext-link-6">http://arxiv.org/abs/1404.5010</ext-link></citation></ref></ref-list></back></article>
