<article article-type="article" specific-use="production" xml:lang="en" xmlns:hw="org.highwire.hpp" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ali="http://www.niso.org/schemas/ali/1.0/" xmlns:ref="http://schema.highwire.org/Reference" xmlns:hwp="http://schema.highwire.org/Journal" xmlns:l="http://schema.highwire.org/Linking" xmlns:r="http://schema.highwire.org/Revision" xmlns:x="http://www.w3.org/1999/xhtml" xmlns:app="http://www.w3.org/2007/app" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:nlm="http://schema.highwire.org/NLM/Journal" xmlns:a="http://www.w3.org/2005/Atom" xmlns:c="http://schema.highwire.org/Compound" xmlns:hpp="http://schema.highwire.org/Publishing"><front><journal-meta><journal-id journal-id-type="hwp">biorxiv</journal-id><journal-id journal-id-type="publisher-id">BIORXIV</journal-id><journal-title>bioRxiv</journal-title><abbrev-journal-title abbrev-type="publisher">bioRxiv</abbrev-journal-title><publisher><publisher-name>Cold Spring Harbor Laboratory</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="doi">10.1101/292425</article-id><article-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;292425v3</article-id><article-id pub-id-type="other" hwp:sub-type="pisa-master">biorxiv;292425</article-id><article-id pub-id-type="other" hwp:sub-type="slug">292425</article-id><article-id pub-id-type="other" hwp:sub-type="tag">292425</article-id><article-version>1.3</article-version><article-categories><subj-group subj-group-type="author-type"><subject>Regular Article</subject></subj-group><subj-group subj-group-type="heading"><subject>New Results</subject></subj-group><subj-group subj-group-type="hwp-journal-coll" hwp:journal-coll-id="Bioinformatics" hwp:journal="biorxiv"><subject>Bioinformatics</subject></subj-group></article-categories><title-group><article-title hwp:id="article-title-1">Mass spectra alignment using virtual lock-masses</article-title></title-group><author-notes hwp:id="author-notes-1"><fn fn-type="present-address" id="n1" hwp:id="fn-1"><label>¤</label><p hwp:id="p-1">Current Address: 2325 rue de l’Université, Big Data Research Center, Université Laval, Québec, Qc, Canada</p></fn><fn id="n2" hwp:id="fn-2" hwp:rev-id="xref-fn-2-1"><label>*</label><p hwp:id="p-2"><email hwp:id="email-1">francis.brochu.2@ulaval.ca</email></p></fn></author-notes><contrib-group hwp:id="contrib-group-1"><contrib contrib-type="author" hwp:id="contrib-1"><contrib-id contrib-id-type="orcid" authenticated="false">http://orcid.org/0000-0002-5804-6023</contrib-id><name name-style="western" hwp:sortable="Brochu Francis"><surname>Brochu</surname><given-names>Francis</given-names></name><xref ref-type="aff" rid="a1" hwp:id="xref-aff-1-1" hwp:rel-id="aff-1">1</xref><xref ref-type="aff" rid="a2" hwp:id="xref-aff-2-1" hwp:rel-id="aff-2">2</xref><xref ref-type="fn" rid="n2" hwp:id="xref-fn-2-1" hwp:rel-id="fn-2">*</xref><object-id pub-id-type="other" hwp:sub-type="orcid" xlink:href="http://orcid.org/0000-0002-5804-6023"/></contrib><contrib contrib-type="author" hwp:id="contrib-2"><name name-style="western" hwp:sortable="Plante Pier-Luc"><surname>Plante</surname><given-names>Pier-Luc</given-names></name><xref ref-type="aff" rid="a1" hwp:id="xref-aff-1-2" hwp:rel-id="aff-1">1</xref><xref ref-type="aff" rid="a3" hwp:id="xref-aff-3-1" hwp:rel-id="aff-3">3</xref></contrib><contrib contrib-type="author" hwp:id="contrib-3"><contrib-id contrib-id-type="orcid" authenticated="false">http://orcid.org/0000-0001-7718-0319</contrib-id><name name-style="western" hwp:sortable="Drouin Alexandre"><surname>Drouin</surname><given-names>Alexandre</given-names></name><xref ref-type="aff" rid="a1" hwp:id="xref-aff-1-3" hwp:rel-id="aff-1">1</xref><xref ref-type="aff" rid="a2" hwp:id="xref-aff-2-2" hwp:rel-id="aff-2">2</xref><object-id pub-id-type="other" hwp:sub-type="orcid" xlink:href="http://orcid.org/0000-0001-7718-0319"/></contrib><contrib contrib-type="author" hwp:id="contrib-4"><name name-style="western" hwp:sortable="Laviolette François"><surname>Laviolette</surname><given-names>François</given-names></name><xref ref-type="aff" rid="a1" hwp:id="xref-aff-1-4" hwp:rel-id="aff-1">1</xref><xref ref-type="aff" rid="a2" hwp:id="xref-aff-2-3" hwp:rel-id="aff-2">2</xref></contrib><contrib contrib-type="author" hwp:id="contrib-5"><name name-style="western" hwp:sortable="Marchand Mario"><surname>Marchand</surname><given-names>Mario</given-names></name><xref ref-type="aff" rid="a1" hwp:id="xref-aff-1-5" hwp:rel-id="aff-1">1</xref><xref ref-type="aff" rid="a2" hwp:id="xref-aff-2-4" hwp:rel-id="aff-2">2</xref></contrib><contrib contrib-type="author" hwp:id="contrib-6"><name name-style="western" hwp:sortable="Corbeil Jacques"><surname>Corbeil</surname><given-names>Jacques</given-names></name><xref ref-type="aff" rid="a1" hwp:id="xref-aff-1-6" hwp:rel-id="aff-1">1</xref><xref ref-type="aff" rid="a3" hwp:id="xref-aff-3-2" hwp:rel-id="aff-3">3</xref></contrib><aff id="a1" hwp:id="aff-1" hwp:rev-id="xref-aff-1-1 xref-aff-1-2 xref-aff-1-3 xref-aff-1-4 xref-aff-1-5 xref-aff-1-6"><label>1</label><institution hwp:id="institution-1">Big Data Research Center, Laval University</institution>, Québec, Qc, <country>Canada</country></aff><aff id="a2" hwp:id="aff-2" hwp:rev-id="xref-aff-2-1 xref-aff-2-2 xref-aff-2-3 xref-aff-2-4"><label>2</label><institution hwp:id="institution-2">Département d’Informatique et Génie Logiciel, Université Laval</institution>, Québec, Qc, <country>Canada</country></aff><aff id="a3" hwp:id="aff-3" hwp:rev-id="xref-aff-3-1 xref-aff-3-2"><label>3</label><institution hwp:id="institution-3">Centre de Recherche du CHU de Québec, Université Laval</institution>, Québec, Qc, <country>Canada</country></aff></contrib-group><pub-date pub-type="epub-original" hwp:start="2018"><year>2018</year></pub-date><pub-date pub-type="hwp-created" hwp:start="2018-03-30T20:18:15-07:00">
    <day>30</day><month>3</month><year>2018</year>
  </pub-date><pub-date pub-type="hwp-received" hwp:start="2018-04-18T13:09:08-07:00">
    <day>18</day><month>4</month><year>2018</year>
  </pub-date><pub-date pub-type="epub" hwp:start="2018-03-30T20:24:03-07:00">
    <day>30</day><month>3</month><year>2018</year>
  </pub-date><pub-date pub-type="epub-version" hwp:start="2018-04-18T13:15:02-07:00">
    <day>18</day><month>4</month><year>2018</year>
  </pub-date><elocation-id>292425</elocation-id><history hwp:id="history-1">
<date date-type="received" hwp:start="2018-03-30"><day>30</day><month>3</month><year>2018</year></date>
<date date-type="rev-recd" hwp:start="2018-04-18"><day>18</day><month>4</month><year>2018</year></date>
<date date-type="accepted" hwp:start="2018-04-18"><day>18</day><month>4</month><year>2018</year></date>
</history><permissions><copyright-statement hwp:id="copyright-statement-1">© 2018, Posted by Cold Spring Harbor Laboratory</copyright-statement><copyright-year>2018</copyright-year><license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by/4.0/" hwp:id="license-1"><p hwp:id="p-3">This pre-print is available under a Creative Commons License (Attribution 4.0 International), CC BY 4.0, as described at <ext-link l:rel="related" l:ref-type="uri" l:ref="http://creativecommons.org/licenses/by/4.0/" ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/" hwp:id="ext-link-1">http://creativecommons.org/licenses/by/4.0/</ext-link></p></license></permissions><self-uri xlink:href="292425.pdf" content-type="pdf" xlink:role="full-text"/><self-uri l:ref="forthcoming:yes" c:role="http://schema.highwire.org/variant/abstract" xlink:role="abstract" content-type="xhtml+xml" hwp:variant="yes"/><self-uri l:ref="forthcoming:yes" c:role="http://schema.highwire.org/variant/full-text" xlink:href="file:/content/biorxiv/vol0/issue2019/pdf/292425v3.pdf" hwp:variant="yes" content-type="pdf" xlink:role="full-text"/><self-uri l:ref="forthcoming:yes" c:role="http://schema.highwire.org/variant/full-text" xlink:role="full-text" content-type="xhtml+xml" hwp:variant="yes"/><self-uri l:ref="forthcoming:yes" c:role="http://schema.highwire.org/variant/source" xlink:role="source" content-type="xml" xlink:show="none" hwp:variant="yes"/><self-uri l:ref="forthcoming:yes" c:role="http://schema.highwire.org/variant/original" xlink:role="original" content-type="xml" xlink:show="none" hwp:variant="yes" xlink:href="292425.xml"/><self-uri content-type="abstract" xlink:href="file:/content/biorxiv/vol0/issue2019/abstracts/292425v3/292425v3.htslp"/><self-uri content-type="fulltext" xlink:href="file:/content/biorxiv/vol0/issue2019/fulltext/292425v3/292425v3.htslp"/><abstract hwp:id="abstract-1"><title hwp:id="title-1">Abstract</title><p hwp:id="p-4">Mass spectrometry is a valued method to evaluate the metabolomics content of a biological sample. The recent advent of rapid ionization technologies such as Laser Diode Thermal Desorption (LDTD) and Direct Analysis in Real Time (DART) has rendered high-throughput mass spectrometry possible. It can now be used for large-scale comparative analysis of populations of samples. In practice, many factors resulting from the environment, the protocol, and even the instrument itself, can lead to minor discrepancies between spectra, rendering automated comparative analysis difficult. In this work, a sequence/pipeline of algorithms to correct variations between spectra is proposed. The algorithms correct multiple spectra by identifying peaks that are common to all and, from those, computes a spectrum-specific correction. We show that these algorithms increase comparability within large datasets of spectra, facilitating comparative analysis, such as machine learning.</p><sec hwp:id="sec-1"><title hwp:id="title-2">Author summary</title><p hwp:id="p-5">Mass spectrometry is a widespread technology used to measure the chemical content of samples. This measurement technique is often used with biological samples for diverse applications, such as protein sequencing, metabolomic profiling or quantitative measurements. However, with the increasing throughput of mass spectrometry technologies and methodologies, the resulting datasets are becoming larger. This reveals slight shifts in mass measured by the instruments, in the case of Time-of-Flight (ToF) mass spectrometers. These shifts render spectra harder to compare and analyze in large datasets. In this article, we propose algorithms that counter mass shifts and variations in datasets of ToF mass spectra. These algorithms use no external reference points, instead calculating spectrum-specific corrections by finding peaks present in all spectra of a dataset. Applying these algorithm yields a representation of the mass spectra that can then easily be used for statistical or machine learning analyses.</p></sec></abstract><counts><page-count count="32"/></counts><custom-meta-wrap>
    <custom-meta hwp:id="custom-meta-1">
      <meta-name>has-earlier-version</meta-name>
      <meta-value>yes</meta-value>
    </custom-meta>
  </custom-meta-wrap></article-meta></front><body><sec id="s1" hwp:id="sec-2"><title hwp:id="title-3">Introduction</title><p hwp:id="p-6">Mass spectrometry (MS) is a widely used technique for acquiring data on the metabolome or the proteome of individuals [<xref ref-type="bibr" rid="c1" hwp:id="xref-ref-1-1" hwp:rel-id="ref-1">1</xref>] [<xref ref-type="bibr" rid="c2" hwp:id="xref-ref-2-1" hwp:rel-id="ref-2">2</xref>]. Proteomics applications can consist, among others, of typing of microbial organisms [<xref ref-type="bibr" rid="c3" hwp:id="xref-ref-3-1" hwp:rel-id="ref-3">3</xref>], imaging MS [<xref ref-type="bibr" rid="c4" hwp:id="xref-ref-4-1" hwp:rel-id="ref-4">4</xref>], quantitative comparisons [<xref ref-type="bibr" rid="c5" hwp:id="xref-ref-5-1" hwp:rel-id="ref-5">5</xref>], and peptide sequencing [<xref ref-type="bibr" rid="c6" hwp:id="xref-ref-6-1" hwp:rel-id="ref-6">6</xref>] [<xref ref-type="bibr" rid="c7" hwp:id="xref-ref-7-1" hwp:rel-id="ref-7">7</xref>]. For metabolomics applications, the two main approaches fall into the categories of targeted and untargeted studies. In comparison with targeted studies, untargeted studies acquire data using a shotgun approach. Therefore, this type of study is a good option for novel biomarker discovery and hypothesis generation [<xref ref-type="bibr" rid="c8" hwp:id="xref-ref-8-1" hwp:rel-id="ref-8">8</xref>] [<xref ref-type="bibr" rid="c9" hwp:id="xref-ref-9-1" hwp:rel-id="ref-9">9</xref>].</p><p hwp:id="p-7">Through recent years, novel ionization technologies have emerged, facilitating the high-throughput acquisition of mass spectra [<xref ref-type="bibr" rid="c10" hwp:id="xref-ref-10-1" hwp:rel-id="ref-10">10</xref>]. Technologies such as Laser Diode Thermal Desorption (LDTD) or Direct Analysis in Real Time (DART), allow for the rapid acquisition of large datasets. These methods often preclude or bypass the time separation process used in Liquid Chromatography (LC) or Gas Chromatography (GC) [<xref ref-type="bibr" rid="c11" hwp:id="xref-ref-11-1" hwp:rel-id="ref-11">11</xref>]. Thus, without any time separation, a single mass spectrum will often be represented as lists of peaks, composed of the mass-to-charge ratio of the ion (<italic toggle="yes">m/z</italic> value) and its intensity.</p><p hwp:id="p-8">With the rise of larger datasets, multiple problems of comparability between spectra have emerged. Datasets are acquired in multiple batches over numerous days, on different instruments in multiple locations, with recalibrations of the instruments occurring between batches [<xref ref-type="bibr" rid="c12" hwp:id="xref-ref-12-1" hwp:rel-id="ref-12">12</xref>]. These factors induce variations in the spectra that hinders their comparison.</p><p hwp:id="p-9">In the past, three algorithms have been proposed to address this problem, which mainly affecting Time-of-Flight mass spectrometers. These include the work of Tibshirani <italic toggle="yes">et al</italic>. (2004) [<xref ref-type="bibr" rid="c13" hwp:id="xref-ref-13-1" hwp:rel-id="ref-13">13</xref>], Jeffries (2005) [<xref ref-type="bibr" rid="c14" hwp:id="xref-ref-14-1" hwp:rel-id="ref-14">14</xref>], and Tracy <italic toggle="yes">et al</italic>. (2008) [<xref ref-type="bibr" rid="c15" hwp:id="xref-ref-15-1" hwp:rel-id="ref-15">15</xref>]. Tibshirani’s algorithm relies on a clustering algorithm to align peaks that are present in multiple spectra and picks them for further statistical analyses. However, unlike the algorithms proposed in this article, it does not address the problem of inter-batch variations. Jeffries’ algorithm is more appropriate for this problem. This method uses cubic splines to recalibrate spectra, based on the shifts between observed peaks and known reference masses. A similar algorithm has been proposed by Barry <italic toggle="yes">et al</italic>. (2013) for Fourier-Transform Mass Spectrometry [<xref ref-type="bibr" rid="c16" hwp:id="xref-ref-16-1" hwp:rel-id="ref-16">16</xref>]. This approach uses ambient ions in order to correct the spectra using known reference masses. One limitation of these algorithms is that they require known reference masses. The algorithm presented in this work alleviates this constraint, by automatically detecting such reference points. Another algorithm of interest for MALDI-ToF spectra has been proposed by Tracy <italic toggle="yes">et al</italic>. [<xref ref-type="bibr" rid="c15" hwp:id="xref-ref-15-2" hwp:rel-id="ref-15">15</xref>]. In this case, commonly occurring peaks within the dataset are used to correct the spectra and determine the binning distance used. However, this method computes a single constant correction factor for the entire spectrum, while the method proposed in this work computes correction factors that vary across the <italic toggle="yes">m/z</italic> axis of the spectra in order to obtain a more accurate correction.</p><p hwp:id="p-10">The algorithms proposed in this article aim to render spectra more comparable prior to peak selection and statistical analyses. We draw inspiration from the interal lock mass approach and exploit the fact that spectra of samples of the same nature (i.e., blood plasma samples, urine samples, etc.) are very likely to share common peaks (i.e., compounds that are present in each sample). For example, human blood plasma contains compounds, such as glucose and amino acids [<xref ref-type="bibr" rid="c17" hwp:id="xref-ref-17-1" hwp:rel-id="ref-17">17</xref>]. Similarly, urine contains urea, creatinine, citric acid, and many more [<xref ref-type="bibr" rid="c18" hwp:id="xref-ref-18-1" hwp:rel-id="ref-18">18</xref>]. Hence, we propose to correct the spectra based on the position of peaks that are detected to be consistently present in samples of the same nature. We call these peaks “virtual lock masses” (VLM) and propose an algorithm to detect them automatically. This idea is similar to the one proposed by Barry <italic toggle="yes">et al</italic>. [<xref ref-type="bibr" rid="c16" hwp:id="xref-ref-16-2" hwp:rel-id="ref-16">16</xref>], but the peaks are not limited to ambient ions. In this work, we show that our algorithm allows the detections of tens to hundreds of peaks that can be used as reference points to re-align the spectra and reduce inter-batch variations. Our approach is fully compatible with the classical lock mass approach, which can be used complementarily. Moreover, we show that a slight modification to the VLM detection algorithm can produce an alignment algorithm that can be used to further correct the spectra.</p><p hwp:id="p-11">Hence, our key contributions are: an algorithm that automatically detects reference points in mass spectra, an algorithm that corrects the spectra based on these points, and an alignment algorithm to align large sets of spectra. In the next section, we present results supporting the accuracy of our reference point detection algorithm. Moreover, we show that the proposed algorithms are a key component of machine learning analysis performed on ToF mass spectra. Subsequently, we discuss these results and their implications and finally, present the details of the algorithms and their implementation.</p></sec><sec id="s2" hwp:id="sec-3"><title hwp:id="title-4">Results</title><sec id="s2a" hwp:id="sec-4"><title hwp:id="title-5">A consistent set of virtual lock masses can be detected in different batches</title><p hwp:id="p-12">This experiment was conducted on the <italic toggle="yes">Days</italic> dataset (see <xref ref-type="sec" rid="s4" hwp:id="xref-sec-15-1" hwp:rel-id="sec-15"><italic toggle="yes">Methods</italic></xref>), which consist of 192 samples of pooled blood plasma. Half of the samples were acquired on a given day and the others were acquired on a separate day. Since the samples are of the same nature, we expect a high similarity apart from inter-batch variations. The goal of the experiment was to determine if a consistent set of virtual lock masses could be detected among similar datasets and within parts of the same dataset.</p><p hwp:id="p-13">The VLM detection algorithm was independently applied to 1) every spectrum in the dataset, to 2) only the spectra acquired on the first day, and to 3) only the spectra acquired on the second day. The algorithm was applied with the same window size of 40 ppm in all cases. This window size was determined by the procedure described in the Methods section, being the <italic toggle="yes">w</italic> that yielded the largest number of isolated VLMs on the entire dataset.</p><p hwp:id="p-14">The detected VLMs were then compared in the following manner. We define that if we have two sets of spectra <italic toggle="yes">A</italic> and <italic toggle="yes">B</italic>, their detected VLMs will be &#x01d4b1;<italic toggle="yes"><sub>A</sub></italic> and &#x01d4b1;<italic toggle="yes"><sub>B</sub></italic>. Each element of &#x01d4b1;<italic toggle="yes"><sub>A</sub></italic> is a VLM <italic toggle="yes">υ<sub>A</sub></italic> that is composed of a single peak per spectrum for the spectra in <italic toggle="yes">A</italic>. If <italic toggle="yes">B</italic> ⊂ <italic toggle="yes">A</italic>, then a VLM <italic toggle="yes">υ<sub>A</sub></italic> ∈ &#x01d4b1;<italic toggle="yes"><sub>A</sub></italic> and a VLM <italic toggle="yes">υ<sub>B</sub></italic> ∈ &#x01d4b1;<italic toggle="yes"><sub>B</sub></italic> are homologous if the peaks forming <italic toggle="yes">υ<sub>B</sub></italic> are a subset of the peaks forming <italic toggle="yes">υ<sub>A</sub></italic>. Additionally, we can define comparisons between the VLMs of subsets of <italic toggle="yes">A</italic>. If we have sets of spectra <italic toggle="yes">A,B</italic> and <italic toggle="yes">C</italic>, where <italic toggle="yes">B</italic> ⊂ <italic toggle="yes">A</italic> and <italic toggle="yes">C</italic> ⊂ <italic toggle="yes">A</italic>, then we can define that VLMs <italic toggle="yes">υ<sub>B</sub></italic> and <italic toggle="yes">υ<sub>C</sub></italic> are homologous if <italic toggle="yes">υ<sub>B</sub></italic> if homologous to <italic toggle="yes">υ<sub>A</sub></italic> and <italic toggle="yes">υ<sub>C</sub></italic> is homologous to <italic toggle="yes">υ<sub>A</sub></italic>.</p><p hwp:id="p-15">We compared the peak groups forming the VLMs in all spectra with the spectra acquired on the first day, and found that the 113 VLMs detected on all spectra have homologues in the set of 148 VLMs detected on the first day. Conversely, we observed that the 113 VLMs also have homologues within the set of 118 VLMs detected in the spectra acquired on the second day.</p><p hwp:id="p-16">Hence, the algorithm finds common VLM points in all settings, corresponding to different days and multiple instrument recalibrations. This suggests that it correctly identifies landmark compounds that are present in a particular type of sample, which can be used as a common basis for correction. We therefore conclude that our detection algorithm behaves as expected.</p></sec><sec id="s2b" hwp:id="sec-5"><title hwp:id="title-6">Virtual lock mass correction improves machine learning analysis</title><p hwp:id="p-17">Machine learning experiments were conducted on four binary classification tasks. The first two tasks consist of the detection of a single compound spiked in blood plasma samples from the <italic toggle="yes">Clomiphene-Acetaminophen</italic> dataset (see <xref ref-type="sec" rid="s4" hwp:id="xref-sec-15-2" hwp:rel-id="sec-15"><italic toggle="yes">Methods</italic></xref>). The third task is the detection of malaria infection in red blood cell culture samples from the <italic toggle="yes">Malaria</italic> dataset (see <xref ref-type="sec" rid="s4" hwp:id="xref-sec-15-3" hwp:rel-id="sec-15"><italic toggle="yes">Methods</italic></xref>). The fourth and final task consists of distinguishing plasma samples of patients with and without breast cancer in the <italic toggle="yes">Cancer</italic> dataset (see <xref ref-type="sec" rid="s4" hwp:id="xref-sec-15-4" hwp:rel-id="sec-15"><italic toggle="yes">Methods</italic></xref>).</p><sec id="s2b1" hwp:id="sec-6"><title hwp:id="title-7">Machine learning algorithms</title><p hwp:id="p-18">Multiple machine learning algorithms were applied to the spectra. The first algorithm used is the AdaBoost ensemble method [<xref ref-type="bibr" rid="c19" hwp:id="xref-ref-19-1" hwp:rel-id="ref-19">19</xref>]. This method learns a weighted majority vote on a set of simple pre-defined classifiers. A linear Support Vector Machine (SVM) [<xref ref-type="bibr" rid="c22" hwp:id="xref-ref-22-1" hwp:rel-id="ref-22">22</xref>] was used with a L1-norm regularizer. The latter is to ensure that the predictions are based on a small subset of the peaks. We also used decision tree [<xref ref-type="bibr" rid="c20" hwp:id="xref-ref-20-1" hwp:rel-id="ref-20">20</xref>] and Set Covering Machine classifiers [<xref ref-type="bibr" rid="c21" hwp:id="xref-ref-21-1" hwp:rel-id="ref-21">21</xref>]. These algorithms have the advantage of producing interpretable classifiers that consist of a very small combination of simple rules on peak intensities. We used the Scikit-learn implementations for AdaBoost, CART, and the L1-regularized SVM [<xref ref-type="bibr" rid="c23" hwp:id="xref-ref-23-1" hwp:rel-id="ref-23">23</xref>]; whereas we used our own implementation of the SCM. This implementation is available at <ext-link l:rel="related" l:ref-type="uri" l:ref="https://github.com/aldro61/pyscm" ext-link-type="uri" xlink:href="https://github.com/aldro61/pyscm" hwp:id="ext-link-2">https://github.com/aldro61/pyscm</ext-link>.</p></sec><sec id="s2b2" hwp:id="sec-7"><title hwp:id="title-8">Experimental protocol</title><p hwp:id="p-19">For each experiment, the spectra were randomly partitioned into a training set and a test set. For the compound detection tasks (clomiphene and acetaminophen), the test set consisted of 50 selected samples. For the cancer detection task, the same number of samples were included in the test set. Finally, for the malaria detection task, 100 samples were selected for the test set. The hyper-parameters of each learning algorithm were chosen by 5-fold cross-validation on the training set (refer to Elements of Statistical Learning [<xref ref-type="bibr" rid="c24" hwp:id="xref-ref-24-1" hwp:rel-id="ref-24">24</xref>]). Each experiment was repeated 10 times independently on different partitions of the data.</p><p hwp:id="p-20">Two different experimental protocols were tested which are illustrated in <xref ref-type="fig" rid="fig1" hwp:id="xref-fig-1-1" hwp:rel-id="F1">Fig (1)</xref>. First, the correction and alignment algorithms were applied in the transductive learning setting [<xref ref-type="bibr" rid="c25" hwp:id="xref-ref-25-1" hwp:rel-id="ref-25">25</xref>]. In this setting, the whole dataset is exposed to the pipeline of proposed algorithms (VLM detection + VLM correction + alignment point detection). The training and testing sets are then partitioned randomly. The second experimental protocol was conducted as the inductive learning setting, in which the pipeline of proposed algorithms were only applied to the training set. Hence the set of alignment points is found from the training set only. For the inductive learning protocol, the percentile parameter of the alignment algorithm is considered an hyper-parameter and is thus cross-validated on the training set. For the transductive learning protocol, the percentile parameter is set at 95%. The features shown to the machine learning algorithms are the alignment points and their associated intensity values.</p><fig id="fig1" position="float" fig-type="figure" orientation="portrait" hwp:id="F1" hwp:rev-id="xref-fig-1-1"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;292425v3/FIG1</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F1</object-id><object-id pub-id-type="publisher-id">fig1</object-id><label>Fig 1.</label><caption hwp:id="caption-1"><title hwp:id="title-9">Transductive and inductive workflows.</title><p hwp:id="p-21">(A) The transductive workflow, in which all spectra are corrected at once, prior to partitioning the data into a training and testing set. (B) The inductive workflow, where the data are first partitioned and only the spectra in the training set are used to learn a transformation that is applied to all spectra. The dotted blue arrows show where the algorithms were applied on unseen data, while the whole black arrows show the workflow of the training data.</p></caption><graphic xlink:href="292425_fig1" position="float" orientation="portrait" hwp:id="graphic-1"/></fig><p hwp:id="p-22">For each task, we compared the performance of classifiers according to their preprocessing. We thus compared (a) simply binning the spectra, (b) using the VLM detection and correction algorithms and then binning the mass spectra and (c) using the VLM detection and correction algorithms before using the alignment algorithm. Binning is a commonly used technique in mass spectrometry analysis consisting in grouping peaks and intensities found in a larger bin on the <italic toggle="yes">m/z</italic> axis into a single point or peak [<xref ref-type="bibr" rid="c26" hwp:id="xref-ref-26-1" hwp:rel-id="ref-26">26</xref>].</p></sec><sec id="s2b3" hwp:id="sec-8"><title hwp:id="title-10">Results for transductive learning</title><p hwp:id="p-23"><xref ref-type="table" rid="tbl1" hwp:id="xref-table-wrap-1-1" hwp:rel-id="T1">Table 1</xref> shows the results of the machine learning experiments in the transductive setting for different tasks. Let us first consider the case of the clomiphene detection task. In all conditions, we observe excellent results, with accuracies over 90% in almost every case. However, we know that the solution to this problem is the appearance of a single additional molecule and its fragments in the spectra, since a solution of water and clomiphene is added in the plasma samples. Thus, it is expected that a single peak (feature) should be sufficient to classify the spectra. Considering this information, we see that a single peak is used for classification only when applying the VLM correction and alignment algorithms when using the Decision Tree and SCM. We also see a decrease in the number of features used for the AdaBoost classifier when using the VLM correction and alignment algorithms. In the case of the L1-regularized SVM, the sparsest solution (with an average of 2.6 features used) was obtained when the VLM correction algorithm was applied in addition to binning.</p><table-wrap id="tbl1" orientation="portrait" position="float" hwp:id="T1" hwp:rev-id="xref-table-wrap-1-1"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;292425v3/TBL1</object-id><object-id pub-id-type="other" hwp:sub-type="slug">T1</object-id><object-id pub-id-type="publisher-id">tbl1</object-id><label>Table 1.</label><caption hwp:id="caption-2"><title hwp:id="title-11">Machine learning results in the transductive setting.</title><p hwp:id="p-24">The percentage in each column is the average accuracy of classifiers on 10 repeats of the experiment. The number shown in parentheses is the average number of features used by the classifiers.</p></caption><graphic xlink:href="292425_tbl1" position="float" orientation="portrait" hwp:id="graphic-2"/></table-wrap><p hwp:id="p-25">Consider now the results for acetaminophen detection. In this case, an acetaminophen pill was added to the blood plasma samples. Thus, it is expected that multiple molecules and their fragments appear in the spectra in this case, at extremely high concentration not normally found in physiological blood plasma. It is then not surprising that most algorithms can identify acetaminophen with the use of a singe feature (peak). Note that in the case of the L1-regularized Support Vector Machine, the best results, both in terms of accuracy and sparsity, are obtained when the VLM correction and alignment algorithms were used.</p><p hwp:id="p-26">The next two tasks represent more realistic problems with unknown solutions. Let us then consider the malaria detection task. For each algorithm, applying the VLM correction algorithm yields an increase in prediction accuracy. For the AdaBoost classifier, we observe an increase of about 1% and the best sparsity in the case of the VLM correction applied before binning, with a slight increase in accuracy with the alignment algorithm. The Decision Tree classifier increases its accuracy by approximately 5% with the VLM correction algorithm, both with alignment and with binning. We see a similar increase in accuracy for the Set Covering Machine in the case of VLM correction with binning. Finally, the L1-regularized SVM obtains a 3% increase in accuracy with the VLM correction algorithm applied, and a better sparsity.</p><p hwp:id="p-27">Finally, let us consider the results for the cancer detection task. This classification problem is much harder, with few machine learning algorithms having a prediction accuracy over 70%. Still, both the AdaBoost and Decision Tree classifiers have similar results in all cases, with slight losses in accuracy but improved sparsity with the proposed algorithms applied. The Set Covering Machine sees its accuracy increased by 4% with both correction and alignment algorithms applied and with comparable sparsity. However, in the case of the L1-regularized SVM, the classifier accuracy increases of almost 20% with the proposed algorithms compared to binning only.</p></sec><sec id="s2b4" hwp:id="sec-9"><title hwp:id="title-12">Results for inductive learning</title><p hwp:id="p-28">In <xref ref-type="table" rid="tbl2" hwp:id="xref-table-wrap-2-1" hwp:rel-id="T2">Table 2</xref>, we compare the effect of using the proposed algorithms in the transductive setting versus the inductive setting. For the compound detection tasks, there is very little difference between the two approaches for both clomiphene detection and acetaminophen detection. The inductive setting yields slightly sparser classifiers, but the results are very similar. For the malaria detection task, the difference in sparsity is not significant for the Decision Tree and Set Covering Machine algorithms. The AdaBoost classifier is sparser for the inductive setting, while the L1 SVM has a significant advantage in the transductive setting. The results are also very similar in terms of accuracy for both settings, with very slightly better accuracies in the transductive setting. Finally, the transductive setting appears to be the best setting for cancer detection. The AdaBoost classifier is sparser in this case, with a slight decrease in accuracy. The Decision Tree and Set Covering Machine have better accuracies in the transductive setting, though the SCM is sparser in the inductive setting. The L1-regularized SVM is, on the other hand, much more accurate and slightly sparser in the transductive setting, with an increase in accuracy of about 6%.</p><table-wrap id="tbl2" orientation="portrait" position="float" hwp:id="T2" hwp:rev-id="xref-table-wrap-2-1"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;292425v3/TBL2</object-id><object-id pub-id-type="other" hwp:sub-type="slug">T2</object-id><object-id pub-id-type="publisher-id">tbl2</object-id><label>Table 2.</label><caption hwp:id="caption-3"><p hwp:id="p-29">Comparison of transductive and inductive learning of the VLM and Alignment algorithms</p></caption><graphic xlink:href="292425_tbl2" position="float" orientation="portrait" hwp:id="graphic-3"/></table-wrap><p hwp:id="p-30">Finally, and perhaps not surprisingly, we can see (for AdaBoost and L1-SVM) that cancer and malaria detection need far more features then clomiphene and acetaminophen detection.</p></sec></sec><sec id="s2c" hwp:id="sec-10"><title hwp:id="title-13">Stability of virtual lock masses in datasets</title><p hwp:id="p-31">This experiment was conducted in order to verify that virtual lock masses detected on a given dataset will be found in unseen spectra of the same type. The algorithm for VLM detection was also cross-validated on the <italic toggle="yes">Days</italic> Dataset and the <italic toggle="yes">Clomiphene-Acetaminophen</italic> Dataset. Each dataset was randomly split into <italic toggle="yes">k</italic> folds. The VLM detection algorithm was applied to the first <italic toggle="yes">k</italic> – 1 folds, the training folds. The detected VLMs on the training folds are then used for VLM correction of the spectra in last remaining fold, the testing fold. When the correction is applied, we note if every VLM is found in the spectra of the testing fold. The algorithm is scored according to the ratio of detected VLMs on the training folds that are also found in the testing fold. This process is repeated <italic toggle="yes">k</italic> times so that each fold serves as a test fold once. Multiples values of <italic toggle="yes">k</italic> were used in the experiment, such that <italic toggle="yes">k</italic> ∈ {3, 5, 8,10,15, 20}.</p><p hwp:id="p-32">In each case, we found that <italic toggle="yes">every</italic> VLM point detected on the training set was detected on the testing set. This thus results in a ratio of VLMs found in the testing set over the VLMs detected on the training set of 100% in all cases. This provides empirical evidence of the stability of VLM points across different sets of spectra.</p></sec><sec id="s2d" hwp:id="sec-11"><title hwp:id="title-14">Learning Curves</title><p hwp:id="p-33">A learning curve experiment was performed in order to evaluate the behavior of the VLM detection and correction algorithms on varying numbers of samples. In a first step, the VLM detection algorithm followed by the VLM correction algorithm was performed on the whole set of spectra. 25 spectra were randomly selected as a test set. These test spectra will be considered the “ground truth”, i.e., the best correction that the algorithm can achieve for these 25 spectra.</p><p hwp:id="p-34">The algorithm was subsequently applied once again to a number of spectra. The number of spectra the algorithm was exposed to was gradually increased, from 10 spectra to 160 spectra. At each point, the uncorrected test spectra are corrected and compared to the ground truth spectra. The difference in <italic toggle="yes">m/z</italic> value between the homologous peaks is calculated in ppm. Then, the difference is squared and summed for all test spectra. Finally, this sum is divided by the number of peaks in the test spectra and the square root is taken. The difference in correction is thus expressed as the Root Mean Squared Error (RMSE) in ppm units for each peak. This experiment was repeated 50 times, with randomly re-sampled test sets, in order to obtain statistically significant results.</p><p hwp:id="p-35"><xref ref-type="fig" rid="fig2" hwp:id="xref-fig-2-1" hwp:rel-id="F2">Fig 2</xref> shows the learning curves obtained on three different datasets. In each case, the trends is similar. When sub-sampling a low number of spectra as a training set for the VLM detection and correction algorithms, a higher number of lock masses is found. As the number of training spectra increases, the number of virtual lock masses found diminishes and starts to plateau near the number of lock masses found in the whole dataset. This is explained by the fact that when few spectra are in the training set, there is a higher number of candidates. As new spectra are added in the training set, there is a probability that one of the new spectra are missing at least one peak that was previously considered a virtual lock mass. These peaks could be missing because of strong noise, either on the <italic toggle="yes">m/z</italic> axis or in terms of intensity, rendering its intensity too small to be considered a VLM. A peak could also be missing simply because the compound or fragment generating that peak is not present in all samples.</p><fig id="fig2" position="float" fig-type="figure" orientation="portrait" hwp:id="F2" hwp:rev-id="xref-fig-2-1"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;292425v3/FIG2</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F2</object-id><object-id pub-id-type="publisher-id">fig2</object-id><label>Fig 2.</label><caption hwp:id="caption-4"><title hwp:id="title-15">Learning Curves of Virtual Lock Mass Detection and Correction.</title><p hwp:id="p-36">Subfigures (A), (B) and (C) show the learning curves for three different datasets (Days, Clomiphene-Acetaminophen, Malaria). Subfigure (D) shows the RMSE of VLM Correction for these datasets.</p></caption><graphic xlink:href="292425_fig2" position="float" orientation="portrait" hwp:id="graphic-4"/></fig><p hwp:id="p-37">The same trend is found in all three datasets for the Root Mean Squared Error (RMSE) in Subfigure (D). The error is initially high when few spectra are in the training set, but as more spectra are added in the training set it gradually decreases. In the case of the <italic toggle="yes">Days</italic> Dataset, the final average RMSE when using 160 spectra to train the algorithm is 0.56 ppms. For the other two datasets (<italic toggle="yes">Clomiphene-Acetaminophen</italic> and <italic toggle="yes">Malaria</italic>), the final RMSEs are approximately 1.10 ppms. In each case, the RMSE drops under 2.0 ppms when using 100 spectra or more to train the correction algorithm. In conjunction with the results of inductive learning shown above, these results suggest that the VLM detection and correction algorithms can generalize the virtual lock masses and correction it learns to unseen spectra of the same nature, such as those of a new test set.</p></sec></sec><sec id="s3" hwp:id="sec-12"><title hwp:id="title-16">Discussion</title><p hwp:id="p-38">The algorithms proposed in this article aim to render mass spectra more comparable for large datasets acquired in single or multiple batches. The VLM detection algorithm is stable and detects virtual lock masses reliably in datasets. It also detects peaks that are present in mass spectra of the same type but that are not part of the training set. In addition, applying the proposed pipeline of algorithms (VLM detection + VLM correction + alignment point detection) on sets of mass spectra before statistical and machine learning analyses generally yields classifiers with increased accuracy and sometimes with increased sparsity, leading to interpretable models that could serve for biomarker discovery. The proposed pipeline of algorithms has a very low running time complexity of <italic toggle="yes">O</italic>(<italic toggle="yes">n</italic> log <italic toggle="yes">m</italic>) for a collection of m spectra containing a total of <italic toggle="yes">n</italic> peaks which, as argued, cannot be surpassed by algorithms based on clustering (with the current state of knowledge).</p><p hwp:id="p-39">However, the algorithms, as presented, have a number of drawbacks. Since the virtual lock masses are assigned the average <italic toggle="yes">m/z</italic> value of the peaks associated to it, the correction algorithm does not correct the peaks to the exact <italic toggle="yes">m/z</italic> value of the ion. The alignment algorithm has also the same property. However, the virtual lock mass approach is compatible with any external lock masses added to the spectra. Thus, by applying both methods, any shift away from the exact (and known) <italic toggle="yes">m/z</italic> value of an external lock mass can be corrected. Some situations are also unsuitable for the proposed algorithms. In order for the VLM detection algorithm to function properly and detect virtual lock masses, the mass spectra forming the dataset must be of the same “nature” so that the algorithm can detect a sufficient number of peaks that are common to all spectra. Additionally, the correction algorithm works best in a situation where there are more peaks than spectra. In the cases where each spectrum contains very few peaks, there is a much lower probability that that algorithm can find peaks present in all spectra of the set.</p><sec id="s3a" hwp:id="sec-13"><sec id="s3a1" hwp:id="sec-14"><title hwp:id="title-17">Future works</title><p hwp:id="p-40">The algorithms, as presented here, can only be applied to mass spectra represented by a list of peaks of the form (<italic toggle="yes">μ, ι</italic>) where <italic toggle="yes">μ</italic> is the <italic toggle="yes">m/z</italic> value of the peak and <italic toggle="yes">ι</italic> its intensity. Hence, the algorithms are currently not applicable with mass spectra having additional dimensions for the peaks, such as ion mobility. It is also not applicable to chromatogram where multiple mass spectra are acquired over time for a single sample and where each spectra contains different peaks due to the chromatographic separation. It is thus relevant to investigate if the proposed approach, based on virtual lock masses, can be extended to incorporate these extra dimensions.</p></sec></sec></sec><sec id="s4" hwp:id="sec-15" hwp:rev-id="xref-sec-15-1 xref-sec-15-2 xref-sec-15-3 xref-sec-15-4"><title hwp:id="title-18">Materials and methods</title><p hwp:id="p-41">In this section, we present the mathematical basis of the proposed methodology. First, the problem of virtual lock-mass identification is addressed. A formal definition of VLM peaks is introduced, along with an highly efficient algorithm capable of identifying such peaks in a set of mass spectra. Second, a methodology for correcting mass spectra based on a set of identified virtual lock masses is described. Third, an algorithm for mass spectra alignment based on the previous algorithm is proposed. Finally, the datasets used and the experimental methodologies are presented.</p><sec id="s4a" hwp:id="sec-16"><title hwp:id="title-19">Definitions</title><p hwp:id="p-42">Let us first recall that a <italic toggle="yes">set</italic> is an un-ordered collection of elements whereas a <italic toggle="yes">sequence</italic> is an ordered collection of elements. Hence, in a sequence we have a first element, a second element, and so on. If A is a sequence or a set, |A| denotes the number of elements in <italic toggle="yes">A</italic>.</p><p hwp:id="p-43">Let <inline-formula hwp:id="inline-formula-1"><alternatives hwp:id="alternatives-1"><inline-graphic xlink:href="292425_inline1.gif" hwp:id="inline-graphic-1"/></alternatives></inline-formula> a set of mass spectra. Each spectrum <italic toggle="yes">S<sub>i</sub></italic> is a sequence of peaks, where each peak is a pair (<italic toggle="yes">μ, ι</italic>) with an <italic toggle="yes">m/z</italic> value <italic toggle="yes">μ</italic> and a peak intensity <italic toggle="yes">ι</italic>.</p><p hwp:id="p-44">Let a <italic toggle="yes">window</italic> of size 2<italic toggle="yes">w</italic> centered on the peak (<italic toggle="yes">μ, ι</italic>) be an interval that starts at <italic toggle="yes">μ</italic> ⋅ (1 − <italic toggle="yes">w</italic>) and ends at <italic toggle="yes">μ</italic> ⋅ (1 + <italic toggle="yes">w</italic>). Notice that the size of the window <italic toggle="yes">w</italic> is relative to <italic toggle="yes">μ</italic>. The reason for using window sizes in relative units is that the mass measurement uncertainty of ToF mass spectrometers increases linearly with the <italic toggle="yes">m/z</italic> value of a peak.</p><p hwp:id="p-45">Given a set &#x01d4ae; of mass spectra and a window size parameter <italic toggle="yes">w</italic>, a <italic toggle="yes">virtual lock mass</italic> (VLM) with respect to (&#x01d4ae;, <italic toggle="yes">w</italic>) is a point <italic toggle="yes">υ</italic> on the <italic toggle="yes">m/z</italic> axis such that there exists a set &#x01d4ab; of peaks from &#x01d4ae; that satisfies the following properties
<list list-type="order" hwp:id="list-1"><list-item hwp:id="list-item-1"><p hwp:id="p-46">&#x01d4ab; contains exactly one peak from each spectrum in &#x01d4ae;.</p></list-item><list-item hwp:id="list-item-2"><p hwp:id="p-47">The average of the <italic toggle="yes">m/z</italic> values of the peaks in &#x01d4ab; is equal to <italic toggle="yes">υ</italic>.</p></list-item><list-item hwp:id="list-item-3"><p hwp:id="p-48">Every peak in &#x01d4ab; has a <italic toggle="yes">m/z</italic> value located in the interval [<italic toggle="yes">υ</italic>(1 − <italic toggle="yes">w</italic>), <italic toggle="yes">υ</italic>(1 + <italic toggle="yes">w</italic>)].</p></list-item><list-item hwp:id="list-item-4"><p hwp:id="p-49">No other peak in &#x01d4ae; has an <italic toggle="yes">m/z</italic> value that belongs to [<italic toggle="yes">υ</italic>(1 − <italic toggle="yes">w</italic>), <italic toggle="yes">υ</italic>(1 + <italic toggle="yes">w</italic>)].</p></list-item><list-item hwp:id="list-item-5"><p hwp:id="p-50">Every peak in &#x01d4ab; has an intensity superior to a threshold <italic toggle="yes">t</italic>.</p></list-item></list></p><p hwp:id="p-51">If and only if all these criteria are satisfied, we say that &#x01d4ab; is the set of peaks associated with the VLM <italic toggle="yes">υ</italic>.</p><p hwp:id="p-52">Note than we impose an intensity threshold <italic toggle="yes">t</italic>, since peaks with a higher intensity will tend to have a higher mass accuracy. Hence, in principle, a VLM is defined only with respect to (w.r.t.) (&#x01d4ae;, <italic toggle="yes">w, t</italic>). However, we will drop the reference to <italic toggle="yes">t</italic> to simplify the notation.</p><p hwp:id="p-53">A crucial aspect of the definition of a VLM is the fact that it holds only w.r.t. a given value of a window size <italic toggle="yes">w</italic>. Indeed, consider <xref ref-type="fig" rid="fig3" hwp:id="xref-fig-3-1" hwp:rel-id="F3">Fig (3)</xref> which represents the peaks coming from three different spectra. We can observe that a first window size <italic toggle="yes">w</italic><sub>1</sub> will correctly detect four VLM points. If the window size is too large however, we observe the case of <italic toggle="yes">w</italic><sub>2</sub>: peaks that are further apart can be erroneously grouped into a VLM group. Moreover, <italic toggle="yes">w</italic><sub>2</sub> can detect the first grouping of peaks within the figure as a VLM, and then the shown grouping as a second one. Thus, the same peaks would be part of two distinct VLM points. This would create ambiguity in the correction and is nonsensical. The last possible case is that of a window size that is too small. In this situation, the window would be unable to detect groups of peaks coming from each spectra of &#x01d4ae;.</p><p hwp:id="p-54">Hence, this motivates the following definition of overlapping VLM points. Given (&#x01d4ae;, <italic toggle="yes">w</italic>), a VLM <italic toggle="yes">υ<sub>i</sub></italic> w.r.t. (&#x01d4ae;, <italic toggle="yes">w</italic>) is said to <italic toggle="yes">overlap</italic> with another VLM <italic toggle="yes">υ<sub>j</sub></italic> (with respect to (&#x01d4ae;, <italic toggle="yes">w</italic>)) if and only if there exists an intersection between the <italic toggle="yes">m/z</italic> interval [<italic toggle="yes">υ<sub>i</sub></italic>(1 − <italic toggle="yes">w</italic>), <italic toggle="yes">υ<sub>i</sub></italic>(1 + <italic toggle="yes">w</italic>)] and the <italic toggle="yes">m/z</italic> interval [<italic toggle="yes">υ<sub>j</sub></italic>(1 − <italic toggle="yes">w</italic>), <italic toggle="yes">υ<sub>j</sub></italic>(1 + <italic toggle="yes">w</italic>)]. Moreover, we say that a VLM <italic toggle="yes">υ</italic> w.r.t. (&#x01d4ae;, <italic toggle="yes">w</italic>) is <italic toggle="yes">isolated</italic> from all all other VLM with w.r.t. (&#x01d4ae;, <italic toggle="yes">w</italic>) if and only if there does not exists any other VLM <italic toggle="yes">υ′</italic> w.r.t. (&#x01d4ae;, <italic toggle="yes">w</italic>) that overlaps with <italic toggle="yes">υ</italic>. For a given window size <italic toggle="yes">w</italic>, the algorithm that we present in the next subsection identifies <italic toggle="yes">all</italic> isolated VLM points w.r.t. (&#x01d4ae;, <italic toggle="yes">w</italic>). Consequently, the best value for <italic toggle="yes">w</italic> is one for which the number of isolated VLM points is the largest.</p><fig id="fig3" position="float" fig-type="figure" orientation="portrait" hwp:id="F3" hwp:rev-id="xref-fig-3-1"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;292425v3/FIG3</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F3</object-id><object-id pub-id-type="publisher-id">fig3</object-id><label>Fig 3.</label><caption hwp:id="caption-5"><title hwp:id="title-20">Peaks coming from three different spectra</title><p hwp:id="p-55">(identified as 1, 2, and 3). Window size <italic toggle="yes">w</italic><sub>1</sub> correctly detects four VLM groups. Window size <italic toggle="yes">w</italic><sub>2</sub> however is too wide and will detect ambiguous and erroneous groups. Moreover, <italic toggle="yes">w</italic><sub>2</sub> will detect several
overlapping VLM groups.</p></caption><graphic xlink:href="292425_fig3" position="float" orientation="portrait" hwp:id="graphic-5"/></fig></sec><sec id="s4b" hwp:id="sec-17"><title hwp:id="title-21">An Algorithm for Virtual Lock Mass Identification</title><p hwp:id="p-56">Given a sequence &#x01d4ae; = {<italic toggle="yes">S<sub>1</sub></italic>, …,<italic toggle="yes">S<sub>m</sub></italic>} of <italic toggle="yes">m</italic> spectra, each peak is identified by a pair (<italic toggle="yes">σ, ρ</italic>) where <italic toggle="yes">σ</italic> ∈ {1, …, <italic toggle="yes">m</italic>} is the index of its spectrum of origin and <italic toggle="yes">ρ</italic> ∈ {1, …, <italic toggle="yes">n<sub>σ</sub></italic>} is the index of the peak in spectrum <italic toggle="yes">S<sub>σ</sub></italic> containing <italic toggle="yes">n<sub>σ</sub></italic> peaks. Given that we have a total of <italic toggle="yes">n</italic> peaks in &#x01d4ae;, we have that <inline-formula hwp:id="inline-formula-2"><alternatives hwp:id="alternatives-2"><inline-graphic xlink:href="292425_inline2.gif" hwp:id="inline-graphic-2"/></alternatives></inline-formula>. For the description of the algorithm, <italic toggle="yes">μ</italic>(<italic toggle="yes">σ, ρ</italic>) denotes the <italic toggle="yes">m/z</italic> value of peak (<italic toggle="yes">σ, ρ</italic>). Finally, we assume that the peaks in each spectra <italic toggle="yes">S<sub>i</sub></italic> are listed in increasing order of their <italic toggle="yes">m/z</italic> values.</p><p hwp:id="p-57">The proposed algorithm uses two data structures: a <italic toggle="yes">binary heap</italic> and a so-called <italic toggle="yes">active sequence</italic>. A binary heap is a classical data structure used for priority queues which are useful when one wants to efficiently remove the element of highest priority in a queue. In our case, the heap will maintain, at any time, the next peak of each spectra to be processed by the algorithm. Hence, given a set &#x01d4ae; of <italic toggle="yes">m</italic> spectra, the heap generally contains a set of <italic toggle="yes">m</italic> peaks, where each peak belongs to a different spectrum of &#x01d4ae;. The “priority value” for each peak (<italic toggle="yes">σ, ρ</italic>) in the heap is given by its <italic toggle="yes">m/z</italic> value <italic toggle="yes">μ</italic>(<italic toggle="yes">σ, ρ</italic>); a peak with the smaller mass is always on top of the heap. A heap <italic toggle="yes">H</italic> containing the first peak of each spectrum can thus be constructed in <italic toggle="yes">O</italic>(<italic toggle="yes">m</italic>) time. Moreover, we can read the <italic toggle="yes">m/z</italic> value at the top of the heap in constant time; we can remove the peak (<italic toggle="yes">σ, ρ</italic>) of the top of the heap and replace it with the next available peak in the spectrum <italic toggle="yes">S<sub>σ</sub></italic> in <italic toggle="yes">O</italic>(log <italic toggle="yes">m</italic>) time <sup><xref ref-type="fn" rid="fn1" hwp:id="xref-fn-3-1" hwp:rel-id="fn-3">1</xref></sup>.</p><p hwp:id="p-58">The second data structure is, what we call, the <italic toggle="yes">active sequence A</italic>. At any time, <italic toggle="yes">A</italic> contains a sequence of peaks, listed in increasing order of their <italic toggle="yes">m/z</italic> values, which are currently being considered to become a VLM sequence. That data structure uses a doubly linked list <italic toggle="yes">L</italic> and a boolean-valued vector <italic toggle="yes">B</italic> of dimension <italic toggle="yes">m</italic>. The linked list <italic toggle="yes">L</italic> is actually containing the sequence of peaks to be considered for the next VLM and the vector <italic toggle="yes">B</italic> is such that, at any time, <italic toggle="yes">B</italic>[<italic toggle="yes">σ</italic>] = <italic toggle="yes">True</italic> if and only if a peak from spectrum <italic toggle="yes">S<sub>σ</sub></italic> is present in <italic toggle="yes">L</italic>. The active sequence <italic toggle="yes">A</italic> also maintains the <italic toggle="yes">m/z</italic> value <italic toggle="yes">μ<sub>l</sub></italic> of the last peak that was removed from <italic toggle="yes">L</italic>, the average <italic toggle="yes">m/z</italic> value <italic toggle="yes">μ<sub>A</sub></italic> of the peaks in <italic toggle="yes">L</italic>, and a copy <italic toggle="yes">w<sub>A</sub></italic> of the window size <italic toggle="yes">w</italic> chosen by the user. Since <italic toggle="yes">L</italic> is a linked list, we can read the front (first) and back (last) values of <italic toggle="yes">L</italic> in constant time, as well as obtaining its size (number of peaks). Removing the value at the front of <italic toggle="yes">L</italic> is also performed in constant time.</p><p hwp:id="p-59">We now present a short description of the algorithm for virtual lock mass identification. The detailed description is provided in Supplementary Information 1.</p><sec id="s4b1" hwp:id="sec-18"><title hwp:id="title-22">Validation of an active sequence</title><p hwp:id="p-60">For this step, we use a method, call <italic toggle="yes">A.isV alid</italic>(), that returns <italic toggle="yes">True</italic> if and only if the peaks in the active sequence <italic toggle="yes">A</italic> satisfies all the criteria enumerated in the definition of a VLM. A precondition for the validity of this method is that <italic toggle="yes">L</italic> contains only peaks that belong to distinct spectra of &#x01d4ae;. This precondition holds initially for an empty list <italic toggle="yes">L</italic> and will always be enforced each time a new peak gets inserted in <italic toggle="yes">A</italic>, as we will see below. Thus, this step of the algorithm checks first that the active sequence contains exactly |&#x01d4ae;| peaks, thus one peak from each spectrum in the set. Then, if there are still peaks in the heap, we verify that the peak at the top of <italic toggle="yes">H</italic> (thus, the peak immediately following the active sequence) has a <italic toggle="yes">m/z</italic> value that is out of the interval [<italic toggle="yes">μ<sub>A</sub></italic>(1 − <italic toggle="yes">w</italic>), <italic toggle="yes">μ<sub>A</sub></italic>(1 + <italic toggle="yes">w</italic>)]. Similarly, it is verified that the peak whose <italic toggle="yes">m/z</italic> value immediately precedes the active sequence also has an <italic toggle="yes">m/z</italic> value outside of [<italic toggle="yes">μ<sub>A</sub></italic>(1 − <italic toggle="yes">w</italic>), <italic toggle="yes">μ<sub>A</sub></italic>(1 + <italic toggle="yes">w</italic>)]. If either peak lies inside this window, then the property (4) of a VLM is violated, as the window contains more than |&#x01d4ae;| peaks. Finally, we ensure that the first and last peaks in the active sequence <italic toggle="yes">A</italic> are both within the window [<italic toggle="yes">μ<sub>A</sub></italic>(1 − <italic toggle="yes">w</italic>), <italic toggle="yes">μ<sub>A</sub></italic>(1 + <italic toggle="yes">w</italic>)]. If all checks pass, then the current sequence is considered a potential virtual lock mass.</p></sec><sec id="s4b2" hwp:id="sec-19"><title hwp:id="title-23">Advancing the active sequence</title><p hwp:id="p-61">This step tries to insert at the end of the list <italic toggle="yes">L</italic> of <italic toggle="yes">A</italic> the peak (<italic toggle="yes">σ, ρ</italic>) located on top of <italic toggle="yes">H</italic>. The insertion succeeds if the resulting <italic toggle="yes">A</italic> still have some probability that the peak sequence can become a VLM after zero or more future insertions. Thus, we first verify if another peak from spectrum &#x01d4ae;<italic toggle="yes"><sub>σ</sub></italic> is present in <italic toggle="yes">A</italic>. If that is the case, then the insertion fails. Otherwise, we compute the new value <italic toggle="yes">μ′<sub>A</sub></italic> that <italic toggle="yes">μ<sub>A</sub></italic> will have after the insertion. If the peak at the front of <italic toggle="yes">L</italic> (the peak in <italic toggle="yes">A</italic> having the smallest <italic toggle="yes">m/z</italic> value) and the new peak (<italic toggle="yes">σ, ρ</italic>) have masses that are within the window [<italic toggle="yes">μ′<sub>A</sub></italic>(1 − <italic toggle="yes">w<sub>A</sub></italic>), <italic toggle="yes">μ′<sub>A</sub></italic>(1 + <italic toggle="yes">w<sub>A</sub></italic>)], then the insertion succeeds. The peak is inserted, and <italic toggle="yes">H</italic> is updated by removing the peak (<italic toggle="yes">σ, ρ</italic>) and adding the next peak from the spectrum &#x01d4ae;<italic toggle="yes"><sub>σ</sub></italic>. Thus, this step ensures that we can insert a new peak in <italic toggle="yes">A</italic> and still have some probability that the sequence can become a VLM after zero or more future insertions.</p><p hwp:id="p-62">Whenever we have an insertion failure, it means that the active sequence cannot become a valid VLM and that we must remove from <italic toggle="yes">A</italic> the peak having the smallest <italic toggle="yes">m/z</italic> value (which is located in the front of <italic toggle="yes">L</italic>) in order to have a chance that the sequence of peaks in <italic toggle="yes">A</italic> becomes a valid VLM.</p></sec><sec id="s4b3" hwp:id="sec-20"><title hwp:id="title-24">Advancing the lower bound</title><p hwp:id="p-63">This step is called to remove the peak (<italic toggle="yes">σ, ρ</italic>) at the front of <italic toggle="yes">L</italic> until a valid insertion can be made. First, it updates <italic toggle="yes">B</italic>[<italic toggle="yes">σ</italic>] to <italic toggle="yes">False</italic>, as peak (<italic toggle="yes">σ, ρ</italic>) is about to be removed and no peak from <italic toggle="yes">S<sub>σ</sub></italic> will be in the active sequence <italic toggle="yes">A</italic> anymore. The <italic toggle="yes">m/z</italic> value of peak (<italic toggle="yes">σ, ρ</italic>) is copied in <italic toggle="yes">μ<sub>l</sub></italic>, and the peak is then removed from <italic toggle="yes">L</italic>. If <italic toggle="yes">L</italic> is empty at this point, its average <italic toggle="yes">m/z</italic> value <italic toggle="yes">μ<sub>A</sub></italic> is set to 0. Otherwise, <italic toggle="yes">μ<sub>A</sub></italic> is set to the average value of the peaks remaining in the active sequence.</p></sec><sec id="s4b4" hwp:id="sec-21"><title hwp:id="title-25">Removing overlapping virtual lock masses</title><p hwp:id="p-64">The final step of the algorithm removes all overlapping VLMs. As described in Appendix 1, a Boolean vector (with a number of components equal to the number of VLMs found) is initialized to <italic toggle="yes">False</italic>. Then, we simply iterate over all the VLM points found and assign the corresponding vector entry to <italic toggle="yes">True</italic> whenever a VLM point (with <italic toggle="yes">m/z</italic> value <italic toggle="yes">μ</italic>) is found such that its window [<italic toggle="yes">μ</italic>(1 − <italic toggle="yes">w</italic>), <italic toggle="yes">μ</italic>(1 + <italic toggle="yes">w</italic>)] overlaps with that of its neighboring VLMs. Only the VLMs whose entry in the vector is <italic toggle="yes">False</italic> are kept.</p><statement hwp:id="statement-1"><label>Algorithm 1:</label><title hwp:id="title-26">The Virtual Lock Mass Detection Algorithm</title><p hwp:id="p-65"><bold>virtualLockMassDetection</bold>(&#x01d4ae;, <italic toggle="yes">w</italic>);</p><p hwp:id="p-66"><bold>Input:</bold> &#x01d4ae; = {<italic toggle="yes">S</italic><sub>1</sub>, <italic toggle="yes">S</italic><sub>2</sub>, …, <italic toggle="yes">S<sub>m</sub></italic>}, a sequence of mass spectra.</p><p hwp:id="p-67"><bold>Input:</bold> <italic toggle="yes">w</italic>, a window size parameter in relative units.</p><p hwp:id="p-68"><bold>Output:</bold> The sequence of all isolated VLM points with respect to (&#x01d4ae;, <italic toggle="yes">w</italic>).</p><p hwp:id="p-69"><bold>Data:</bold> <italic toggle="yes">H</italic>, a heap initialized with <italic toggle="yes">H.init</italic>(&#x01d4ae;); thus containing the first peak of each spectra in &#x01d4ae;.</p><p hwp:id="p-70"><bold>Data:</bold> <italic toggle="yes">A</italic>, an active sequence initialized with <italic toggle="yes">A.init</italic>(<italic toggle="yes">H, w</italic>); hence initially empty.</p><p hwp:id="p-71"><bold>Data:</bold> <italic toggle="yes">&#x01d4b0;</italic>, a sequence of <italic toggle="yes">m/z</italic> values, initially empty.</p></statement><fig id="ufig1" position="float" fig-type="figure" orientation="portrait" hwp:id="F4"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;292425v3/UFIG1</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F4</object-id><object-id pub-id-type="publisher-id">ufig1</object-id><graphic xlink:href="292425_ufig1" position="float" orientation="portrait" hwp:id="graphic-6"/></fig></sec><sec id="s4b5" hwp:id="sec-22"><title hwp:id="title-27">Main algorithm</title><p hwp:id="p-72">Having described the data structures used and their methods, we are now in position to present the main algorithm for virtual lock mass detection, which is described by Algorithm (1). The task of this algorithm is to find all the isolated VLM points w.r.t. (&#x01d4ae;, <italic toggle="yes">w</italic>). To achieve this, the central part of the algorithm is to find find the sequence <italic toggle="yes">&#x01d4b0;</italic> = 〈<italic toggle="yes">μ</italic><sub>1</sub>, …, <italic toggle="yes">μ<sub>|&#x01d4b0;|</sub></italic>〉 of all possible VLM points w.r.t. (&#x01d4ae;, <italic toggle="yes">w</italic>). This sequence may contain several pairs of overlapping VLMs. The strategy to achieve this central task is to use <italic toggle="yes">A.insert</italic>(<italic toggle="yes">H,</italic> &#x01d4ae;) to try to insert in <italic toggle="yes">A</italic> (consequently in <italic toggle="yes">L</italic>) the next unprocessed peak of &#x01d4ae;, which is always located on the top of the heap <italic toggle="yes">H</italic>. Initially, the first such peak of &#x01d4ae;, a peak having the smallest <italic toggle="yes">m/z</italic> value among those in &#x01d4ae;, gets eventually inserted in an empty <italic toggle="yes">A</italic> by <italic toggle="yes">A.insert</italic>(<italic toggle="yes">H,</italic> &#x01d4ae;). Next, after verifying with <italic toggle="yes">A.isV alid</italic>(<italic toggle="yes">H</italic>) if the content of <italic toggle="yes">A</italic> satisfies the criteria to be a valid VLM sequence, we try to insert again in <italic toggle="yes">A</italic> the next available peak. On each insertion failure, we test if, before this insertion, the content of <italic toggle="yes">A</italic> was a valid VLM sequence. This is done with the Boolean variable <italic toggle="yes">found</italic> (which is set to <italic toggle="yes">True</italic> as soon as the content of <italic toggle="yes">A</italic> is a valid VLM sequence and which is set to <italic toggle="yes">F alse</italic> immediately after the average <italic toggle="yes">m/z</italic> value <italic toggle="yes">μ<sub>A</sub></italic> of <italic toggle="yes">A</italic>’s content is appended to <italic toggle="yes">&#x01d4b0;</italic>). Hence, for each considered peak in <italic toggle="yes">L.front</italic>(), we try to insert one more peak in <italic toggle="yes">L</italic> and test after the insertion if <italic toggle="yes">L</italic>’s content is a valid VLM sequence. If we cannot insert an extra peak in <italic toggle="yes">L</italic> with the current peak in <italic toggle="yes">L.front</italic>() this means that there is no possibility of finding one more VLM sequence with the current peak in <italic toggle="yes">L.front</italic>(). In that case we remove that peak from <italic toggle="yes">L</italic> with <italic toggle="yes">A.advanceLowerBound</italic>() and, consequently, <italic toggle="yes">L.front</italic>() now becomes the peak that was next to <italic toggle="yes">L.front</italic>() in <italic toggle="yes">L</italic>. Hence, with this strategy, the algorithm attempts to find the largest consecutive sub-sequence of peaks from &#x01d4ae; that starts with any given peak in &#x01d4ae; and that forms a valid VLM sequence<sup><xref ref-type="fn" rid="fn2" hwp:id="xref-fn-4-1" hwp:rel-id="fn-4">2</xref></sup>. In addition, note that in the <bold>else</bold> branch of Algorithm (1), we verify if <italic toggle="yes">H</italic> becomes empty after a successful insertion. In that case, we need to check if we can find a valid VLM sequence by incrementing sequentially the lower bound <italic toggle="yes">L.front</italic>() and then append to <italic toggle="yes">&#x01d4b0;</italic> the first VLM found. Then, we can safely exit the <bold>while</bold> loop since any other possible VLM sequence will be a subset of the one already found. Without this else branch, a VLM sequence that ends with the last peak presented by <italic toggle="yes">H</italic> would be missed by the algorithm. As explained in Appendix 1, the running time of Algorithm (1) (i.e., the VLM detection algorithm) is in <italic toggle="yes">O</italic>(<italic toggle="yes">n</italic> log <italic toggle="yes">m</italic>) for a sequence &#x01d4ae; of <italic toggle="yes">m</italic> spectra that contains a total of <italic toggle="yes">n</italic> peaks. This, however, is for a fixed value of window size <italic toggle="yes">w</italic>. Note that in order to obtain the most accurate correction (by interpolation) for the spectra in &#x01d4ae;, we should use the largest number of isolated (i.e., non-overlapping) VLMs we can find. Consequently, the optimal value for <italic toggle="yes">w</italic> is the one for which Algorithm (1) will give the largest number of isolated VLMs. Moreover, note that if <italic toggle="yes">w</italic> is too small, very few VLMs will be detected as <italic toggle="yes">w</italic> will not be able to cover exactly one peak per spectra. If, on the other hand, <italic toggle="yes">w</italic> is too large, a large number of the VLMs found in the first phase of the algorithm will overlap and the remaining isolated VLMs will be rare. Consequently, because of this “unimodal” behavior, one can generally find rapidly the best value for <italic toggle="yes">w</italic>. In our case, we never needed to tried more than 20 different values.</p></sec></sec><sec id="s4c" hwp:id="sec-23"><title hwp:id="title-28">An Algorithm for Virtual Lock Mass Correction</title><p hwp:id="p-73">Given a set &#x01d4ae; of spectra and a widow size parameter <italic toggle="yes">w</italic> expressed in relative units, once the sequence &#x01d4b1; of all isolated VLM points w.r.t. (&#x01d4ae;, <italic toggle="yes">w</italic>) has been determined, the individual spectra in &#x01d4ae; can be corrected in a manner similar as it is usually done with traditional lock masses. Algorithm (2) performs the correction needed for each peak in a spectrum <italic toggle="yes">S</italic> ∈ &#x01d4ae;.</p><statement hwp:id="statement-2"><label>Algorithm 2:</label><title hwp:id="title-29">Virtual Lock Mass Correction Algorithm</title><p hwp:id="p-74"><bold>virtualLockMassCorrection</bold>(&#x01d4ae;, &#x01d4b1;, <italic toggle="yes">w</italic>);</p><p hwp:id="p-75"><bold>Input:</bold> &#x01d4ae; = 〈(<italic toggle="yes">μ</italic><sub>1</sub>, <italic toggle="yes">ι</italic><sub>1</sub>), (<italic toggle="yes">μ</italic><sub>2</sub>, <italic toggle="yes">ι</italic><sub>2</sub>), …, (<italic toggle="yes">μ<sub>m</sub>, ι<sub>m</sub></italic>) 〉, a spectrum</p><p hwp:id="p-76"><bold>Input:</bold> &#x01d4b1; = 〈<italic toggle="yes">υ</italic><sub>1</sub>, <italic toggle="yes">υ</italic><sub>2</sub>, …, <italic toggle="yes">υ<sub>n</sub></italic>, 〉 a sequence of <italic toggle="yes">m/z</italic> values (VLMs) sorted in increasing order</p><p hwp:id="p-77"><bold>Input:</bold> <italic toggle="yes">w</italic>, a window size parameter in relative units</p><p hwp:id="p-78"><bold>Output:</bold> A spectrum <italic toggle="yes">S′</italic>=〈(<italic toggle="yes">μ′</italic><sub>1</sub>, <italic toggle="yes">ι</italic><sub>1</sub>), (<italic toggle="yes">μ′</italic><sub>2</sub>, <italic toggle="yes">ι</italic><sub>2</sub>), …, (<italic toggle="yes">μ′<sub>m</sub>, ι<sub>m</sub></italic>)〉 where each <italic toggle="yes">μ′<sub>j</sub></italic> is the corrected <italic toggle="yes">m/z</italic> value for the peak (<italic toggle="yes">μ<sub>j</sub>, ι<sub>j</sub></italic>) ∈ &#x01d4ae;</p><p hwp:id="p-79"><bold>Data: <italic toggle="yes">α</italic></bold> = (<italic toggle="yes">α</italic><sub>1</sub>, …, <italic toggle="yes">α<sub>n</sub></italic>), a vector of indexes (natural numbers)</p></statement><fig id="ufig2" position="float" fig-type="figure" orientation="portrait" hwp:id="F5"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;292425v3/UFIG2</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F5</object-id><object-id pub-id-type="publisher-id">ufig2</object-id><graphic xlink:href="292425_ufig2" position="float" orientation="portrait" hwp:id="graphic-7"/></fig><p hwp:id="p-80">First, in the <bold>for</bold> loop, we identify each peak of <italic toggle="yes">S</italic> corresponding to a lock mass point <italic toggle="yes">υ<sub>i</sub></italic> ∈ &#x01d4b1;. Since <italic toggle="yes">S</italic> ∈ &#x01d4ae; and <italic toggle="yes">υ<sub>i</sub></italic> is a VLM point w.r.t. (&#x01d4ae;, <italic toggle="yes">w</italic>), we are assured to find exactly one such peak <italic toggle="yes">p<sub>j</sub></italic> ∈ <italic toggle="yes">S</italic> with an observed <italic toggle="yes">m/z</italic> value of <italic toggle="yes">μ<sub>j</sub></italic> such that <italic toggle="yes">μ<sub>j</sub></italic> lies in the interval [(1 − <italic toggle="yes">w</italic>)<italic toggle="yes">υ<sub>i</sub></italic>, (1 + <italic toggle="yes">w</italic>)<italic toggle="yes">υ<sub>i</sub></italic>]. For such <italic toggle="yes">μ<sub>j</sub></italic>, we assign the index <italic toggle="yes">j</italic> to <italic toggle="yes">α<sub>i</sub></italic> so that <bold><italic toggle="yes">α</italic></bold> = (<italic toggle="yes">α</italic><sub>1</sub>, …, <italic toggle="yes">α<sub>n</sub></italic>) is a vector of <italic toggle="yes">n</italic> indexes, each pointing to the peak in <italic toggle="yes">S</italic> associated to a VLM point. Note that for <italic toggle="yes">μ<sub>j</sub></italic> ∈ [(1 − <italic toggle="yes">w</italic>)<italic toggle="yes">υ<sub>i</sub></italic>, (1 + <italic toggle="yes">w</italic>)<italic toggle="yes">υ<sub>i</sub></italic>], its corrected <italic toggle="yes">m/z</italic> value must be equal to <italic toggle="yes">υ<sub>i</sub></italic>. Instead of performing these corrections immediately in the <bold>for</bold> loop, we delay them to the linear interpolation step where all peaks having a <italic toggle="yes">m/z</italic> value <italic toggle="yes">μ<sub>j</sub></italic> such that <italic toggle="yes">α</italic><sub>1</sub> ≤ <italic toggle="yes">j</italic> ≤ <italic toggle="yes">α<sub>n</sub></italic> will be corrected.</p><p hwp:id="p-81">Next, for each VLM <italic toggle="yes">υ<sub>i</sub></italic>, we correct by linear interpolation all the <italic toggle="yes">m/z</italic> values <italic toggle="yes">μ<sub>j</sub></italic> such that <italic toggle="yes">α<sub>i</sub></italic> ≤ <italic toggle="yes">j</italic> ≤ <italic toggle="yes">α</italic><sub><italic toggle="yes">i</italic>+1</sub>. To explain precisely this procedure, let <italic toggle="yes">μ′</italic> (<italic toggle="yes">μ<sub>j</sub></italic>) denote the corrected value of <italic toggle="yes">μ<sub>j</sub></italic>. Linear interpolation consists at looking for a correction of the form
<disp-formula id="ueqn1" hwp:id="disp-formula-1">
<alternatives hwp:id="alternatives-3"><graphic xlink:href="292425_ueqn1.gif" position="float" orientation="portrait" hwp:id="graphic-8"/></alternatives>
</disp-formula>
where <italic toggle="yes">a</italic> is called the <italic toggle="yes">slope</italic> and <italic toggle="yes">b</italic> is the <italic toggle="yes">intercept</italic>. By imposing that <italic toggle="yes">μ ′</italic> (<italic toggle="yes">μ<sub>j</sub></italic>) = <italic toggle="yes">υ<sub>i</sub></italic> for <italic toggle="yes">j</italic> = <italic toggle="yes">α<sub>i</sub></italic> and <italic toggle="yes">μ ′</italic> (<italic toggle="yes">μ<sub>j</sub></italic>) = <italic toggle="yes">υ</italic><sub><italic toggle="yes">i</italic>+1</sub> for <italic toggle="yes">j</italic> = <italic toggle="yes">α</italic><sub><italic toggle="yes">i</italic>+1</sub>, we find that
<disp-formula id="ueqn2" hwp:id="disp-formula-2">
<alternatives hwp:id="alternatives-4"><graphic xlink:href="292425_ueqn2.gif" position="float" orientation="portrait" hwp:id="graphic-9"/></alternatives>
</disp-formula>
and <inline-formula hwp:id="inline-formula-3"><alternatives hwp:id="alternatives-5"><inline-graphic xlink:href="292425_inline3.gif" hwp:id="inline-graphic-3"/></alternatives></inline-formula>. The nested <bold>while</bold> loops of the algorithm performs exactly these linear interpolation corrections for all <italic toggle="yes">μ<sub>j</sub></italic> such that <italic toggle="yes">α<sub>i</sub></italic> ≤ <italic toggle="yes">j</italic> ≤ <italic toggle="yes">α</italic><sub><italic toggle="yes">i</italic>+1</sub> for <italic toggle="yes">i</italic> = 1 to <italic toggle="yes">n</italic> − 1.</p><p hwp:id="p-82">Once all <italic toggle="yes">m/z</italic> values <italic toggle="yes">μ<sub>j</sub></italic> such that <italic toggle="yes">α</italic><sub>1</sub> ≤ <italic toggle="yes">j</italic> ≤ <italic toggle="yes">α<sub>n</sub></italic> have been corrected, the algorithm is done. Hence, we have decided not to correct any <italic toggle="yes">m/z</italic> value of <italic toggle="yes">S</italic> that is either smaller that <italic toggle="yes">υ</italic><sub>1</sub>(1 − <italic toggle="yes">w</italic>) or larger than <italic toggle="yes">υ<sub>n</sub></italic>(1 + <italic toggle="yes">w</italic>) because such a peak has only one adjacent VLM and, consequently, could only be corrected by extrapolation, which is much less reliable than interpolation<sup><xref ref-type="fn" rid="fn3" hwp:id="xref-fn-5-1" hwp:rel-id="fn-5">3</xref></sup>. Finally, the intensities of the peaks remain unchanged. The running time complexity of this algorithm is <italic toggle="yes">O</italic>(<italic toggle="yes">m</italic>) where <italic toggle="yes">m</italic> is the number of peaks in the spectrum <italic toggle="yes">S</italic> (see the full details in Appendix 1).</p></sec><sec id="s4d" hwp:id="sec-24"><title hwp:id="title-30">From VLM correction to spectra alignment</title><p hwp:id="p-83">After running the VLM detection and correction algorithms, all the peaks associated with VLM points will be perfectly aligned in the sense that each peak in different spectra associated to a VLM point <italic toggle="yes">υ</italic> will have exactly the same <italic toggle="yes">m/z</italic> value <italic toggle="yes">υ</italic>. However, all the other peaks corrected by Algorithm (2) will not be perfectly aligned in the sense that a molecule fragment responsible for a peak in different spectra will not yield exactly the same mass after correction. This is due to possibly many uncontrollable phenomena that vary each time a sample gets processed by a mass spectrometer, and by the fact that the correction of each peak was performed by an approximate numerical interpolation. However, if all the peaks have been corrected by Algorithm (2), we expect that the peaks corresponding to the same molecule fragment <italic toggle="yes">f</italic> across different spectra will have very similar masses and will all be localized within a very small window of <italic toggle="yes">m/z</italic> values. Moreover, we also expect that the <italic toggle="yes">m/z</italic> values of the peaks coming from another molecule fragment <italic toggle="yes">g</italic> having a different mass will not cross the <italic toggle="yes">m/z</italic> values coming from molecule fragment <italic toggle="yes">f</italic>.</p><p hwp:id="p-84">More precisely, suppose that we have executed Algorithms (1) and (2) with a window size parameter <italic toggle="yes">w</italic> (in relative units) on a sequence &#x01d4ae; of mass spectra. In addition, suppose that a molecule fragment <italic toggle="yes">f</italic> gives rise to a peak of <italic toggle="yes">m/z</italic> value <italic toggle="yes">μ</italic><sub>1</sub> in spectrum <italic toggle="yes">S</italic><sub>1</sub>, and a peak of <italic toggle="yes">m/z</italic> value <italic toggle="yes">μ</italic><sub>2</sub> in spectrum <italic toggle="yes">S</italic><sub>2</sub>, and so on for a sub-sequence of spectra in &#x01d4ae;. Let <italic toggle="yes">ℳ<sub>f</sub></italic> = {<italic toggle="yes">μ</italic><sub>1</sub>, <italic toggle="yes">μ</italic><sub>2</sub>,…} be the set of these <italic toggle="yes">m/z</italic> values. Moreover, let <italic toggle="yes">μ<sub>f</sub></italic> be the average of the <italic toggle="yes">m/z</italic> values in <italic toggle="yes">ℳ<sub>f</sub></italic>. Then, we expect that there exists a window size <italic toggle="yes">θ</italic> in relative units, such that 0 &lt; <italic toggle="yes">θ</italic> ≪ <italic toggle="yes">w</italic>, and for which we have <italic toggle="yes">μ<sub>i</sub></italic> ∈ [<italic toggle="yes">μ<sub>f</sub></italic> (1 − <italic toggle="yes">θ</italic>), <italic toggle="yes">μ<sub>f</sub></italic> (1 +<italic toggle="yes">θ</italic>)] for all <italic toggle="yes">μ<sub>i</sub></italic> ∈ <italic toggle="yes">ℳ<sub>f</sub></italic>. Moreover, if <italic toggle="yes">θ</italic> is sufficiently small, we expect that the sequence <italic toggle="yes">ℳ<sub>g</sub></italic> referring to peaks produced by another molecule fragment <italic toggle="yes">g</italic> having a different mass will be such that each <italic toggle="yes">μ<sub>j</sub></italic> ∈ <italic toggle="yes">ℳ<sub>g</sub></italic> will not be located within [<italic toggle="yes">μ<sub>f</sub></italic> (1 − <italic toggle="yes">θ</italic>), <italic toggle="yes">μ<sub>f</sub></italic> (1 + <italic toggle="yes">θ</italic>)].</p><p hwp:id="p-85">Motivated by this hypothesis, let us introduce the following definitions. Given that Algorithms (1) and (2) have been executed on a set &#x01d4ae; of mass spectra with window size parameter <italic toggle="yes">w</italic> in relative units, and given that we have another window size parameter <italic toggle="yes">θ</italic> ≪ <italic toggle="yes">w</italic> in relative units, we say that a <italic toggle="yes">m/z</italic> value <italic toggle="yes">μ<sub>f</sub></italic> is an <italic toggle="yes">alignment point</italic> w.r.t. (&#x01d4ae;, <italic toggle="yes">θ</italic>) if there exists a set <italic toggle="yes">ℳ<sub>f</sub></italic> of peaks from &#x01d4ae; that satisfies the following properties.</p><list list-type="order" hwp:id="list-2"><list-item hwp:id="list-item-6"><p hwp:id="p-86">Every peak in <italic toggle="yes">ℳ<sub>f</sub></italic> comes from a different spectrum of &#x01d4ae;.</p></list-item><list-item hwp:id="list-item-7"><p hwp:id="p-87">The average of the <italic toggle="yes">m/z</italic> values of the peaks in <italic toggle="yes">ℳ<sub>f</sub></italic> is equal to <italic toggle="yes">μ<sub>f</sub></italic>.</p></list-item><list-item hwp:id="list-item-8"><p hwp:id="p-88">Every peak in <italic toggle="yes">ℳ<sub>f</sub></italic> has an <italic toggle="yes">m/z</italic> value in [<italic toggle="yes">μ<sub>f</sub></italic> (1 − <italic toggle="yes">θ</italic>), <italic toggle="yes">μ<sub>f</sub></italic> (1 +<italic toggle="yes">θ</italic>)] and all other peaks of &#x01d4ae; have an <italic toggle="yes">m/z</italic> value outside this interval.</p></list-item><list-item hwp:id="list-item-9"><p hwp:id="p-89">There does not exist another peak in &#x01d4ae; that we can add to <italic toggle="yes">ℳ<sub>f</sub></italic> and still satisfy the above properties.</p></list-item></list><p hwp:id="p-90">Whenever these criteria are satisfied, we say that <italic toggle="yes">ℳ<sub>f</sub></italic> is the <italic toggle="yes">alignment set associated</italic> to alignment point <italic toggle="yes">μ<sub>f</sub></italic>. Given &#x01d4ae; and <italic toggle="yes">θ</italic>, an alignment point <italic toggle="yes">μ<sub>f</sub></italic> w.r.t. (&#x01d4ae;, <italic toggle="yes">θ</italic>) is said to <italic toggle="yes">overlap</italic> with another alignment point <italic toggle="yes">μ<sub>g</sub></italic> w.r.t. (&#x01d4ae;, <italic toggle="yes">θ</italic>) if and only if there exists a non-empty intersection between the <italic toggle="yes">m/z</italic> intervals [<italic toggle="yes">μ<sub>f</sub></italic> (1 − <italic toggle="yes">θ</italic>), <italic toggle="yes">μ<sub>f</sub></italic> (1 +<italic toggle="yes">θ</italic>)] and [<italic toggle="yes">μ<sub>g</sub></italic>(1 − <italic toggle="yes">θ</italic>), <italic toggle="yes">μ<sub>g</sub></italic>(1 + <italic toggle="yes">θ</italic>)].</p><p hwp:id="p-91">Let <inline-formula hwp:id="inline-formula-4"><alternatives hwp:id="alternatives-6"><inline-graphic xlink:href="292425_inline4.gif" hwp:id="inline-graphic-4"/></alternatives></inline-formula>. Note that there are only two differences between the definition of alignment point (and its associated alignment sequence) and the definition of VLM point (and its associated VLM set). The first difference is the fact that a VLM set must contain exactly <italic toggle="yes">m</italic> peaks, whereas an alignment set can contain any number of peaks between 1 to <italic toggle="yes">m</italic> (since the peaks in an alignment set may originate from a molecule fragment which is not present in all the samples for which we have a spectrum in &#x01d4ae;). Hence, if we remove the constraint that each virtual lock mass must be formed of |&#x01d4ae;| peaks from the validation step, Algorithm (1) then finds all the maximum-length sub-sequence of peaks that satisfy the 4 criteria for a valid alignment set when it reaches the overlap deletion step. The second difference is that there is no intensity threshold <italic toggle="yes">t</italic> applied to the peaks for alignment, as we wish to align every peak in the spectra if possible. Note that, generally, a lower intensity threshold is still applied to the peaks in order to remove peaks that are the result of background noise. Consequently, with that very minor change,
<disp-formula id="ueqn3" hwp:id="disp-formula-3">
<alternatives hwp:id="alternatives-7"><graphic xlink:href="292425_ueqn3.gif" position="float" orientation="portrait" hwp:id="graphic-10"/></alternatives>
</disp-formula>
finds all isolated alignment points w.r.t. (&#x01d4ae;, <italic toggle="yes">θ</italic>) in <italic toggle="yes">O</italic>(<italic toggle="yes">n</italic> log <italic toggle="yes">m</italic>) time, where <italic toggle="yes">n</italic> is the total number of peaks in &#x01d4ae;.</p><p hwp:id="p-92">If the window size parameter <italic toggle="yes">θ</italic> is too large, then many alignment points will overlap and Algorithm (1) will return very few isolated alignment points. If <italic toggle="yes">θ</italic> is very very small, then, in contrast with the VLM identification case, Algorithm (1) will return a very large number of isolated alignment points associated to aligned sets that contain only one point. Hence, in contrast with the VLM identification case, the best parameter is not the one for which we obtain the largest number of alignment points. What should then be the choice for <italic toggle="yes">θ</italic>? To answer this question, we consider each VLM point (and its associated sequence of peaks) found by Algorithm (1). If we leave out one VLM point <italic toggle="yes">υ<sub>i</sub></italic> from the correction algorithm (2) and use this algorithm to correct all the <italic toggle="yes">m/z</italic> values of the peaks associated to this VLM point, the maximum deviation from <italic toggle="yes">υ<sub>i</sub></italic> among these <italic toggle="yes">m/z</italic> values will give us the smallest window size <italic toggle="yes">θ<sub>i</sub></italic> such that each <italic toggle="yes">m/z</italic> value will be located within [<italic toggle="yes">υ<sub>i</sub></italic>(1 − <italic toggle="yes">θ<sub>i</sub></italic>), <italic toggle="yes">υ<sub>i</sub></italic>(1 + <italic toggle="yes">θ<sub>i</sub></italic>)]. Essentially, this window size <italic toggle="yes">θ<sub>i</sub></italic> is the smallest one for which we can still recognize all the peaks associated to the same VLM <italic toggle="yes">υ<sub>i</sub></italic>. It would then certainly be a very good choice for <italic toggle="yes">θ</italic> in that region of <italic toggle="yes">m/z</italic> values. We can then repeat this procedure for all isolated VLM points (except the VLMs with the smallest and largest <italic toggle="yes">m/z</italic> values) found by Algorithm (1) to obtain a sequence of <italic toggle="yes">θ<sub>i</sub></italic> values. One interesting possibility for <italic toggle="yes">θ</italic> is the maximum among the <italic toggle="yes">θ<sub>i</sub></italic> values. However, this is clearly an overestimate of the maximum spreading of peaks associated to the same molecule fragment since all the VLMs will be used for the correction, including the one that was left out. Moreover, as we can see in <xref ref-type="fig" rid="fig4" hwp:id="xref-fig-6-1" hwp:rel-id="F6">Figure (4)</xref>, we can recover a large fraction of the non-overlapping VLMs if we use a significantly smaller window size than the max<italic toggle="yes"><sub>i</sub> θ<sub>i</sub></italic>. For that reason, we have decided to use, for the window size <italic toggle="yes">θ</italic>, the smallest value covering 95% of the non-overlapping VLMs, i.e., the 95th percentile. Alternatively, to attempt to maximize the accuracy of a learning algorithm, a percentile <italic toggle="yes">z</italic> can be selected by cross-validation along with the selection of the hyperparameters of the learning algorithm.</p><fig id="fig4" position="float" fig-type="figure" orientation="portrait" hwp:id="F6" hwp:rev-id="xref-fig-6-1"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;292425v3/FIG4</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F6</object-id><object-id pub-id-type="publisher-id">fig4</object-id><label>Fig 4.</label><caption hwp:id="caption-6"><title hwp:id="title-31">Error in ppm versus mass units.</title><p hwp:id="p-93">Subfigure (A) shows the error on left-out VLMs in ppms, while Subfigure (B) shows the error in Daltons.</p></caption><graphic xlink:href="292425_fig4" position="float" orientation="portrait" hwp:id="graphic-11"/></fig><p hwp:id="p-94">If we have <italic toggle="yes">r</italic> VLM points, each <italic toggle="yes">θ<sub>i</sub></italic> associated to the <italic toggle="yes">i</italic>th VLM point is found in <italic toggle="yes">O</italic>(<italic toggle="yes">m</italic>) time for a sequence &#x01d4ae; of <italic toggle="yes">m</italic> spectra; thus implying a running time in <italic toggle="yes">O</italic>(<italic toggle="yes">mr</italic>) to find every <italic toggle="yes">θ<sub>i</sub></italic>. Then, the 95th percentile is found by sorting the vector of <italic toggle="yes">θ<sub>i</sub></italic>s in <italic toggle="yes">O</italic>(<italic toggle="yes">r</italic> log <italic toggle="yes">r</italic>) time. Assuming that we always have log(<italic toggle="yes">r</italic>) &lt; <italic toggle="yes">m</italic>, the total running time to find <italic toggle="yes">θ</italic> is in <italic toggle="yes">O</italic>(<italic toggle="yes">mr</italic>), and hence in <italic toggle="yes">O</italic>(<italic toggle="yes">n</italic>) when &#x01d4ae; contains a total of <italic toggle="yes">n</italic> peaks.</p><p hwp:id="p-95">Once the window size <italic toggle="yes">θ</italic> is found, we can then run Algorithm (1) just once on the full set &#x01d4ae; of spectra with that value of <italic toggle="yes">θ</italic> in <italic toggle="yes">O</italic>(<italic toggle="yes">n</italic> log <italic toggle="yes">m</italic>) time. Consequently, the total running time of the alignment algorithm, which includes the running time to find and to find all non overlapping alignment points w.r.t. (&#x01d4ae;, <italic toggle="yes">θ</italic>), is in <italic toggle="yes">O</italic>(<italic toggle="yes">n</italic> log <italic toggle="yes">m</italic>).</p><p hwp:id="p-96">Once we have the VLM points and the alignment points, these are used to provide a <italic toggle="yes">representation</italic> of the spectra which is well suited for running machine learning algorithms on them. Indeed, consider <xref ref-type="fig" rid="fig5" hwp:id="xref-fig-7-1" hwp:rel-id="F7">Fig (5)</xref>. For any new spectrum <italic toggle="yes">S</italic> the VLM points are first used correct the <italic toggle="yes">m/z</italic> value of each peak of <italic toggle="yes">S</italic> and, following that, the intensity of any corrected peak that fall into the window associated to an alignment point give a feature of <italic toggle="yes">S</italic>. Hence, the vector of these intensities provides a new representation of the spectrum <italic toggle="yes">S</italic> that we will use for the input into a classifier to predict the label of <italic toggle="yes">S</italic>.</p><fig id="fig5" position="float" fig-type="figure" orientation="portrait" hwp:id="F7" hwp:rev-id="xref-fig-7-1"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;292425v3/FIG5</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F7</object-id><object-id pub-id-type="publisher-id">fig5</object-id><label>Fig 5.</label><caption hwp:id="caption-7"><title hwp:id="title-32">A representation of the original spectra</title><p hwp:id="p-97">is given by the intensities of the VLM-corrected peaks that fall into the windows associated to alignment points.</p></caption><graphic xlink:href="292425_fig5" position="float" orientation="portrait" hwp:id="graphic-12"/></fig><p hwp:id="p-98">Finally, it might be tempting to use a clustering approach to solve the problem of finding the isolated alignment points. After all, the alignment sequences are just clusters of peaks belonging to different spectra. However, we have to keep in mind that current trends lead to the processing of hundreds of spectra, each potentially containing thousands of peaks. The total number of peaks to be processed can thus reach a million peaks or more. In our case, the total running time of the full pipeline (finding all isolated VLMs, correcting all the mass spectra with the VLMs, and finding all the isolated alignment points) is in <italic toggle="yes">O</italic>(<italic toggle="yes">n</italic> log <italic toggle="yes">m</italic>). Hence, any algorithm running in Ω(<italic toggle="yes">n</italic><sup>2</sup>) time, will be completely surpassed by the proposed pipeline of algorithms. As far as we know, the running times of popular off-the-shelf clustering algorithms such as K-means and linkage-based clustering algorithms all require a running time in Ω(<italic toggle="yes">n</italic><sup>2</sup>). Moreover, all the clustering algorithms that we know have at least one parameter to tune, which often includes the number of desired clusters. Hence, with the current state of knowledge, a clustering-based algorithm is bound to be substantially less efficient than the proposed pipeline of algorithms.</p><p hwp:id="p-99">An implementation of the algorithms for Python is available at <ext-link l:rel="related" l:ref-type="uri" l:ref="https://github.com/francisbrochu/msvlm" ext-link-type="uri" xlink:href="https://github.com/francisbrochu/msvlm" hwp:id="ext-link-3">https://github.com/francisbrochu/msvlm</ext-link>.</p></sec><sec id="s4e" hwp:id="sec-25"><title hwp:id="title-33">Dataset descriptions</title><sec id="s4e1" hwp:id="sec-26"><title hwp:id="title-34"><italic toggle="yes">Days</italic> Dataset</title><p hwp:id="p-100">Plasma from 20 healthy persons was equally pooled together. The pooled plasma was aliquoted and kept at −20 °C.</p><p hwp:id="p-101">Two consecutive days, an acetonitrile crash was performed using 9 parts of acetonitrile (Fisher Optima) for 1 part of unfrozen plasma pool. The crash solution was centrifuged at 4000 rpm for 5 minutes. 2 <italic toggle="yes">μ</italic>l of the solution was spotted on every well of a 96 wells Lazwell plate (Phytronix). The same experiment was repeated the next day.</p></sec><sec id="s4e2" hwp:id="sec-27"><title hwp:id="title-35"><italic toggle="yes">Clomiphene-Acetaminophen</italic> Dataset</title><p hwp:id="p-102">One pill of acetaminophen (500 mg) was diluted in 50 mL of methanol and water (50:50). The solution was put in a sonicating bath for 20 minutes. The resulting solution was centrifuged and diluted 1:100 in water. For clomiphene, we used a solution of 100<italic toggle="yes">μ</italic>g/ml of clomiphene in methanol (Phytronix).</p><p hwp:id="p-103">A pool of plasma was crashed as previously described. The solution was split in 3 parts. One received 10 <italic toggle="yes">μ</italic>l of the acetaminophen solution, another 10 <italic toggle="yes">μ</italic>l of the clomiphene solution and the last one stayed unmodified. Each type of sample was spotted 32 times.</p></sec><sec id="s4e3" hwp:id="sec-28"><title hwp:id="title-36"><italic toggle="yes">Malaria</italic> Dataset</title><p hwp:id="p-104"><italic toggle="yes">Plasmodium falciparum</italic> parasites were put in culture in red blood cells and tightly synchronized. Culture was performed for 28-36 hours, until parasites are in the trophozoite stage and parasitaemia reached 5-10%. In the same conditions, red blood cells were kept uninfected. Cells were diluted to 2% hematrocrit by adding the correct amount of pelleted cells to complete RPMI media. 200 <italic toggle="yes">μ</italic>L of the cell suspensions was deposited in a 96 well plate in order to have 40 samples of infected cells and 40 samples of uninfected cells.</p><p hwp:id="p-105">After 4 hours at 37 °C, the plate was spin at 800x <italic toggle="yes">g</italic> for 5 minutes. 180 <italic toggle="yes">μ</italic>L of culture media was removed. Pellet was resuspended in the remaining 20 <italic toggle="yes">μ</italic>L and 10 <italic toggle="yes">μ</italic>L was transferred to a new 96 well plate. 100 <italic toggle="yes">μ</italic>L of ice-cold methanol was quickly added to the plate and put on dry-ice to stop any metabolic reaction. The plate was vortexed 3 times, for 15 seconds each, over 15 minutes incubation on dry-ice. The plate then was placed for sonication in a water bath for 5 times 1 minute with 2 minutes breaks on dry-ice. Finally, the plate was centrifuged at 3200 rpm for 5 minutes at 4°C. 30<italic toggle="yes">μ</italic>L of the supernatant was transferred to another plate and kept at −80°C until LDTD-MS analysis.</p><p hwp:id="p-106">For analysis, 2 <italic toggle="yes">μ</italic>l of the metabolomic extract was spotted on a 96 well Lazwell plate and left at room temperature until dryness.</p></sec><sec id="s4e4" hwp:id="sec-29"><title hwp:id="title-37"><italic toggle="yes">Cancer</italic> Dataset</title><p hwp:id="p-107">Plasma from patients diagnosed for breast cancer and from healthy patients were individually treated using the same acetonitrile crash protocol. A total of 96 samples from breast cancer patients were acquired. In addition, 96 plasma samples from healthy patients were also acquired in order to have control samples.</p></sec><sec id="s4e5" hwp:id="sec-30"><title hwp:id="title-38">Data acquisition</title><p hwp:id="p-108">All data were acquired on a Synapt G2-Si mass spectrometer. The instrument was operated in high resolution mode. Except if stated otherwise, data acquisition was performed in positive ionization. The acquisition method was <italic toggle="yes">MS<sup>e</sup></italic> with a scan time of 0.1 second. Calibration of the instrument was performed daily before data acquisition using a solution of sodium formate 0.5 mM. The instrument was operated with Mass Lynx software. The source is a LDTD 960 ion source (Phytronix). The laser pattern used is the following: 2 seconds at 0%, ramp up to 65% in 6 seconds, hold at 65% for 2 seconds and back at 0% in 0.1 second.</p></sec><sec id="s4e6" hwp:id="sec-31"><title hwp:id="title-39">Data conversion</title><p hwp:id="p-109">Raw files produced by the mass spectrometer were converted to ion list using a continuous to centroid approach using the ProcessKernel software (Waters Corporation) using only the first function (low energy) present in the files. The resulting centroided peak list were used for data analysis.</p><p hwp:id="p-110">For all experiments presented in this article, the <italic toggle="yes">t</italic> threshold on intensity for virtual lock mass detection was set at 1000 counts.</p></sec></sec></sec></body><back><ack hwp:id="ack-1"><title hwp:id="title-40">Acknowledgments</title><p hwp:id="p-111">We thank Waters Corporation for their support and expertise that helped to the design of the proposed algorithms and for the support using their instruments. We also thank Phytronix Technologies Inc. for their support with their instruments. Computations were made on the supercomputer Colosse from Université Laval, managed by Calcul Québec and Compute Canada. The operation of this supercomputer is funded by the Canada Foundation for Innovation (CFI), the ministère de l’Économie, de la science et de l’innovation du Québec (MESI) and the Fonds de recherche du Québec - Nature et technologies (FRQ-NT). Computations were also made on the supercomputer Graham from Waterloo University, managed by Compute Canada. Finally, we thank Dr. Dave Richard for providing us with the malaria dataset samples and Dr. Francine Durocher for providing the breast cancer dataset samples.</p></ack><ref-list hwp:id="ref-list-1"><title hwp:id="title-41">References</title><ref id="c1" hwp:id="ref-1" hwp:rev-id="xref-ref-1-1"><label>1.</label><citation publication-type="journal" citation-type="journal" ref:id="292425v3.1" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-1"><string-name name-style="western" hwp:sortable="Dettmer K."><given-names>K.</given-names> <surname>Dettmer</surname></string-name>, <string-name name-style="western" hwp:sortable="Aronov P. A."><given-names>P. A.</given-names> <surname>Aronov</surname></string-name>, <string-name name-style="western" hwp:sortable="Hammock B. D."><given-names>B. D.</given-names> <surname>Hammock</surname></string-name>, <article-title hwp:id="article-title-2">Mass spectrometry-based metabolomics</article-title>, <source hwp:id="source-1">Mass spectrometry reviews</source> <volume>26</volume> (<issue>1</issue>) (<year>2007</year>) <fpage>51</fpage>–<lpage>78</lpage>.</citation></ref><ref id="c2" hwp:id="ref-2" hwp:rev-id="xref-ref-2-1"><label>2.</label><citation publication-type="journal" citation-type="journal" ref:id="292425v3.2" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-2"><string-name name-style="western" hwp:sortable="Han X."><given-names>X.</given-names> <surname>Han</surname></string-name>, <string-name name-style="western" hwp:sortable="Aslanian A."><given-names>A.</given-names> <surname>Aslanian</surname></string-name>, <string-name name-style="western" hwp:sortable="Yates J. R. III"><given-names>J. R.</given-names> <surname>Yates</surname> <suffix>III</suffix></string-name>, <article-title hwp:id="article-title-3">Mass spectrometry for proteomics</article-title>, <source hwp:id="source-2">Current opinion in chemical biology</source> <volume>12</volume> (<issue>5</issue>) (<year>2008</year>) <fpage>483</fpage>–<lpage>490</lpage>.</citation></ref><ref id="c3" hwp:id="ref-3" hwp:rev-id="xref-ref-3-1"><label>3.</label><citation publication-type="journal" citation-type="journal" ref:id="292425v3.3" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-3"><string-name name-style="western" hwp:sortable="Fenselau C."><given-names>C.</given-names> <surname>Fenselau</surname></string-name>, <string-name name-style="western" hwp:sortable="Demirev P. A."><given-names>P. A.</given-names> <surname>Demirev</surname></string-name>, <article-title hwp:id="article-title-4">Characterization of intact microorganisms by maldi mass spectrometry</article-title>, <source hwp:id="source-3">Mass spectrometry reviews</source> <volume>20</volume> (<issue>4</issue>) (<year>2001</year>) <fpage>157</fpage>–<lpage>171</lpage>.</citation></ref><ref id="c4" hwp:id="ref-4" hwp:rev-id="xref-ref-4-1"><label>4.</label><citation publication-type="journal" citation-type="journal" ref:id="292425v3.4" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-4"><string-name name-style="western" hwp:sortable="Caprioli R. M."><given-names>R. M.</given-names> <surname>Caprioli</surname></string-name>, <string-name name-style="western" hwp:sortable="Farmer T. B."><given-names>T. B.</given-names> <surname>Farmer</surname></string-name>, <string-name name-style="western" hwp:sortable="Gile J."><given-names>J.</given-names> <surname>Gile</surname></string-name>, <article-title hwp:id="article-title-5">Molecular imaging of biological samples: localization of peptides and proteins using maldi-tof ms</article-title>, <source hwp:id="source-4">Analytical chemistry</source> <volume>69</volume> (<issue>23</issue>) (<year>1997</year>) <fpage>4751</fpage>–<lpage>4760</lpage>.</citation></ref><ref id="c5" hwp:id="ref-5" hwp:rev-id="xref-ref-5-1"><label>5.</label><citation publication-type="journal" citation-type="journal" ref:id="292425v3.5" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-5"><string-name name-style="western" hwp:sortable="Cox J."><given-names>J.</given-names> <surname>Cox</surname></string-name>, <string-name name-style="western" hwp:sortable="Mann M."><given-names>M.</given-names> <surname>Mann</surname></string-name>, <article-title hwp:id="article-title-6">Quantitative, high-resolution proteomics for data-driven systems biology</article-title>, <source hwp:id="source-5">Annual review of biochemistry</source> <volume>80</volume> (<year>2011</year>) <fpage>273</fpage>–<lpage>299</lpage>.</citation></ref><ref id="c6" hwp:id="ref-6" hwp:rev-id="xref-ref-6-1"><label>6.</label><citation publication-type="journal" citation-type="journal" ref:id="292425v3.6" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-6"><string-name name-style="western" hwp:sortable="Hunt D. F."><given-names>D. F.</given-names> <surname>Hunt</surname></string-name>, <string-name name-style="western" hwp:sortable="Yates J. R."><given-names>J. R.</given-names> <surname>Yates</surname></string-name>, <string-name name-style="western" hwp:sortable="Shabanowitz J."><given-names>J.</given-names> <surname>Shabanowitz</surname></string-name>, <string-name name-style="western" hwp:sortable="Winston S."><given-names>S.</given-names> <surname>Winston</surname></string-name>, <string-name name-style="western" hwp:sortable="Hauer C. R."><given-names>C. R.</given-names> <surname>Hauer</surname></string-name>, <article-title hwp:id="article-title-7">Protein sequencing by tandem mass spectrometry</article-title>, <source hwp:id="source-6">Proceedings of the National Academy of Sciences</source> <volume>83</volume> (<issue>17</issue>) (<year>1986</year>) <fpage>6233</fpage>–<lpage>6237</lpage>.</citation></ref><ref id="c7" hwp:id="ref-7" hwp:rev-id="xref-ref-7-1"><label>7.</label><citation publication-type="journal" citation-type="journal" ref:id="292425v3.7" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-7"><string-name name-style="western" hwp:sortable="Cottrell J. S."><given-names>J. S.</given-names> <surname>Cottrell</surname></string-name>, <string-name name-style="western" hwp:sortable="London U."><given-names>U.</given-names> <surname>London</surname></string-name>, <article-title hwp:id="article-title-8">Probability-based protein identification by searching sequence databases using mass spectrometry data</article-title>, <source hwp:id="source-7">electrophoresis</source> <volume>20</volume> (<issue>18</issue>) (<year>1999</year>) <fpage>3551</fpage>–<lpage>3567</lpage>.</citation></ref><ref id="c8" hwp:id="ref-8" hwp:rev-id="xref-ref-8-1"><label>8.</label><citation publication-type="journal" citation-type="journal" ref:id="292425v3.8" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-8"><string-name name-style="western" hwp:sortable="Alonso A."><given-names>A.</given-names> <surname>Alonso</surname></string-name>, <string-name name-style="western" hwp:sortable="Marsal S."><given-names>S.</given-names> <surname>Marsal</surname></string-name>, <string-name name-style="western" hwp:sortable="Julià A."><given-names>A.</given-names> <surname>Julià</surname></string-name>, <article-title hwp:id="article-title-9">Analytical methods in untargeted metabolomics: state of the art in 2015</article-title>, <source hwp:id="source-8">Frontiers in bioengineering and biotechnology</source> <volume>3</volume> (<year>2015</year>) <fpage>23</fpage>.</citation></ref><ref id="c9" hwp:id="ref-9" hwp:rev-id="xref-ref-9-1"><label>9.</label><citation publication-type="journal" citation-type="journal" ref:id="292425v3.9" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-9"><string-name name-style="western" hwp:sortable="Dunn W. B."><given-names>W. B.</given-names> <surname>Dunn</surname></string-name>, <string-name name-style="western" hwp:sortable="Erban A."><given-names>A.</given-names> <surname>Erban</surname></string-name>, <string-name name-style="western" hwp:sortable="Weber R. J."><given-names>R. J.</given-names> <surname>Weber</surname></string-name>, <string-name name-style="western" hwp:sortable="Creek D. J."><given-names>D. J.</given-names> <surname>Creek</surname></string-name>, <string-name name-style="western" hwp:sortable="Brown M."><given-names>M.</given-names> <surname>Brown</surname></string-name>, <string-name name-style="western" hwp:sortable="Breitling R."><given-names>R.</given-names> <surname>Breitling</surname></string-name>, <string-name name-style="western" hwp:sortable="Hankemeier T."><given-names>T.</given-names> <surname>Hankemeier</surname></string-name>, <string-name name-style="western" hwp:sortable="Goodacre R."><given-names>R.</given-names> <surname>Goodacre</surname></string-name>, <string-name name-style="western" hwp:sortable="Neumann S."><given-names>S.</given-names> <surname>Neumann</surname></string-name>, <string-name name-style="western" hwp:sortable="Kopka J."><given-names>J.</given-names> <surname>Kopka</surname></string-name>, <etal>et al.</etal>, <article-title hwp:id="article-title-10">Mass appeal: metabolite identification in mass spectrometry-focused untargeted metabolomics</article-title>, <source hwp:id="source-9">Metabolomics</source> <volume>9</volume> (<issue>1</issue>) (<year>2013</year>) <fpage>44</fpage>–<lpage>66</lpage>.</citation></ref><ref id="c10" hwp:id="ref-10" hwp:rev-id="xref-ref-10-1"><label>10.</label><citation publication-type="other" citation-type="journal" ref:id="292425v3.10" ref:linkable="no" ref:use-reference-as-is="yes" hwp:id="citation-10"><string-name name-style="western" hwp:sortable="Römpp A."><given-names>A.</given-names> <surname>Römpp</surname></string-name>, <string-name name-style="western" hwp:sortable="Karst U."><given-names>U.</given-names> <surname>Karst</surname></string-name>, <source hwp:id="source-10">Current trends in mass spectrometry imaging</source> (<year>2015</year>).</citation></ref><ref id="c11" hwp:id="ref-11" hwp:rev-id="xref-ref-11-1"><label>11.</label><citation publication-type="journal" citation-type="journal" ref:id="292425v3.11" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-11"><string-name name-style="western" hwp:sortable="Huang M.-Z."><given-names>M.-Z.</given-names> <surname>Huang</surname></string-name>, <string-name name-style="western" hwp:sortable="Yuan C.-H."><given-names>C.-H.</given-names> <surname>Yuan</surname></string-name>, <string-name name-style="western" hwp:sortable="Cheng S.-C."><given-names>S.-C.</given-names> <surname>Cheng</surname></string-name>, <string-name name-style="western" hwp:sortable="Cho Y.-T."><given-names>Y.-T.</given-names> <surname>Cho</surname></string-name>, <string-name name-style="western" hwp:sortable="Shiea J."><given-names>J.</given-names> <surname>Shiea</surname></string-name>, <article-title hwp:id="article-title-11">Ambient ionization mass spectrometry</article-title>, <source hwp:id="source-11">Annual review of analytical chemistry</source> <volume>3</volume>(<year>2010</year>) <fpage>43</fpage>–<lpage>65</lpage>.</citation></ref><ref id="c12" hwp:id="ref-12" hwp:rev-id="xref-ref-12-1"><label>12.</label><citation publication-type="journal" citation-type="journal" ref:id="292425v3.12" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-12"><string-name name-style="western" hwp:sortable="Semmes O. J."><given-names>O. J.</given-names> <surname>Semmes</surname></string-name>, <string-name name-style="western" hwp:sortable="Feng Z."><given-names>Z.</given-names> <surname>Feng</surname></string-name>, <string-name name-style="western" hwp:sortable="Adam B.-L."><given-names>B.-L.</given-names> <surname>Adam</surname></string-name>, <string-name name-style="western" hwp:sortable="Banez L. L."><given-names>L. L.</given-names> <surname>Banez</surname></string-name>, <string-name name-style="western" hwp:sortable="Bigbee W. L."><given-names>W. L.</given-names> <surname>Bigbee</surname></string-name>, <string-name name-style="western" hwp:sortable="Campos D."><given-names>D.</given-names> <surname>Campos</surname></string-name>, <string-name name-style="western" hwp:sortable="Cazares L. H."><given-names>L. H.</given-names> <surname>Cazares</surname></string-name>, <string-name name-style="western" hwp:sortable="Chan D. W."><given-names>D. W.</given-names> <surname>Chan</surname></string-name>, <string-name name-style="western" hwp:sortable="Grizzle W. E."><given-names>W. E.</given-names> <surname>Grizzle</surname></string-name>, <string-name name-style="western" hwp:sortable="Izbicka E."><given-names>E.</given-names> <surname>Izbicka</surname></string-name>, <etal>et al.</etal>, <article-title hwp:id="article-title-12">Evaluation of serum protein profiling by surface-enhanced laser desorption/ionization time-of-flight mass spectrometry for the detection of prostate cancer: I. assessment of platform reproducibility</article-title>, <source hwp:id="source-12">Clinical Chemistry</source> <volume>51</volume> (<issue>1</issue>) (<year>2005</year>) <fpage>102</fpage>–<lpage>112</lpage>.</citation></ref><ref id="c13" hwp:id="ref-13" hwp:rev-id="xref-ref-13-1"><label>13.</label><citation publication-type="journal" citation-type="journal" ref:id="292425v3.13" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-13"><string-name name-style="western" hwp:sortable="Tibshirani R."><given-names>R.</given-names> <surname>Tibshirani</surname></string-name>, <string-name name-style="western" hwp:sortable="Hastie T."><given-names>T.</given-names> <surname>Hastie</surname></string-name>, <string-name name-style="western" hwp:sortable="Narasimhan B."><given-names>B.</given-names> <surname>Narasimhan</surname></string-name>, <string-name name-style="western" hwp:sortable="Soltys S."><given-names>S.</given-names> <surname>Soltys</surname></string-name>, <string-name name-style="western" hwp:sortable="Shi G."><given-names>G.</given-names> <surname>Shi</surname></string-name>, <string-name name-style="western" hwp:sortable="Koong A."><given-names>A.</given-names> <surname>Koong</surname></string-name>, <string-name name-style="western" hwp:sortable="Le Q.-T."><given-names>Q.-T.</given-names> <surname>Le</surname></string-name>, <article-title hwp:id="article-title-13">Sample classification from protein mass spectrometry, by ‘peak probability contrasts’</article-title>, <source hwp:id="source-13">Bioinformatics</source> <volume>20</volume> (<issue>17</issue>) (<year>2004</year>) <fpage>3034</fpage>–<lpage>3044</lpage>.</citation></ref><ref id="c14" hwp:id="ref-14" hwp:rev-id="xref-ref-14-1"><label>14.</label><citation publication-type="journal" citation-type="journal" ref:id="292425v3.14" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-14"><string-name name-style="western" hwp:sortable="Jeffries N."><given-names>N.</given-names> <surname>Jeffries</surname></string-name>, <article-title hwp:id="article-title-14">Algorithms for alignment of mass spectrometry proteomic data</article-title>, <source hwp:id="source-14">Bioinformatics</source> <volume>21</volume> (<issue>14</issue>) (<year>2005</year>) <fpage>3066</fpage>–<lpage>3073</lpage>.</citation></ref><ref id="c15" hwp:id="ref-15" hwp:rev-id="xref-ref-15-1 xref-ref-15-2"><label>15.</label><citation publication-type="journal" citation-type="journal" ref:id="292425v3.15" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-15"><string-name name-style="western" hwp:sortable="Tracy M. B."><given-names>M. B.</given-names> <surname>Tracy</surname></string-name>, <string-name name-style="western" hwp:sortable="Chen H."><given-names>H.</given-names> <surname>Chen</surname></string-name>, <string-name name-style="western" hwp:sortable="Weaver D. M."><given-names>D. M.</given-names> <surname>Weaver</surname></string-name>, <string-name name-style="western" hwp:sortable="Malyarenko D. I."><given-names>D. I.</given-names> <surname>Malyarenko</surname></string-name>, <string-name name-style="western" hwp:sortable="Sasinowski M."><given-names>M.</given-names> <surname>Sasinowski</surname></string-name>, <string-name name-style="western" hwp:sortable="Cazares L. H."><given-names>L. H.</given-names> <surname>Cazares</surname></string-name>, <string-name name-style="western" hwp:sortable="Drake R. R."><given-names>R. R.</given-names> <surname>Drake</surname></string-name>, <string-name name-style="western" hwp:sortable="Semmes O. J."><given-names>O. J.</given-names> <surname>Semmes</surname></string-name>, <string-name name-style="western" hwp:sortable="Tracy E. R."><given-names>E. R.</given-names> <surname>Tracy</surname></string-name>, <string-name name-style="western" hwp:sortable="Cooke W. E."><given-names>W. E.</given-names> <surname>Cooke</surname></string-name>, <article-title hwp:id="article-title-15">Precision enhancement of maldi-tof ms using high resolution peak detection and label-free alignment</article-title>, <source hwp:id="source-15">Proteomics</source> <volume>8</volume> (<issue>8</issue>) (<year>2008</year>) <fpage>1530</fpage>–<lpage>1538</lpage>.</citation></ref><ref id="c16" hwp:id="ref-16" hwp:rev-id="xref-ref-16-1 xref-ref-16-2"><label>16.</label><citation publication-type="journal" citation-type="journal" ref:id="292425v3.16" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-16"><string-name name-style="western" hwp:sortable="Barry J. A."><given-names>J. A.</given-names> <surname>Barry</surname></string-name>, <string-name name-style="western" hwp:sortable="Robichaud G."><given-names>G.</given-names> <surname>Robichaud</surname></string-name>, <string-name name-style="western" hwp:sortable="Muddiman D. C."><given-names>D. C.</given-names> <surname>Muddiman</surname></string-name>, <article-title hwp:id="article-title-16">Mass recalibration of ft-icr mass spectrometry imaging data using the average frequency shift of ambient ions</article-title>, <source hwp:id="source-16">Journal of the American Society for Mass Spectrometry</source> <volume>24</volume> (<issue>7</issue>) (<year>2013</year>) <fpage>1137</fpage>–<lpage>1145</lpage>.</citation></ref><ref id="c17" hwp:id="ref-17" hwp:rev-id="xref-ref-17-1"><label>17.</label><citation publication-type="journal" citation-type="journal" ref:id="292425v3.17" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-17"><string-name name-style="western" hwp:sortable="Psychogios N."><given-names>N.</given-names> <surname>Psychogios</surname></string-name>, <string-name name-style="western" hwp:sortable="Hau D. D."><given-names>D. D.</given-names> <surname>Hau</surname></string-name>, <string-name name-style="western" hwp:sortable="Peng J."><given-names>J.</given-names> <surname>Peng</surname></string-name>, <string-name name-style="western" hwp:sortable="Guo A. C."><given-names>A. C.</given-names> <surname>Guo</surname></string-name>, <string-name name-style="western" hwp:sortable="Mandal R."><given-names>R.</given-names> <surname>Mandal</surname></string-name>, <string-name name-style="western" hwp:sortable="Bouatra S."><given-names>S.</given-names> <surname>Bouatra</surname></string-name>, <string-name name-style="western" hwp:sortable="Sinelnikov I."><given-names>I.</given-names> <surname>Sinelnikov</surname></string-name>, <string-name name-style="western" hwp:sortable="Krishnamurthy R."><given-names>R.</given-names> <surname>Krishnamurthy</surname></string-name>, <string-name name-style="western" hwp:sortable="Eisner R."><given-names>R.</given-names> <surname>Eisner</surname></string-name>, <string-name name-style="western" hwp:sortable="Gautam B."><given-names>B.</given-names> <surname>Gautam</surname></string-name>, <etal>et al.</etal>, <article-title hwp:id="article-title-17">The human serum metabolome</article-title>, <source hwp:id="source-17">PloS one</source> <volume>6</volume> (<issue>2</issue>) (<year>2011</year>) <fpage>e16957</fpage>.</citation></ref><ref id="c18" hwp:id="ref-18" hwp:rev-id="xref-ref-18-1"><label>18.</label><citation publication-type="journal" citation-type="journal" ref:id="292425v3.18" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-18"><string-name name-style="western" hwp:sortable="Bouatra S."><given-names>S.</given-names> <surname>Bouatra</surname></string-name>, <string-name name-style="western" hwp:sortable="Aziat F."><given-names>F.</given-names> <surname>Aziat</surname></string-name>, <string-name name-style="western" hwp:sortable="Mandal R."><given-names>R.</given-names> <surname>Mandal</surname></string-name>, <string-name name-style="western" hwp:sortable="Guo A. C."><given-names>A. C.</given-names> <surname>Guo</surname></string-name>, <string-name name-style="western" hwp:sortable="Wilson M. R."><given-names>M. R.</given-names> <surname>Wilson</surname></string-name>, <string-name name-style="western" hwp:sortable="Knox C."><given-names>C.</given-names> <surname>Knox</surname></string-name>, <string-name name-style="western" hwp:sortable="Bjorndahl T. C."><given-names>T. C.</given-names> <surname>Bjorndahl</surname></string-name>, <string-name name-style="western" hwp:sortable="Krishnamurthy R."><given-names>R.</given-names> <surname>Krishnamurthy</surname></string-name>, <string-name name-style="western" hwp:sortable="Saleem F."><given-names>F.</given-names> <surname>Saleem</surname></string-name>, <string-name name-style="western" hwp:sortable="Liu P."><given-names>P.</given-names> <surname>Liu</surname></string-name>, <etal>et al.</etal>, <article-title hwp:id="article-title-18">The human urine metabolome</article-title>, <source hwp:id="source-18">PloS one</source> <volume>8</volume> (<issue>9</issue>) (<year>2013</year>) <fpage>e73076</fpage>.</citation></ref><ref id="c19" hwp:id="ref-19" hwp:rev-id="xref-ref-19-1"><label>19.</label><citation publication-type="book" citation-type="book" ref:id="292425v3.19" ref:linkable="no" ref:use-reference-as-is="yes" hwp:id="citation-19"><string-name name-style="western" hwp:sortable="Freund Y."><given-names>Y.</given-names> <surname>Freund</surname></string-name>, <string-name name-style="western" hwp:sortable="Schapire R. E."><given-names>R. E.</given-names> <surname>Schapire</surname></string-name>, <chapter-title>A desicion-theoretic generalization of on-line learning and an application to boosting</chapter-title>, in: <source hwp:id="source-19">European conference on computational learning theory</source>, <publisher-name>Springer</publisher-name>, <year>1995</year>, pp. <fpage>23</fpage>–<lpage>37</lpage>.</citation></ref><ref id="c20" hwp:id="ref-20" hwp:rev-id="xref-ref-20-1"><label>20.</label><citation publication-type="book" citation-type="book" ref:id="292425v3.20" ref:linkable="no" ref:use-reference-as-is="yes" hwp:id="citation-20"><string-name name-style="western" hwp:sortable="Breiman L."><given-names>L.</given-names> <surname>Breiman</surname></string-name>, <string-name name-style="western" hwp:sortable="Friedman J."><given-names>J.</given-names> <surname>Friedman</surname></string-name>, <string-name name-style="western" hwp:sortable="Olshen R."><given-names>R.</given-names> <surname>Olshen</surname></string-name>, <string-name name-style="western" hwp:sortable="Stone C."><given-names>C.</given-names> <surname>Stone</surname></string-name>, <source hwp:id="source-20">Classification and Regression Trees</source>, <publisher-name>Wadsworth and Brooks</publisher-name>, <publisher-loc>Monterey, CA</publisher-loc>, <year>1984</year>, new edition [?]?</citation></ref><ref id="c21" hwp:id="ref-21" hwp:rev-id="xref-ref-21-1"><label>21.</label><citation publication-type="journal" citation-type="journal" ref:id="292425v3.21" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-21"><string-name name-style="western" hwp:sortable="Marchand M."><given-names>M.</given-names> <surname>Marchand</surname></string-name>, <string-name name-style="western" hwp:sortable="Shawe-Taylor J."><given-names>J.</given-names> <surname>Shawe-Taylor</surname></string-name>, <article-title hwp:id="article-title-19">The set covering machine</article-title>, <source hwp:id="source-21">Journal of Machine Learning Research</source> <volume>3</volume> (<month>Dec</month>) (<year>2002</year>) <fpage>723</fpage>–<lpage>746</lpage>.</citation></ref><ref id="c22" hwp:id="ref-22" hwp:rev-id="xref-ref-22-1"><label>22.</label><citation publication-type="journal" citation-type="journal" ref:id="292425v3.22" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-22"><string-name name-style="western" hwp:sortable="Cortes C."><given-names>C.</given-names> <surname>Cortes</surname></string-name>, <string-name name-style="western" hwp:sortable="Vapnik V."><given-names>V.</given-names> <surname>Vapnik</surname></string-name>, <article-title hwp:id="article-title-20">Support-vector networks</article-title>, <source hwp:id="source-22">Machine learning</source> <volume>20</volume> (<issue>3</issue>) (<year>1995</year>) <fpage>273</fpage>–<lpage>297</lpage>.</citation></ref><ref id="c23" hwp:id="ref-23" hwp:rev-id="xref-ref-23-1"><label>23.</label><citation publication-type="journal" citation-type="journal" ref:id="292425v3.23" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-23"><string-name name-style="western" hwp:sortable="Pedregosa F."><given-names>F.</given-names> <surname>Pedregosa</surname></string-name>, <string-name name-style="western" hwp:sortable="Varoquaux G."><given-names>G.</given-names> <surname>Varoquaux</surname></string-name>, <string-name name-style="western" hwp:sortable="Gramfort A."><given-names>A.</given-names> <surname>Gramfort</surname></string-name>, <string-name name-style="western" hwp:sortable="Michel V."><given-names>V.</given-names> <surname>Michel</surname></string-name>, <string-name name-style="western" hwp:sortable="Thirion B."><given-names>B.</given-names> <surname>Thirion</surname></string-name>, <string-name name-style="western" hwp:sortable="Grisel O."><given-names>O.</given-names> <surname>Grisel</surname></string-name>, <string-name name-style="western" hwp:sortable="Blondel M."><given-names>M.</given-names> <surname>Blondel</surname></string-name>, <string-name name-style="western" hwp:sortable="Prettenhofer P."><given-names>P.</given-names> <surname>Prettenhofer</surname></string-name>, <string-name name-style="western" hwp:sortable="Weiss R."><given-names>R.</given-names> <surname>Weiss</surname></string-name>, <string-name name-style="western" hwp:sortable="Dubourg V."><given-names>V.</given-names> <surname>Dubourg</surname></string-name>, <string-name name-style="western" hwp:sortable="Vanderplas J."><given-names>J.</given-names> <surname>Vanderplas</surname></string-name>, <string-name name-style="western" hwp:sortable="Passos A."><given-names>A.</given-names> <surname>Passos</surname></string-name>, <string-name name-style="western" hwp:sortable="Cournapeau D."><given-names>D.</given-names> <surname>Cournapeau</surname></string-name>, <string-name name-style="western" hwp:sortable="Brucher M."><given-names>M.</given-names> <surname>Brucher</surname></string-name>, <string-name name-style="western" hwp:sortable="Perrot M."><given-names>M.</given-names> <surname>Perrot</surname></string-name>, <string-name name-style="western" hwp:sortable="Duchesnay E."><given-names>E.</given-names> <surname>Duchesnay</surname></string-name>, <article-title hwp:id="article-title-21">Scikit-learn: Machine learning in Python</article-title>, <source hwp:id="source-23">Journal of Machine Learning Research</source> <volume>12</volume> (<year>2011</year>) <fpage>2825</fpage>–<lpage>2830</lpage>.</citation></ref><ref id="c24" hwp:id="ref-24" hwp:rev-id="xref-ref-24-1"><label>24.</label><citation publication-type="book" citation-type="book" ref:id="292425v3.24" ref:linkable="no" ref:use-reference-as-is="yes" hwp:id="citation-24"><string-name name-style="western" hwp:sortable="Friedman J."><given-names>J.</given-names> <surname>Friedman</surname></string-name>, <string-name name-style="western" hwp:sortable="Hastie T."><given-names>T.</given-names> <surname>Hastie</surname></string-name>, <string-name name-style="western" hwp:sortable="Tibshirani R."><given-names>R.</given-names> <surname>Tibshirani</surname></string-name>, <chapter-title>The elements of statistical learning</chapter-title>, Vol. <volume>1</volume>, <source hwp:id="source-24">Springer series in statistics</source> <publisher-loc>New York</publisher-loc>, <year>2001</year>.</citation></ref><ref id="c25" hwp:id="ref-25" hwp:rev-id="xref-ref-25-1"><label>25.</label><citation publication-type="book" citation-type="book" ref:id="292425v3.25" ref:linkable="no" ref:use-reference-as-is="yes" hwp:id="citation-25"><string-name name-style="western" hwp:sortable="Gammerman A."><given-names>A.</given-names> <surname>Gammerman</surname></string-name>, <string-name name-style="western" hwp:sortable="Vovk V."><given-names>V.</given-names> <surname>Vovk</surname></string-name>, <string-name name-style="western" hwp:sortable="Vapnik V."><given-names>V.</given-names> <surname>Vapnik</surname></string-name>, <chapter-title>Learning by transduction</chapter-title>, in: <source hwp:id="source-25">Proceedings of the Fourteenth conference on Uncertainty in artificial intelligence</source>, <publisher-name>Morgan Kaufmann Publishers Inc</publisher-name>., <year>1998</year>, pp. <fpage>148</fpage>–<lpage>155</lpage>.</citation></ref><ref id="c26" hwp:id="ref-26" hwp:rev-id="xref-ref-26-1"><label>26.</label><citation publication-type="journal" citation-type="journal" ref:id="292425v3.26" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-26"><string-name name-style="western" hwp:sortable="Nordström A."><given-names>A.</given-names> <surname>Nordström</surname></string-name>, <string-name name-style="western" hwp:sortable="O’Maille G."><given-names>G.</given-names> <surname>O’Maille</surname></string-name>, <string-name name-style="western" hwp:sortable="Qin C."><given-names>C.</given-names> <surname>Qin</surname></string-name>, <string-name name-style="western" hwp:sortable="Siuzdak G."><given-names>G.</given-names> <surname>Siuzdak</surname></string-name>, <article-title hwp:id="article-title-22">Nonlinear data alignment for uplc- ms and hplc- ms based metabolomics: quantitative analysis of endogenous and exogenous metabolites in human serum</article-title>, <source hwp:id="source-26">Analytical chemistry</source> <volume>78</volume> (<issue>10</issue>) (<year>2006</year>) <fpage>3289</fpage>–<lpage>3295</lpage>.</citation></ref></ref-list><fn-group hwp:id="fn-group-1"><fn id="fn1" hwp:id="fn-3" hwp:rev-id="xref-fn-3-1"><label>1</label><p hwp:id="p-112">We refer here to the well-known running times (available from any introductory textbook on data structures and algorithms) for heap construction, removal of its top element, and insertion of a new element.</p></fn><fn id="fn2" hwp:id="fn-4" hwp:rev-id="xref-fn-4-1"><label>2</label><p hwp:id="p-113">This may appear to be a strategy a bit too complicated than necessary in view of the fact that the largest (and smallest) such sub-sequence must contain exactly <italic toggle="yes">m</italic> peaks to be a valid VLM. However, we will see below that a significant advantage of using the proposed strategy is the fact that the same algorithm, modulo some very small and trivial modification, can also be used to detect the alignment points of &#x01d4ae;.</p></fn><fn id="fn3" hwp:id="fn-5" hwp:rev-id="xref-fn-5-1"><label>3</label><p hwp:id="p-114">Therefore, we recommend removing all these peaks from <italic toggle="yes">S</italic> to perform statistical analyses or machine learning experiments.</p></fn></fn-group></back></article>
