<article article-type="article" specific-use="production" xml:lang="en" xmlns:hw="org.highwire.hpp" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ali="http://www.niso.org/schemas/ali/1.0/" xmlns:ref="http://schema.highwire.org/Reference" xmlns:hwp="http://schema.highwire.org/Journal" xmlns:l="http://schema.highwire.org/Linking" xmlns:r="http://schema.highwire.org/Revision" xmlns:x="http://www.w3.org/1999/xhtml" xmlns:app="http://www.w3.org/2007/app" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:nlm="http://schema.highwire.org/NLM/Journal" xmlns:a="http://www.w3.org/2005/Atom" xmlns:c="http://schema.highwire.org/Compound" xmlns:hpp="http://schema.highwire.org/Publishing"><front><journal-meta><journal-id journal-id-type="hwp">biorxiv</journal-id><journal-id journal-id-type="publisher-id">BIORXIV</journal-id><journal-title>bioRxiv</journal-title><abbrev-journal-title abbrev-type="publisher">bioRxiv</abbrev-journal-title><publisher><publisher-name>Cold Spring Harbor Laboratory</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="doi">10.1101/101501</article-id><article-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1</article-id><article-id pub-id-type="other" hwp:sub-type="pisa-master">biorxiv;101501</article-id><article-id pub-id-type="other" hwp:sub-type="slug">101501</article-id><article-id pub-id-type="other" hwp:sub-type="tag">101501</article-id><article-version>1.1</article-version><article-categories><subj-group subj-group-type="author-type"><subject>Regular Article</subject></subj-group><subj-group subj-group-type="heading"><subject>New Results</subject></subj-group><subj-group subj-group-type="hwp-journal-coll" hwp:journal-coll-id="Bioinformatics" hwp:journal="biorxiv"><subject>Bioinformatics</subject></subj-group></article-categories><title-group><article-title hwp:id="article-title-1">A Flow Procedure for the Linearization of Genome Sequence Graphs</article-title></title-group><author-notes hwp:id="author-notes-1"><fn id="n1" hwp:id="fn-1"><p hwp:id="p-1"><email hwp:id="email-1">dmitrii.miagkov@epam.com</email></p></fn></author-notes><contrib-group hwp:id="contrib-group-1"><contrib contrib-type="author" hwp:id="contrib-1"><name name-style="western" hwp:sortable="Haussler David"><surname>Haussler</surname><given-names>David</given-names></name><xref ref-type="aff" rid="a1" hwp:id="xref-aff-1-1" hwp:rel-id="aff-1">1</xref></contrib><contrib contrib-type="author" hwp:id="contrib-2"><name name-style="western" hwp:sortable="Smuga-Otto Maciej"><surname>Smuga-Otto</surname><given-names>Maciej</given-names></name><xref ref-type="aff" rid="a1" hwp:id="xref-aff-1-2" hwp:rel-id="aff-1">1</xref></contrib><contrib contrib-type="author" hwp:id="contrib-3"><name name-style="western" hwp:sortable="Paten Benedict"><surname>Paten</surname><given-names>Benedict</given-names></name><xref ref-type="aff" rid="a1" hwp:id="xref-aff-1-3" hwp:rel-id="aff-1">1</xref></contrib><contrib contrib-type="author" hwp:id="contrib-4"><name name-style="western" hwp:sortable="Novak Adam M"><surname>Novak</surname><given-names>Adam M</given-names></name><xref ref-type="aff" rid="a1" hwp:id="xref-aff-1-4" hwp:rel-id="aff-1">1</xref></contrib><contrib contrib-type="author" hwp:id="contrib-5"><name name-style="western" hwp:sortable="Nikitin Sergei"><surname>Nikitin</surname><given-names>Sergei</given-names></name><xref ref-type="aff" rid="a2" hwp:id="xref-aff-2-1" hwp:rel-id="aff-2">2</xref></contrib><contrib contrib-type="author" hwp:id="contrib-6"><name name-style="western" hwp:sortable="Zueva Maria"><surname>Zueva</surname><given-names>Maria</given-names></name><xref ref-type="aff" rid="a2" hwp:id="xref-aff-2-2" hwp:rel-id="aff-2">2</xref></contrib><contrib contrib-type="author" hwp:id="contrib-7"><name name-style="western" hwp:sortable="Miagkov Dmitrii"><surname>Miagkov</surname><given-names>Dmitrii</given-names></name><xref ref-type="aff" rid="a2" hwp:id="xref-aff-2-3" hwp:rel-id="aff-2">2</xref></contrib><aff id="a1" hwp:id="aff-1" hwp:rev-id="xref-aff-1-1 xref-aff-1-2 xref-aff-1-3 xref-aff-1-4"><label>1</label><institution hwp:id="institution-1">UC Santa Cruz Genomics Institute, University of California</institution>, Santa Cruz, CA, <country>USA</country></aff><aff id="a2" hwp:id="aff-2" hwp:rev-id="xref-aff-2-1 xref-aff-2-2 xref-aff-2-3"><label>2</label><institution hwp:id="institution-2">EPAM Systems, Inc.</institution>, Newtown, PA, <country>USA</country></aff></contrib-group><pub-date pub-type="epub-original" hwp:start="2017"><year>2017</year></pub-date><pub-date pub-type="hwp-created" hwp:start="2017-01-18T20:57:11-08:00">
    <day>18</day><month>1</month><year>2017</year>
  </pub-date><pub-date pub-type="hwp-received" hwp:start="2017-01-18T20:57:11-08:00">
    <day>18</day><month>1</month><year>2017</year>
  </pub-date><pub-date pub-type="epub" hwp:start="2017-01-18T21:25:15-08:00">
    <day>18</day><month>1</month><year>2017</year>
  </pub-date><pub-date pub-type="epub-version" hwp:start="2017-01-18T21:25:15-08:00">
    <day>18</day><month>1</month><year>2017</year>
  </pub-date><elocation-id>101501</elocation-id><history hwp:id="history-1">
<date date-type="received" hwp:start="2017-01-18"><day>18</day><month>1</month><year>2017</year></date>
<date date-type="accepted" hwp:start="2017-01-18"><day>18</day><month>1</month><year>2017</year></date>
</history><permissions><copyright-statement hwp:id="copyright-statement-1">© 2017, Posted by Cold Spring Harbor Laboratory</copyright-statement><copyright-year>2017</copyright-year><license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by/4.0/" hwp:id="license-1"><p hwp:id="p-2">This pre-print is available under a Creative Commons License (Attribution 4.0 International), CC BY 4.0, as described at <ext-link l:rel="related" l:ref-type="uri" l:ref="http://creativecommons.org/licenses/by/4.0/" ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/" hwp:id="ext-link-1">http://creativecommons.org/licenses/by/4.0/</ext-link></p></license></permissions><self-uri xlink:href="101501.pdf" content-type="pdf" xlink:role="full-text"/><self-uri l:ref="forthcoming:yes" c:role="http://schema.highwire.org/variant/abstract" xlink:role="abstract" content-type="xhtml+xml" hwp:variant="yes"/><self-uri l:ref="forthcoming:yes" c:role="http://schema.highwire.org/variant/full-text" xlink:href="file:/content/biorxiv/vol0/issue2019/pdf/101501v1.pdf" hwp:variant="yes" content-type="pdf" xlink:role="full-text"/><self-uri l:ref="forthcoming:yes" c:role="http://schema.highwire.org/variant/full-text" xlink:role="full-text" content-type="xhtml+xml" hwp:variant="yes"/><self-uri l:ref="forthcoming:yes" c:role="http://schema.highwire.org/variant/source" xlink:role="source" content-type="xml" xlink:show="none" hwp:variant="yes"/><self-uri l:ref="forthcoming:yes" c:role="http://schema.highwire.org/variant/original" xlink:role="original" content-type="xml" xlink:show="none" hwp:variant="yes" xlink:href="101501.xml"/><self-uri content-type="abstract" xlink:href="file:/content/biorxiv/vol0/issue2019/abstracts/101501v1/101501v1.htslp"/><self-uri content-type="fulltext" xlink:href="file:/content/biorxiv/vol0/issue2019/fulltext/101501v1/101501v1.htslp"/><abstract hwp:id="abstract-1"><label>1</label><title hwp:id="title-1">Abstract</title><p hwp:id="p-3">Efforts to incorporate human genetic variation into the reference human genome have converged on the idea of a graph representation of genetic variation within a species, a genome sequence graph. A sequence graph represents a set of individual haploid reference genomes as paths in a single graph. When that set of reference genomes is sufficiently diverse, the sequence graph implicitly contains all frequent human genetic variations, including translocations, inversions, deletions, and insertions.</p><p hwp:id="p-4">In representing a set of genomes as a sequence graph one encounters certain challenges. One of the most important is the problem of graph linearization, essential both for efficiency of storage and access, as well as for natural graph visualization and compatibility with other tools. The goal of graph linearization is to order nodes of the graph in such a way that operations such as access, traversal and visualization are as efficient and effective as possible.</p><p hwp:id="p-5">A new algorithm for the linearization of sequence graphs, called the flow procedure, is proposed in this paper. Comparative experimental evaluation of the flow procedure against other algorithms shows that it outperforms its rivals in the metrics most relevant to sequence graphs.</p></abstract><kwd-group kwd-group-type="author" hwp:id="kwd-group-1"><label>1.1</label><title hwp:id="title-2">Keywords</title><kwd hwp:id="kwd-1">sequence graph</kwd><kwd hwp:id="kwd-2">linearization</kwd><kwd hwp:id="kwd-3">flow procedure</kwd><kwd hwp:id="kwd-4">feedback arcs</kwd><kwd hwp:id="kwd-5">cut width</kwd><kwd hwp:id="kwd-6">backbone</kwd><kwd hwp:id="kwd-7">grooming</kwd></kwd-group><counts><page-count count="22"/></counts></article-meta></front><body><sec id="s1" hwp:id="sec-1"><label>2</label><title hwp:id="title-3">Motivation</title><p hwp:id="p-6">The current human reference genome consists essentially of a single representative of each of the human chromosomes. In essence, an arbitrary person’s genome is chosen to represent all of humanity. This leads to loss of information and bias. Efforts to incorporate human genetic variation into the reference human genome have converged on the idea of a graph representation of genetic variation within a species, a genome sequence graph [<xref ref-type="bibr" rid="c1" hwp:id="xref-ref-1-1" hwp:rel-id="ref-1">1</xref>].</p><p hwp:id="p-7">In its mathematically most simple form, each node of a sequence graph contains a single DNA base that occurs at an orthologous locus in one or more of the haploid genomes represented in the graph. Each arc represents an adjacency (chemically, a covalent bond) that occurs between consecutive instances of bases in those genomes. Excluding reversing joins (see below) each arc is directed according to the default strand direction of the DNA sequence used to build the graph, connecting the 3’ side of the previous base (the tail of the edge) with the 5’ side of the next base (the head of the edge). At points where the individual genomes differ to the right (i.e., 3’, downstream) of an orthologous base, the node representing that base will have two or more outgoing arcs. For example, the graph in <xref rid="fig2" ref-type="fig" hwp:id="xref-fig-2-1" hwp:rel-id="F2">Figure 2</xref> was built from the DNA strands <italic toggle="yes">CATCGCT</italic>, <italic toggle="yes">CATCGT, CAGCGAT</italic> and <italic toggle="yes">CATCGAGAGAGCT</italic> aligned at orthologous bases as shown in <xref rid="fig1" ref-type="fig" hwp:id="xref-fig-1-1" hwp:rel-id="F1">Figure 1</xref>.</p><fig id="fig1" position="float" orientation="portrait" fig-type="figure" hwp:id="F1" hwp:rev-id="xref-fig-1-1 xref-fig-1-2"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/FIG1</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F1</object-id><object-id pub-id-type="publisher-id">fig1</object-id><label>Figure 1.</label><caption hwp:id="caption-1"><p hwp:id="p-8">Alignment of CATCGCT, CAGCGAT, CATCGAGAGAGCT DNA strands.</p></caption><graphic xlink:href="101501_fig1" position="float" orientation="portrait" hwp:id="graphic-1"/></fig><fig id="fig2" position="float" orientation="portrait" fig-type="figure" hwp:id="F2" hwp:rev-id="xref-fig-2-1 xref-fig-2-2"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/FIG2</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F2</object-id><object-id pub-id-type="publisher-id">fig2</object-id><label>Figure 2.</label><caption hwp:id="caption-2"><p hwp:id="p-9">An example of a sequence graph reflecting SNP (T/G), tandem duplication GA -&gt; GAGAGA, and deletion/SNP (A/C/-).</p></caption><graphic xlink:href="101501_fig2" position="float" orientation="portrait" hwp:id="graphic-2"/></fig><p hwp:id="p-10">Representing a genome as a graph requires building a number of tools to work with it efficiently. In particular, one needs to linearize the graph, that is order the nodes from left to right in a straight line. Linearization facilitates visual perception of a graph, allows software to index the nodes in a familiar manner, and imposes natural order of bases useful in storage, search and analysis, for example enabling traversal from left to right with minimum feedback runs. <xref rid="fig3" ref-type="fig" hwp:id="xref-fig-3-1" hwp:rel-id="F3">Figures 3</xref> and <xref rid="fig4" ref-type="fig" hwp:id="xref-fig-4-1" hwp:rel-id="F4">4</xref> show examples of a linearized graph and individual genomes in it. Here we have also added a new feature to the graphs in the form of <bold>arc weights</bold>. An arc weight is used to signify the importance of an arc in typical applications running on the graph. Normally we set the arc weight to the number of times that the arc is traversed in the reference genomes used to build the graph, under the assumption that arcs used frequently in the reference genomes 3 will also be used frequently in the applications of the sequence graph built from them. Some reference genomes may be weighted more than others.</p><fig id="fig3" position="float" orientation="portrait" fig-type="figure" hwp:id="F3" hwp:rev-id="xref-fig-3-1 xref-fig-3-2"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/FIG3</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F3</object-id><object-id pub-id-type="publisher-id">fig3</object-id><label>Figure 3.</label><caption hwp:id="caption-3"><p hwp:id="p-11">An example of a linearized sequence graph with weighted arcs. The arc in red is directed from the right to the left and is called feedback arc.</p></caption><graphic xlink:href="101501_fig3" position="float" orientation="portrait" hwp:id="graphic-3"/></fig><fig id="fig4" position="float" orientation="portrait" fig-type="figure" hwp:id="F4" hwp:rev-id="xref-fig-4-1"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/FIG4</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F4</object-id><object-id pub-id-type="publisher-id">fig4</object-id><label>Figure 4.</label><caption hwp:id="caption-4"><p hwp:id="p-12">Three individual genomes as paths in the linearized graph, shown in green. The first and second genomes are ATCAGGCA and ATCAGACTCA, respectively. The third one is AAGACTAGACTCA where the arc between T and A is a feedback arc.</p></caption><graphic xlink:href="101501_fig4" position="float" orientation="portrait" hwp:id="graphic-4"/></fig></sec><sec id="s2" hwp:id="sec-2"><label>3</label><title hwp:id="title-4">Problem Statement</title><p hwp:id="p-13">A linearization of a sequence graph aims to make the total weight of all feedback arcs, called the <bold>weighted feedback</bold> (see <xref rid="fig3" ref-type="fig" hwp:id="xref-fig-3-2" hwp:rel-id="F3">Figure 3</xref>), small, along with the “width” (number of arcs) crossing any vertical line in the layout (called a “cut”, see <xref rid="fig5" ref-type="fig" hwp:id="xref-fig-5-1" hwp:rel-id="F5">Figure 5</xref>). Unnecessary feedback arcs make many types of genetic analysis more inefficient, as these typically proceed left-to-right on a conventional reference genome. An arc crossing a cut is considered to be part of an allele spanning that cut (see [<xref ref-type="bibr" rid="c2" hwp:id="xref-ref-2-1" hwp:rel-id="ref-2">2</xref>]), so a graph with smaller cut width at a cut has fewer alleles at that cut. The mean of the cut width over all cuts in the graph is called the <bold>average cut width</bold>.</p><fig id="fig5" position="float" orientation="portrait" fig-type="figure" hwp:id="F5" hwp:rev-id="xref-fig-5-1"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/FIG5</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F5</object-id><object-id pub-id-type="publisher-id">fig5</object-id><label>Figure 5.</label><caption hwp:id="caption-5"><p hwp:id="p-14">Examples of cuts and cut widths. Three cuts are shown with green vertical lines. Their widths are, from left to right, 3, 4, and 2 respectively.</p></caption><graphic xlink:href="101501_fig5" position="float" orientation="portrait" hwp:id="graphic-5"/></fig><p hwp:id="p-15">In light of their importance for genetic analysis, we will evaluate a linearization based on its average cut width and either the weighted feedback or the number of feedback arcs it contains.</p><p hwp:id="p-16">Unfortunately, the problems of minimizing weighted feedback, and of minimizing the average cut width, are each separately difficult. The simpler problem of minimizing the number of feedback arcs is known in literature as the <italic toggle="yes">feedback arc set problem</italic>, or FAS for short [<xref ref-type="bibr" rid="c3" hwp:id="xref-ref-3-1" hwp:rel-id="ref-3">3</xref>]. This is an NP-hard problem [<xref ref-type="bibr" rid="c4" hwp:id="xref-ref-4-1" hwp:rel-id="ref-4">4</xref>], but there are a number of various heuristic approaches to approximating a solution to it [<xref ref-type="bibr" rid="c5" hwp:id="xref-ref-5-1" hwp:rel-id="ref-5">5</xref>]. The problem of minimizing the average cut width [<xref ref-type="bibr" rid="c6" hwp:id="xref-ref-6-1" hwp:rel-id="ref-6">6</xref>] is also known to be NP-hard. A good heuristic [<xref ref-type="bibr" rid="c7" hwp:id="xref-ref-7-1" hwp:rel-id="ref-7">7</xref>] is necessary for good results. In our case, starting our procedure with the “primary path” taken by the reference genome is a natural choice. This is the first time to our knowledge that a heuristic algorithm to minimize both metrics at the same time has been proposed.</p></sec><sec id="s3" hwp:id="sec-3"><label>4</label><title hwp:id="title-5">Algorithm Description</title><p hwp:id="p-17">We propose here a simple heuristic divide-and-conquer approach to linearly order the bases of a graph that tries to achieve either small weighted feedback (or small number of feedback arcs) and small average cut width. The key algorithmic tool is max-flow/min-cut in a directed graph [<xref ref-type="bibr" rid="c8" hwp:id="xref-ref-8-1" hwp:rel-id="ref-8">8</xref>], so we call it the <bold>flow procedure</bold>. Prior to applying the flow procedure, the sequence graph is “groomed” as described at the end of this section.</p><sec id="s3a" hwp:id="sec-4"><label>4.1</label><title hwp:id="title-6">First Step. Find the Backbone</title><p hwp:id="p-18">Following grooming, the flow procedure starts with a connected graph with directed arcs and a designated linear ordering of a subset of the bases called the <bold>backbone</bold>. Arcs leading from the backbone to nodes not on the backbone are called <bold>out-arcs</bold>, and arcs directed into the backbone from nodes not on the backbone are called <bold>in-arcs</bold>. Grooming guarantees such the first base of the backbone has no in-arcs and the last has no out-arcs. Extra dummy bases are added at either end if necessary. Normally the initial backbone is a biologically determined primary path of the graph, e.g. from a selected haploid reference genome in the set of genomes used to build the graph, perhaps the existing haploid reference human genome. The flow procedure creates a backbone using its internal heuristics if none is given <italic toggle="yes">a priori.</italic> In linearizing the sequence graph by creating a total ordering of the bases, the relative order of the bases in backbone will not change. The rest of the bases in the graph will be inserted either between bases of the backbone, before the backbone, or after the backbone. Thus, any feedback arcs already in the backbone ordering, called <bold>initial feedback arcs</bold>, will remain as feedback arcs in the final ordering.</p><p hwp:id="p-19">Consider the graph depictured in <xref rid="fig6" ref-type="fig" hwp:id="xref-fig-6-1" hwp:rel-id="F6">Figure 6</xref>. The backbone is CGATC horizontally across the middle (highlighted by dark blue color). The three out-arcs of the backbone are shown with thick green arrows. The two in-arcs are shown with thick purple arrows. The weights are assumed to reflect usage, but we also assume the usage statistics may be partial. Hence the weight coming into a base does not always match the weight coming out.</p><fig id="fig6" position="float" orientation="portrait" fig-type="figure" hwp:id="F6" hwp:rev-id="xref-fig-6-1"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/FIG6</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F6</object-id><object-id pub-id-type="publisher-id">fig6</object-id><label>Figure 6.</label><caption hwp:id="caption-6"><p hwp:id="p-20">An initial directed graph with weights on the arcs.</p></caption><graphic xlink:href="101501_fig6" position="float" orientation="portrait" hwp:id="graphic-6"/></fig></sec><sec id="s3b" hwp:id="sec-5"><label>4.2</label><title hwp:id="title-7">Second Step. Add Source and Sink</title><p hwp:id="p-21">We set up a max flow/min cut network as follows. The nodes and arcs of the network are nodes and arcs of the graph. The capacity of the arc is its weight. In addition, there is a special source node and a special sink node. The network arcs for these are defined as follows: we let <italic toggle="yes">N</italic> be the maximum of the sum of the weights of the outgoing arcs for any node in the graph and we add an arc of capacity <italic toggle="yes">N</italic> + 1 from the source node to each base on the backbone that has an out-arc. Then each in-arc on the backbone is redirected to the sink node with no change in capacity.</p></sec><sec id="s3c" hwp:id="sec-6"><label>4.3</label><title hwp:id="title-8">Third Step. Determine the Minimum Cut and Delete It</title><p hwp:id="p-22">The maximum flow in our example is easily seen to be 3, and it maximizes the capacity of the two arcs that are cut by the green bars (<xref rid="fig7" ref-type="fig" hwp:id="xref-fig-7-1" hwp:rel-id="F7">Fig. 7</xref>). Therefore, these form a minimum cut. Since the capacities of the arcs connecting the source to the backbone are too high to be achieved by any flow, none of these are in the cut. Therefore, the cut must split the flow network into an <bold>out-component</bold> containing the source and its outgoing arcs, and an <bold>in-component</bold> containing the sink. In <xref rid="fig7" ref-type="fig" hwp:id="xref-fig-7-2" hwp:rel-id="F7">Figure 7</xref> the in-component consists of the uppermost nodes <italic toggle="yes">C, G, C</italic> and the sink, and the out-component is the remainder.</p><fig id="fig7" position="float" orientation="portrait" fig-type="figure" hwp:id="F7" hwp:rev-id="xref-fig-7-1 xref-fig-7-2"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/FIG7</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F7</object-id><object-id pub-id-type="publisher-id">fig7</object-id><label>Figure 7.</label><caption hwp:id="caption-7"><p hwp:id="p-23">The flow network corresponding to the above weighted graph and its designated backbone.</p></caption><graphic xlink:href="101501_fig7" position="float" orientation="portrait" hwp:id="graphic-7"/></fig><p hwp:id="p-24">We remove the cut arcs from the graph. Essentially, in doing this we decide to give up worrying about these arcs and try to minimize the weighted feedback and average cut width as if they were not there. Since capacity equals weight, by choosing a minimum capacity cut, we ignore the arcs that cost us the least in weight.</p><p hwp:id="p-25">Excluding any initial feedback arcs on the backbone itself, we classify all bases not on the backbone into a sequence of <bold>out-growths</bold> and <bold>in-growths</bold> as follows. Starting at the last base on the backbone that has an out-arc, we define its out-growth to be all bases reachable by a forward directed path from that base. Then we move backwards along the backbone, defining out-growths consisting of all the bases reachable by a forward directed path from the base on the backbone with an out-arc that were not already included in previously defined out-growths. We define in-growths in a similar fashion, moving forward from the start of the backbone and using backward-directed paths. <xref rid="fig8" ref-type="fig" hwp:id="xref-fig-8-1" hwp:rel-id="F8">Figure 8</xref> shows in-growth and out-growths for the example under consideration. There are two outgrowths, the first from the node G on the backbone (contains nodes G, G, C), and the second from its predecessor, the first node on the backbone (labeled “C”, contains nodes C, T, C, A). The dotted green arc is not a proper part of either outgrowth; it is discovered when exploring the outgrowth from C, and found to lead into the previous outgrowth found from G. The one in-growth enters the node A of backbone and contains nodes C, G, C, A, shown in purple.</p><fig id="fig8" position="float" orientation="portrait" fig-type="figure" hwp:id="F8" hwp:rev-id="xref-fig-8-1"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/FIG8</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F8</object-id><object-id pub-id-type="publisher-id">fig8</object-id><label>Figure 8.</label><caption hwp:id="caption-8"><p hwp:id="p-26">Out-growths (green) and in-growth (purple) of the graph.</p></caption><graphic xlink:href="101501_fig8" position="float" orientation="portrait" hwp:id="graphic-8"/></fig></sec><sec id="s3d" hwp:id="sec-7"><label>4.4</label><title hwp:id="title-9">Fourth Step. Repeat Procedure for In- and Out-growths</title><p hwp:id="p-27">Finally, we apply the entire procedure recursively to each out-growth and in-growth, using a heuristic that uses the backbone’s base as the first base for an out-growth or as the last base for an in-growth, respectively. When the recursive call completes, the bases from it are inserted into the backbone of the calling procedure in the specified order immediately following an out-growth or immediately preceding an in-growth, respectively. The final ordering for the example above is shown in <xref rid="fig9" ref-type="fig" hwp:id="xref-fig-9-1" hwp:rel-id="F9">Figure 9</xref>.</p><fig id="fig9" position="float" orientation="portrait" fig-type="figure" hwp:id="F9" hwp:rev-id="xref-fig-9-1"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/FIG9</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F9</object-id><object-id pub-id-type="publisher-id">fig9</object-id><label>Figure 9.</label><caption hwp:id="caption-9"><p hwp:id="p-28">The final sorted graph with the bases totally ordered.</p></caption><graphic xlink:href="101501_fig9" position="float" orientation="portrait" hwp:id="graphic-9"/></fig><p hwp:id="p-29">Normally the out-growths and in-growths together comprise the whole graph. However, if not, the entire procedure can just be repeated, each time using the linear order established from the previous cycle as a new backbone. Grooming a connected graph (see below) assures that these repetitions will eventually reach every node in the graph.</p><p hwp:id="p-30">It remains to specify a heuristic for determining the backbone when it is not explicitly given. When the first base of the backbone is given, we extend it into a path using a greedy algorithm: in each step, we add to the existing path the base with the highest forward directed arc weight, breaking ties arbitrarily, and we do so until no more bases can be added. A complementary procedure is run in reverse if we are instead given the last base of the backbone.</p></sec><sec id="s3e" hwp:id="sec-8"><label>4.5</label><title hwp:id="title-10">Grooming</title><p hwp:id="p-31">Finally, we explain the preprocessing step of grooming the graph. The base in each node in a sequence graph has two sides (3’ and 5’). The directed arcs we have been using are edges of the sequence graph that connect the 3’ side of one node to the 5’ side of another (possibly the same) node. The arcs are directed in the 3’ to 5’ side direction. There are also additional edges in a sequence graph that here we will refer to as <bold>reversing joins</bold>, which we have not discussed up until this point (see [<xref ref-type="bibr" rid="c1" hwp:id="xref-ref-1-2" hwp:rel-id="ref-1">1</xref>] and [<xref ref-type="bibr" rid="c9" hwp:id="xref-ref-9-1" hwp:rel-id="ref-9">9</xref>] for an introduction). A reversing join is an undirected edge connecting the 3’ sides of two nodes, or connecting the 5’ sides of two nodes. As a preprocessing step to the flow procedure, and all other heuristic algorithms we examine for linearization of a directed graph, we first eliminate as many of the reversing joins as possible by replacing the graph with an equivalent graph that has fewer reversing joins. Then if there are still reversing joins left we just ignore them. This way we are always working with graphs that only contain directed arcs. The process we use to minimize the number of reversing joins is called <bold>grooming</bold> (<xref rid="fig10" ref-type="fig" hwp:id="xref-fig-10-1" hwp:rel-id="F10">Figure 10</xref>).</p><fig id="fig10" position="float" orientation="portrait" fig-type="figure" hwp:id="F10" hwp:rev-id="xref-fig-10-1 xref-fig-10-2 xref-fig-10-3 xref-fig-10-4"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/FIG10</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F10</object-id><object-id pub-id-type="publisher-id">fig10</object-id><label>Figure 10.</label><caption hwp:id="caption-10"><p hwp:id="p-32">Grooming procedure. Reversing joins are shown in brown on the upper left. Bottom one shows the graph on the upper right as directed graph.</p></caption><graphic xlink:href="101501_fig10" position="float" orientation="portrait" hwp:id="graphic-10"/></fig><p hwp:id="p-33">Grooming works as follows. A given connected component (a set of nodes such that one can travel between any two nodes in it along the standard arcs, in both direction, and reversing joins) may fall apart if the reversing joins are removed. This indicates that some of reversing joins were unnecessary. Let one connected component be called the <bold>primary component</bold> (shown in dark blue in <xref rid="fig10" ref-type="fig" hwp:id="xref-fig-10-2" hwp:rel-id="F10">Figure 10</xref>), and the others be called the <bold>secondary components</bold> (shown in light blue in <xref rid="fig10" ref-type="fig" hwp:id="xref-fig-10-3" hwp:rel-id="F10">Figure 10</xref>). We obtain an isomorphic graph that will have fewer components after removal of reversing joins by simply <bold>reverse-complementing</bold> the secondary component, i.e., reverse-complementing every base in it and inverting the direction of the arcs between these secondary bases. The 3’ reversing joins connecting this secondary component to the main graph are replaced by directed arcs pointing into the secondary component, and the 5’ reversing joins are replaced by directed arcs back to the primary component. This has the effect of changing every 3’ side in the secondary component into a 5’ side, and vice versa. On the right side of <xref rid="fig10" ref-type="fig" hwp:id="xref-fig-10-4" hwp:rel-id="F10">Figure 10</xref> nodes and arcs which were changed during grooming are shown in red. By repeating this procedure on any connected sequence graph we eventually reach an isomorphic graph that has just one connected component even after removing the reversing joins.</p><p hwp:id="p-34">Since we will not be reducing the number of reversing joins further, and being undirected they cannot be considered feedback arcs, from here on, we will stop paying attention to the reversing joins and consider only graphs that are fully directed.</p></sec></sec><sec id="s4" hwp:id="sec-9" hwp:rev-id="xref-sec-9-1"><label>5</label><title hwp:id="title-11">Complexity Estimation</title><p hwp:id="p-35">The max flow/min cut sorting algorithm described above can be broken into four steps:
<list list-type="order" hwp:id="list-1"><list-item hwp:id="list-item-1"><p hwp:id="p-36">Find the backbone (if it is not given)</p></list-item><list-item hwp:id="list-item-2"><p hwp:id="p-37">Create the flow graph by adding the source and sink and connecting them to the graph</p></list-item><list-item hwp:id="list-item-3"><p hwp:id="p-38">Find the maximum flow and minimal cut and delete the minimal cut, using the Ford-Fulkerson algorithm</p></list-item><list-item hwp:id="list-item-4"><p hwp:id="p-39">Find the in-growth and out-growth and repeat steps 1 through 4 for them</p></list-item></list></p><p hwp:id="p-40">Let us consider the complexity of each step separately.</p><p hwp:id="p-41">In the preparation step, we perform a greedy depth-first search to find the backbone if it is not given (in practice we only find the backbone on recursive calls, as the whole graph’s backbone <italic toggle="yes">is</italic> given). We do not visit any arc more than once, so the time complexity is O(|A|), where A is the number of arcs.</p><p hwp:id="p-42">In creating the flow, we add 2 nodes to the graph (the source and sink) and draw several arcs from the source to those nodes in the backbone that have an outgoing arc, and also reroute the arcs going into the backbone to the sink. We do not examine any arc more than once, so the time complexity is O(|A|).</p><p hwp:id="p-43">The Ford-Fulkerson algorithm works in O(|A|*|max-flow|) [<xref ref-type="bibr" rid="c10" hwp:id="xref-ref-10-1" hwp:rel-id="ref-10">10</xref>]. In the worst case, |max-flow| ~ O(|A|), in which case the time complexity becomes O(|A|<sup>2</sup>).</p><p hwp:id="p-44">Every recursive call decreases the number of nodes in the graph, so the number of recursive calls is O(|V|).</p><p hwp:id="p-45">These estimations are shown in the table below.</p><p hwp:id="p-46">The final complexity estimate is thus <bold>O(|A|*|max-flow|) * |recursion depth|.</bold></p><p hwp:id="p-47">The best-case complexity (if the max flow is constant and there are a constant number of recursive calls) is O(|A|), again, assuming at least one arc per node. In the worst case, it is O((|A|<sup>2</sup>) * |V|) as the max flow may be proportional to |A| and the recursion depth proportional to |V|.</p><p hwp:id="p-48">The Ford-Fulkerson algorithm and the recursion contribute the most to the final algorithm’s complexity. Depth of recursion is not a problem in practice. However, the maximum flow will often be approximately O(|A|) due to how the flow is constructed: each variation increases it by creating a new path from the source to the sink. Because the flow becomes so large, the Ford-Fulkerson algorithm will work in quadratic time (O(|A|<sup>2</sup>)). Improvements to the algorithm that reduce the typical max flow so that it is polylogarithmic in |A| would improve its speed.</p></sec><sec id="s5" hwp:id="sec-10"><label>6</label><title hwp:id="title-12">Experimental Evaluation</title><sec id="s5a" hwp:id="sec-11"><label>6.1</label><title hwp:id="title-13">Data Modeling</title><p hwp:id="p-49">The flow procedure was tested on data that was artificially generated by taking a 37 kilobase piece of the GRCh38 assembly and adding artificial structural variations to it using the RSVSim [<xref ref-type="bibr" rid="c11" hwp:id="xref-ref-11-1" hwp:rel-id="ref-11">11</xref>] from Bioconductor. This package lets one simulate any given set of structural variations to a reference, producing a modified FASTA file. The positions of the variations were distributed uniformly, while their lengths were fixed. After fixing a specified set of variations, a series of FASTA files were created and passed on to a vg [<xref ref-type="bibr" rid="c12" hwp:id="xref-ref-12-1" hwp:rel-id="ref-12">12</xref>] tool, which generated the graph using a multiple sequence graph alignment algorithm.</p><p hwp:id="p-50">Four types of structural variation were simulated: insertions, deletions, duplications, and inversions. Tandem duplications were limited to one copy.</p><p hwp:id="p-51">Two different test data sets, each consisting of a series of graphs, were generated in this way. The first was created to investigate the effect of the overall amount of variation on the number of feedback arcs and the cut width achievable by each algorithm. This data set consisted of graphs each having equal numbers of all four kinds of variations (i.e., there were as many insertions as there were deletions, inversions and duplications), with only the total number of variations changing between graphs. The variations’ sizes are given in <xref rid="tbl2" ref-type="table" hwp:id="xref-table-wrap-1-1" hwp:rel-id="T1">Table 2.</xref></p><table-wrap id="tbl2" orientation="portrait" position="float" hwp:id="T1" hwp:rev-id="xref-table-wrap-1-1"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/TBL2</object-id><object-id pub-id-type="other" hwp:sub-type="slug">T1</object-id><object-id pub-id-type="publisher-id">tbl2</object-id><label>Table 2.</label><caption hwp:id="caption-11"><p hwp:id="p-52">The lengths of the variations in the testing data.</p></caption><graphic xlink:href="101501_tbl2" position="float" orientation="portrait" hwp:id="graphic-11"/></table-wrap><p hwp:id="p-53">The second set of graphs was created to investigate the relationship between the relative frequencies of each type of variation and the number of feedback arcs and the cut width achievable by each algorithm (Appendix B, <xref rid="tbl1" ref-type="table" hwp:id="xref-table-wrap-2-1" hwp:rel-id="T2">tables 1</xref>–<xref rid="tbl4" ref-type="table" hwp:id="xref-table-wrap-3-1" hwp:rel-id="T3">4</xref>).</p><table-wrap id="tbl1" orientation="portrait" position="float" hwp:id="T2" hwp:rev-id="xref-table-wrap-2-1"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/TBL1</object-id><object-id pub-id-type="other" hwp:sub-type="slug">T2</object-id><object-id pub-id-type="publisher-id">tbl1</object-id><label>Table 1.</label><caption hwp:id="caption-12"><p hwp:id="p-54">Complexity estimation of the flow procedure algorithm.</p></caption><graphic xlink:href="101501_tbl1" position="float" orientation="portrait" hwp:id="graphic-12"/></table-wrap><table-wrap id="tbl4" orientation="portrait" position="float" hwp:id="T3" hwp:rev-id="xref-table-wrap-3-1"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/TBL4</object-id><object-id pub-id-type="other" hwp:sub-type="slug">T3</object-id><object-id pub-id-type="publisher-id">tbl4</object-id><label>Table 4.</label><caption hwp:id="caption-13"><p hwp:id="p-55">The relationship between the number of feedback arcs and ACW, and the number of deletions.</p></caption><graphic xlink:href="101501_tbl4" position="float" orientation="portrait" hwp:id="graphic-13"/></table-wrap><p hwp:id="p-56">The third data set was created in order to test algorithm’s time performance. The graphs in this data set were created from scratch and have structure similar to those graphs above with doubling of the number of nodes from one to another.</p></sec><sec id="s5b" hwp:id="sec-12"><label>6.2</label><title hwp:id="title-14">Results and Discussion</title><p hwp:id="p-57">In order to comparatively analyze the quality and speed of our algorithm, we took Kahn’s well-known topological sorting algorithm [<xref ref-type="bibr" rid="c13" hwp:id="xref-ref-13-1" hwp:rel-id="ref-13">13</xref>], as well as Eades’ [<xref ref-type="bibr" rid="c14" hwp:id="xref-ref-14-1" hwp:rel-id="ref-14">14</xref>] modified version thereof that guarantees a low number of feedback arcs while still working in linear time. We were not able to find competitor for cut width minimization problem to measure against, because all the algorithms we have found are focused on exact solution of the problem, thus having high complexity (cubic and higher) and thus working only with graphs of 200 nodes or less. Note that neither Kahn’s nor Eades’ algorithm uses the backbone as a heuristic. All three algorithms were tested on the same data (see Appendix B and <xref ref-type="sec" rid="s4" hwp:id="xref-sec-9-1" hwp:rel-id="sec-9">Section 5.1</xref> for details on the modeling). Their outputs were compared on two metrics – the number of feedback arcs and the average cut width. Kahn’s algorithm, Eades’ algorithm, and flow procedure are all implemented in the vg tool [<xref ref-type="bibr" rid="c12" hwp:id="xref-ref-12-2" hwp:rel-id="ref-12">12</xref>].</p><p hwp:id="p-58"><xref rid="fig11" ref-type="fig" hwp:id="xref-fig-11-1" hwp:rel-id="F11">Figures 11</xref> and <xref rid="fig12" ref-type="fig" hwp:id="xref-fig-12-1" hwp:rel-id="F12">12</xref> depict the main quantitative outputs of the three algorithms, Kahn, Eades, and the flow procedure (FP), for the first set of testing data. The same results for the second set are given in Appendix B. From <xref rid="fig11" ref-type="fig" hwp:id="xref-fig-11-2" hwp:rel-id="F11">Figure 11</xref> it is fairly obvious that in terms of the number of feedback arcs, the FP algorithm vastly outperforms Kahn’s, doing only slightly worse than Eades’ algorithm. The difference between FP and Eades is much smaller than between FP and Kahn. It is clear from <xref rid="fig12" ref-type="fig" hwp:id="xref-fig-12-2" hwp:rel-id="F12">Figure 12</xref> that FP’s average cut width is an order of magnitude lower than that of Eades [<xref ref-type="bibr" rid="c14" hwp:id="xref-ref-14-2" hwp:rel-id="ref-14">14</xref>] or Kahn [<xref ref-type="bibr" rid="c13" hwp:id="xref-ref-13-2" hwp:rel-id="ref-13">13</xref>].</p><fig id="fig11" position="float" orientation="portrait" fig-type="figure" hwp:id="F11" hwp:rev-id="xref-fig-11-1 xref-fig-11-2"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/FIG11</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F11</object-id><object-id pub-id-type="publisher-id">fig11</object-id><label>Figure 11.</label><caption hwp:id="caption-14"><p hwp:id="p-59">The relationship between the number of feedback arcs and variations</p></caption><graphic xlink:href="101501_fig11" position="float" orientation="portrait" hwp:id="graphic-14"/></fig><fig id="fig12" position="float" orientation="portrait" fig-type="figure" hwp:id="F12" hwp:rev-id="xref-fig-12-1 xref-fig-12-2"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/FIG12</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F12</object-id><object-id pub-id-type="publisher-id">fig12</object-id><label>Figure 12.</label><caption hwp:id="caption-15"><p hwp:id="p-60">The relationship between the ACW and number of variations.</p></caption><graphic xlink:href="101501_fig12" position="float" orientation="portrait" hwp:id="graphic-15"/></fig><p hwp:id="p-61">To use the FP algorithm in practice, one must estimate the time it takes the algorithm to run on large amounts of data. In order to use the algorithm on large graphs in practice, we would split the graph into pieces using a graph decomposition scheme as described in [<xref ref-type="bibr" rid="c2" hwp:id="xref-ref-2-2" hwp:rel-id="ref-2">2</xref>]. In practice the time complexity of the FP is O(|A|<sup>2</sup>). On the other hand, both Kahn’s and Eades’ algorithms have complexity O(|A|+|V|), since they do not pass any node more than twice. The relationship between the number of nodes in the graph and the algorithms’ runtimes on our test data is shown in <xref rid="fig13" ref-type="fig" hwp:id="xref-fig-13-1" hwp:rel-id="F13">Figure 13</xref>.</p><fig id="fig13" position="float" orientation="portrait" fig-type="figure" hwp:id="F13" hwp:rev-id="xref-fig-13-1 xref-fig-13-2"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/FIG13</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F13</object-id><object-id pub-id-type="publisher-id">fig13</object-id><label>Figure 13.</label><caption hwp:id="caption-16"><p hwp:id="p-62">The relationship between the runtime and the number of arcs in the graph.</p></caption><graphic xlink:href="101501_fig13" position="float" orientation="portrait" hwp:id="graphic-16"/></fig><fig id="fig14" position="float" orientation="portrait" fig-type="figure" hwp:id="F14"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/FIG14</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F14</object-id><object-id pub-id-type="publisher-id">fig14</object-id><label>Figure 14.</label><caption hwp:id="caption-17"><p hwp:id="p-63">An example of a graph that requires a rerun.</p></caption><graphic xlink:href="101501_fig14" position="float" orientation="portrait" hwp:id="graphic-17"/></fig><fig id="fig15" position="float" orientation="portrait" fig-type="figure" hwp:id="F15"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/FIG15</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F15</object-id><object-id pub-id-type="publisher-id">fig15</object-id><label>Figure 15.</label><caption hwp:id="caption-18"><p hwp:id="p-64">An example of the in-growths and out-growths for a graph.</p></caption><graphic xlink:href="101501_fig15" position="float" orientation="portrait" hwp:id="graphic-18"/></fig><fig id="fig16" position="float" orientation="portrait" fig-type="figure" hwp:id="F16"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/FIG16</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F16</object-id><object-id pub-id-type="publisher-id">fig16</object-id><label>Figure 16.</label><caption hwp:id="caption-19"><p hwp:id="p-65">The relationship between the number of feedback arcs and the number of deletions.</p></caption><graphic xlink:href="101501_fig16" position="float" orientation="portrait" hwp:id="graphic-19"/></fig><fig id="fig17" position="float" orientation="portrait" fig-type="figure" hwp:id="F17"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/FIG17</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F17</object-id><object-id pub-id-type="publisher-id">fig17</object-id><label>Figure 17.</label><caption hwp:id="caption-20"><p hwp:id="p-66">The relationship between the ACW and the number of deletions.</p></caption><graphic xlink:href="101501_fig17" position="float" orientation="portrait" hwp:id="graphic-20"/></fig><fig id="fig18" position="float" orientation="portrait" fig-type="figure" hwp:id="F18"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/FIG18</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F18</object-id><object-id pub-id-type="publisher-id">fig18</object-id><label>Figure 18.</label><caption hwp:id="caption-21"><p hwp:id="p-67">The relationship between the number of feedback arcs and the number of duplications.</p></caption><graphic xlink:href="101501_fig18" position="float" orientation="portrait" hwp:id="graphic-21"/></fig><fig id="fig19" position="float" orientation="portrait" fig-type="figure" hwp:id="F19"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/FIG19</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F19</object-id><object-id pub-id-type="publisher-id">fig19</object-id><label>Figure 19.</label><caption hwp:id="caption-22"><p hwp:id="p-68">The relationship between the ACW and the number of duplications.</p></caption><graphic xlink:href="101501_fig19" position="float" orientation="portrait" hwp:id="graphic-22"/></fig><fig id="fig20" position="float" orientation="portrait" fig-type="figure" hwp:id="F20"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/FIG20</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F20</object-id><object-id pub-id-type="publisher-id">fig20</object-id><label>Figure 20.</label><caption hwp:id="caption-23"><p hwp:id="p-69">The relationship between the number of feedback arcs and the number of insertions.</p></caption><graphic xlink:href="101501_fig20" position="float" orientation="portrait" hwp:id="graphic-23"/></fig><fig id="fig21" position="float" orientation="portrait" fig-type="figure" hwp:id="F21"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/FIG21</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F21</object-id><object-id pub-id-type="publisher-id">fig21</object-id><label>Figure 21.</label><caption hwp:id="caption-24"><p hwp:id="p-70">The relationship between the ACW and the number of insertions.</p></caption><graphic xlink:href="101501_fig21" position="float" orientation="portrait" hwp:id="graphic-24"/></fig><fig id="fig22" position="float" orientation="portrait" fig-type="figure" hwp:id="F22"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/FIG22</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F22</object-id><object-id pub-id-type="publisher-id">fig22</object-id><label>Figure 22.</label><caption hwp:id="caption-25"><p hwp:id="p-71">The relationship between the number of feedback arcs and the number of inversions.</p></caption><graphic xlink:href="101501_fig22" position="float" orientation="portrait" hwp:id="graphic-25"/></fig><fig id="fig23" position="float" orientation="portrait" fig-type="figure" hwp:id="F23"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/FIG23</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F23</object-id><object-id pub-id-type="publisher-id">fig23</object-id><label>Figure 23.</label><caption hwp:id="caption-26"><p hwp:id="p-72">The relationship between the ACW and the number of inversions.</p></caption><graphic xlink:href="101501_fig23" position="float" orientation="portrait" hwp:id="graphic-26"/></fig><p hwp:id="p-73">The relationship matches the one predicted theoretically. It shows that despite quadratic complexity estimation, it is clearly seen from <xref rid="fig13" ref-type="fig" hwp:id="xref-fig-13-2" hwp:rel-id="F13">Figure 13</xref> the algorithm can be used on big graphs.</p><p hwp:id="p-74">In addition to these tests on synthetic data, the algorithms were tested on a graph created from MHC region of chromosome 6 with 251297 nodes. Flow procedure running time was about 40 minutes.</p></sec></sec><sec id="s6" hwp:id="sec-13"><label>7</label><title hwp:id="title-15">Conclusion</title><p hwp:id="p-75">We have proposed a new sequence graph linearization algorithm that outperforms standard methods on the criteria that are important for storing, traversing, analyzing and visualizing genome sequence graphs. The quantitative results thus obtained suggest that this algorithm will prove useful in genome exploration. Earlier work on sequence graph linearization [<xref ref-type="bibr" rid="c15" hwp:id="xref-ref-15-1" hwp:rel-id="ref-15">15</xref>] focused on minimizing feedback arcs, here we additionally introduce cut-width as an important measure of a linearization that effectively measures contiguity between elements that are connected. Future effort to lower the computational complexity of the algorithm using graph decomposition (see [<xref ref-type="bibr" rid="c2" hwp:id="xref-ref-2-3" hwp:rel-id="ref-2">2</xref>]) will allow us to apply a modified form of the presented algorithm to complete human scale sequence graphs of hundreds of millions of nodes.</p></sec></body><back><ack hwp:id="ack-1"><title hwp:id="title-16">Acknowledgements</title><p hwp:id="p-76">We’d like to thank Erik Garrison and Glenn Hickey for helpful conversations. This work was supported by the National Human Genome Research Institute of the National Institutes of Health under Award Number 5U54HG007990 and grants from the W.M. Keck foundation and the Simons Foundation. The content is solely the responsibility of the authors and does not necessarily represent the official views of the National Institutes of Health.</p></ack><app-group hwp:id="app-group-1"><app hwp:id="app-1"><label>8</label><title hwp:id="title-17">Appendix A</title><sec id="s7a" hwp:id="sec-14"><label>8.1</label><title hwp:id="title-18">Some Details of the FP Algorithm</title><p hwp:id="p-77">We pointed out in the algorithm description above that sometimes not all of the graph’s nodes end up in the final list, and so we need to rerun the procedure with the graph’s sorted part as the backbone. <xref rid="fig1" ref-type="fig" hwp:id="xref-fig-1-2" hwp:rel-id="F1">Fig. 1</xref> demonstrates an example of such a situation.</p><p hwp:id="p-78">Here <italic toggle="yes">ABCDE</italic> is the backbone (shown in dark blue), arcs AF and GE are in the min cut and hence deleted in the first run. <italic toggle="yes">CG</italic> is the in-growth and <italic toggle="yes">FC</italic> is the out-growth. Node <italic toggle="yes">H</italic> is in neither the in-growth nor the out-growth and so does not end up in the list on the first run of the procedure. On the rerun, however, the backbone will be <italic toggle="yes">ABFCGDE</italic> and so <italic toggle="yes">H</italic> will fall into F’s outgrowth.</p><p hwp:id="p-79">Also noteworthy is the order in which we find the in- and outgrowths. First, we traverse the backbone from end to start, finding the outgrowth for each node, <italic toggle="yes">then</italic> we traverse it from start to end, finding the ingrowth. We include in the in- and outgrowths only those nodes that did not end up in any of the previous out- or ingrowths (see <xref rid="fig2" ref-type="fig" hwp:id="xref-fig-2-2" hwp:rel-id="F2">Fig. 2</xref>).</p></sec><sec id="s7b" hwp:id="sec-15"><label>8.2</label><title hwp:id="title-19">Step-by-step Algorithm Run</title><p hwp:id="p-80">Let's start from the moment when we have already found and removed the minimum cut. We go from the beginning to the end over the backbone (CGATC) and find the in-growth CCGA (upper 3 nodes and A from the backbone). For this in-growth we run the entire flow procedure recursively. Looking for the backbone, we start from A and search for incoming max weight arcs. We get CCA, then run the min cut search and remove the CG arc. Then we recursively go to the CCA backbone from the beginning to the end; we are looking for the in-growth. We find GC. For it we run the procedure, which arranges these two nodes in the obvious way. We insert the result into the backbone CCA with the G before the second C (the one that had the in-arc). Thus, we get CGCA. All nodes of this part are sorted, so the recursion is finished and we insert the resulting in-growth into the backbone of the source graph. Inserting to the backbone we get CGCGCATC. There are no other in-growths, so we turn to search for out-growths. We go from the end to the beginning. We find the GGC out-growth. It includes 3 consecutive nodes, so the recursive procedure for it throws out a natural GGC order. We insert to the backbone and get CGGCCGCATC. Then we look for the next out-growth. We find the CTCA starting from the first node of the backbone. For it, we run the procedure recursively. It finds the backbone CTA, then removes the min cut, finds the in-growth CA and inserts its C before the A: CTCA. There are no other in- or out-growths, so this part of the algorithm is finished and we insert nodes to the original backbone, finally getting CTCAGGCCGCATC.</p></sec><sec id="s7c" hwp:id="sec-16"><label>8.3</label><title hwp:id="title-20">Test Data Set Modelling</title><p hwp:id="p-81">In order to simulate the test data, we used the RSVSim package (version 1.14.0) from the Bioconductor software (Release 3.4). As a reference genome, we took BSgenome.Hsapiens.UCSC.hg38 (version 1.4.1), alternative branch chr13_KI270842v1_alt, which is 37287 nucleotides long. Using the simulateSV command of the RSVSim package, we modeled genome fragments of 10 individuals with a given set of variations. Resulting FASTA files were submitted to the entry of the msga command of the vg utility (<ext-link l:rel="related" l:ref-type="uri" l:ref="https://github.com/vgteam/vg" ext-link-type="uri" xlink:href="https://github.com/vgteam/vg" hwp:id="ext-link-2">https://github.com/vgteam/vg</ext-link>). As a result, we got a sequence graph (*.gfa format). This graph is an input to the commands vg sort-f (Eades) and vg sort (Flow procedure) of the vg utility (<ext-link l:rel="related" l:ref-type="uri" l:ref="https://github.com/vgteam/vg" ext-link-type="uri" xlink:href="https://github.com/vgteam/vg" hwp:id="ext-link-3">https://github.com/vgteam/vg</ext-link>). Finally, we got text files with graph nodes ordered by linearization using the Kahn, Eades, and flow procedure algorithms respectively. To analyze the algorithm, we created the original software to get the number of feedback arcs and the cut width in abovementioned sorts. To reduce the impact of accidents, we repeated the procedure 20 times for each set of variations and average the results.</p><p hwp:id="p-82">We created variation sets as follows. In the modelled genome fragments, we added 5 variation types: insertions, deletions, duplications, inversions, and translocations. The positions of all variations were uniformly distributed over the simulation section of the genome. Twenty percent of the insertions were duplicating sections of the DNA. Translocations were modelled using the shoulder exchange mechanism. The lengths of insertions and deletions were 20 nucleotides; the length of inversion was 200 nucleotides; the length of duplications was 500. The number of variations of each type was equal to 5 in the first set, 6 in the second, 7 in the third, and so on up to 11 in the latest set of variations. The appendix provides a dependence of the number of feedback arcs and cut widths of number of variations of the same type. For this study, the number of variations of all types, except the examined, were fixed at level 7, and the number of investigated variations were changing according to the following list: 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, and 31.</p></sec></app><app hwp:id="app-2"><label>9</label><title hwp:id="title-21">Appendix B</title><sec id="s8a" hwp:id="sec-17"><label>9.1</label><title hwp:id="title-22">The Results for MHC Graph</title><table-wrap id="tbl3" orientation="portrait" position="float" hwp:id="T4"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/TBL3</object-id><object-id pub-id-type="other" hwp:sub-type="slug">T4</object-id><object-id pub-id-type="publisher-id">tbl3</object-id><label>Table 3.</label><caption hwp:id="caption-27"><p hwp:id="p-83">Number of feedback arcs and average cut width by all three algorithms for MHC graph.</p></caption><graphic xlink:href="101501_tbl3" position="float" orientation="portrait" hwp:id="graphic-27"/></table-wrap></sec><sec id="s8b" hwp:id="sec-18"><label>9.2</label><title hwp:id="title-23">The Results of Additional Experiments</title><table-wrap id="tbl5" orientation="portrait" position="float" hwp:id="T5"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/TBL5</object-id><object-id pub-id-type="other" hwp:sub-type="slug">T5</object-id><object-id pub-id-type="publisher-id">tbl5</object-id><label>Table 5.</label><caption hwp:id="caption-28"><p hwp:id="p-84">The relationship between the number of feedback arcs and ACW, and the number of duplications.</p></caption><graphic xlink:href="101501_tbl5" position="float" orientation="portrait" hwp:id="graphic-28"/></table-wrap><table-wrap id="tbl6" orientation="portrait" position="float" hwp:id="T6"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/TBL6</object-id><object-id pub-id-type="other" hwp:sub-type="slug">T6</object-id><object-id pub-id-type="publisher-id">tbl6</object-id><label>Table 6.</label><caption hwp:id="caption-29"><p hwp:id="p-85">The relationship between the number of feedback arcs and ACW, and the number of inversions.</p></caption><graphic xlink:href="101501_tbl6" position="float" orientation="portrait" hwp:id="graphic-29"/></table-wrap><table-wrap id="tbl7" orientation="portrait" position="float" hwp:id="T7"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;101501v1/TBL7</object-id><object-id pub-id-type="other" hwp:sub-type="slug">T7</object-id><object-id pub-id-type="publisher-id">tbl7</object-id><label>Table 7.</label><caption hwp:id="caption-30"><p hwp:id="p-86">The relationship between the number of feedback arcs and ACW, and the number of insertions.</p></caption><graphic xlink:href="101501_tbl7" position="float" orientation="portrait" hwp:id="graphic-30"/></table-wrap></sec></app></app-group><ref-list hwp:id="ref-list-1"><label>10</label><title hwp:id="title-24">References</title><ref id="c1" hwp:id="ref-1" hwp:rev-id="xref-ref-1-1 xref-ref-1-2"><label>1.</label><citation publication-type="other" citation-type="journal" ref:id="101501v1.1" ref:linkable="no" ref:use-reference-as-is="yes" hwp:id="citation-1"><string-name name-style="western" hwp:sortable="Paten Benedict"><given-names>Benedict</given-names> <surname>Paten</surname></string-name>, <string-name name-style="western" hwp:sortable="Novak Adam"><given-names>Adam</given-names> <surname>Novak</surname></string-name>, <string-name name-style="western" hwp:sortable="Haussler David"><given-names>David</given-names> <surname>Haussler</surname></string-name>, <source hwp:id="source-1">Mapping to a Reference Genome Structure</source>, eprint <ext-link l:rel="related" l:ref-type="uri" l:ref="http://arxiv.org/abs/arXiv:1404.5010" ext-link-type="arxiv" xlink:href="http://arxiv.org/abs/arXiv:1404.5010" hwp:id="ext-link-4">arXiv:1404.5010</ext-link>.</citation></ref><ref id="c2" hwp:id="ref-2" hwp:rev-id="xref-ref-2-1 xref-ref-2-2 xref-ref-2-3"><label>2.</label><citation publication-type="journal" citation-type="journal" ref:id="101501v1.2" ref:linkable="no" ref:use-reference-as-is="yes" hwp:id="citation-2"><string-name name-style="western" hwp:sortable="Paten Benedict"><given-names>Benedict</given-names> <surname>Paten</surname></string-name>, <string-name name-style="western" hwp:sortable="Novak Adam M"><given-names>Adam M</given-names> <surname>Novak</surname></string-name>, <string-name name-style="western" hwp:sortable="Garrison Erik"><given-names>Erik</given-names> <surname>Garrison</surname></string-name>, <article-title hwp:id="article-title-2">Glenn Hickey.: Superbubbles, Ultrabubbles and Cacti</article-title>. <source hwp:id="source-2">Proceedings of RECOMB</source> <year>2017</year>.</citation></ref><ref id="c3" hwp:id="ref-3" hwp:rev-id="xref-ref-3-1"><label>3.</label><citation publication-type="journal" citation-type="journal" ref:id="101501v1.3" ref:linkable="no" ref:use-reference-as-is="yes" hwp:id="citation-3"><string-name name-style="western" hwp:sortable="Baharev Ali"><given-names>Ali</given-names> <surname>Baharev</surname></string-name>, <string-name name-style="western" hwp:sortable="Schichl Herman"><given-names>Herman</given-names> <surname>Schichl</surname></string-name>, <string-name name-style="western" hwp:sortable="Neumaer Arnold"><given-names>Arnold</given-names> <surname>Neumaer</surname></string-name>, <source hwp:id="source-3">Tobias Achterberg.: An exact method for the minimum feedback arc set problem</source>.</citation></ref><ref id="c4" hwp:id="ref-4" hwp:rev-id="xref-ref-4-1"><label>4.</label><citation publication-type="book" citation-type="book" ref:id="101501v1.4" ref:linkable="no" ref:use-reference-as-is="yes" hwp:id="citation-4"><string-name name-style="western" hwp:sortable="Richard M."><surname>Richard</surname> <given-names>M.</given-names></string-name> <chapter-title>Karp.: Reducibility among combinatorial problems</chapter-title>. In <person-group person-group-type="editor" hwp:id="person-group-1"><string-name name-style="western" hwp:sortable="Miller R. E."><given-names>R. E.</given-names> <surname>Miller</surname></string-name>, <string-name name-style="western" hwp:sortable="Thatcher J. W."><given-names>J. W.</given-names> <surname>Thatcher</surname></string-name>, and <string-name name-style="western" hwp:sortable="Bohlinger J. D."><given-names>J. D.</given-names> <surname>Bohlinger</surname></string-name></person-group>, editors, <source hwp:id="source-4">Complexity of Computer Computations, The IBM Research Symposia Series</source>, pages <fpage>85</fpage>–<lpage>103</lpage>. <publisher-name>Springer US</publisher-name>, <year>1972</year>.</citation></ref><ref id="c5" hwp:id="ref-5" hwp:rev-id="xref-ref-5-1"><label>5.</label><citation publication-type="report" citation-type="journal" ref:id="101501v1.5" ref:linkable="no" ref:use-reference-as-is="yes" hwp:id="citation-5"><string-name name-style="western" hwp:sortable="Brandenburg F."><surname>Brandenburg</surname>, <given-names>F.</given-names></string-name> <string-name name-style="western" hwp:sortable="Hanauer K."><surname>Hanauer</surname>, <given-names>K.</given-names></string-name>: <article-title hwp:id="article-title-3">Sorting Heuristics for the Feedback Arc Set Problem</article-title>. <source hwp:id="source-5">Technical Report. Number MIP-1104</source>, (<year>2011</year>).</citation></ref><ref id="c6" hwp:id="ref-6" hwp:rev-id="xref-ref-6-1"><label>6.</label><citation publication-type="confproc" citation-type="confproc" ref:id="101501v1.6" ref:linkable="no" ref:use-reference-as-is="yes" hwp:id="citation-6"><string-name name-style="western" hwp:sortable="Gavril F."><surname>Gavril</surname>, <given-names>F.</given-names></string-name>: <source hwp:id="source-6">Some NP-complete problems on graphs</source>. In <conf-name>Proceedings of the 11th conference on information Sciences and Systems</conf-name>. pp. <fpage>91</fpage>–<lpage>95</lpage> (<year>1977</year>).</citation></ref><ref id="c7" hwp:id="ref-7" hwp:rev-id="xref-ref-7-1"><label>7.</label><citation publication-type="journal" citation-type="journal" ref:id="101501v1.7" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-7"><string-name name-style="western" hwp:sortable="Martí R."><surname>Martí</surname>, <given-names>R.</given-names></string-name>, <string-name name-style="western" hwp:sortable="Pantrigo J."><surname>Pantrigo</surname>, <given-names>J.</given-names></string-name>, <string-name name-style="western" hwp:sortable="Duarte A."><surname>Duarte</surname>, <given-names>A.</given-names></string-name>, <string-name name-style="western" hwp:sortable="Pardo E."><surname>Pardo</surname>, <given-names>E.</given-names></string-name>: <article-title hwp:id="article-title-4">Branch and bound for the cutwidth minimization problem</article-title>. <source hwp:id="source-7">Computers &amp; Operations Research</source>. <volume>40</volume>, <fpage>137</fpage>–<lpage>149</lpage> (<year>2013</year>). doi: <pub-id pub-id-type="doi">10.1016/j.cor.2012.05.016</pub-id></citation></ref><ref id="c8" hwp:id="ref-8" hwp:rev-id="xref-ref-8-1"><label>8.</label><citation publication-type="book" citation-type="book" ref:id="101501v1.8" ref:linkable="no" ref:use-reference-as-is="yes" hwp:id="citation-8"><string-name name-style="western" hwp:sortable="Cormen T."><surname>Cormen</surname>, <given-names>T.</given-names></string-name>, <string-name name-style="western" hwp:sortable="Leiserson C."><surname>Leiserson</surname>, <given-names>C.</given-names></string-name>, <string-name name-style="western" hwp:sortable="Rivest R."><surname>Rivest</surname>, <given-names>R.</given-names></string-name>, <string-name name-style="western" hwp:sortable="Stein C."><surname>Stein</surname>, <given-names>C.</given-names></string-name>: <source hwp:id="source-8">Introduction to algorithms</source>. <publisher-name>Mit Press</publisher-name>, <publisher-loc>Cambridge</publisher-loc> (Inglaterra) (<year>2009</year>).</citation></ref><ref id="c9" hwp:id="ref-9" hwp:rev-id="xref-ref-9-1"><label>9.</label><citation publication-type="journal" citation-type="journal" ref:id="101501v1.9" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-9"><string-name name-style="western" hwp:sortable="Medvedev P."><surname>Medvedev</surname>, <given-names>P.</given-names></string-name> <string-name name-style="western" hwp:sortable="Brudno M"><surname>Brudno</surname>, <given-names>M</given-names></string-name>: <article-title hwp:id="article-title-5">Maximum Likelihood Genome Assembly</article-title>. <source hwp:id="source-9">Journal of Computational Biology</source>. <volume>16</volume>, <fpage>1101</fpage>–<lpage>1116</lpage> (<year>2009</year>). doi: <pub-id pub-id-type="doi">10.1089/cmb.2009.0047</pub-id></citation></ref><ref id="c10" hwp:id="ref-10" hwp:rev-id="xref-ref-10-1"><label>10.</label><citation publication-type="book" citation-type="book" ref:id="101501v1.10" ref:linkable="no" ref:use-reference-as-is="yes" hwp:id="citation-10"><source hwp:id="source-10">Flows in networks</source>. <publisher-name>Princeton University Press</publisher-name>. (<year>1962</year>)</citation></ref><ref id="c11" hwp:id="ref-11" hwp:rev-id="xref-ref-11-1"><label>11.</label><citation publication-type="website" citation-type="web" ref:id="101501v1.11" ref:linkable="no" ref:use-reference-as-is="yes" ref:citation-has-metadata="no" hwp:id="citation-11"><ext-link l:rel="related" l:ref-type="uri" l:ref="https://www.bioconductor.org/packages/release/bioc/html/RSVSim.html" ext-link-type="uri" xlink:href="https://www.bioconductor.org/packages/release/bioc/html/RSVSim.html" hwp:id="ext-link-5">https://www.bioconductor.org/packages/release/bioc/html/RSVSim.html</ext-link></citation></ref><ref id="c12" hwp:id="ref-12" hwp:rev-id="xref-ref-12-1 xref-ref-12-2"><label>12.</label><citation publication-type="website" citation-type="web" ref:id="101501v1.12" ref:linkable="no" ref:use-reference-as-is="yes" ref:citation-has-metadata="no" hwp:id="citation-12"><ext-link l:rel="related" l:ref-type="uri" l:ref="https://github.com/vgteam/vg" ext-link-type="uri" xlink:href="https://github.com/vgteam/vg" hwp:id="ext-link-6">https://github.com/vgteam/vg</ext-link></citation></ref><ref id="c13" hwp:id="ref-13" hwp:rev-id="xref-ref-13-1 xref-ref-13-2"><label>13.</label><citation publication-type="journal" citation-type="journal" ref:id="101501v1.13" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-13"><string-name name-style="western" hwp:sortable="Kahn A."><surname>Kahn</surname>, <given-names>A.</given-names></string-name>: <article-title hwp:id="article-title-6">Topological sorting of large networks</article-title>. <source hwp:id="source-11">Communications of the ACM</source>. <volume>5</volume>, <fpage>558</fpage>–<lpage>562</lpage> (<year>1962</year>). doi: <pub-id pub-id-type="doi">10.1145/368996.369025</pub-id></citation></ref><ref id="c14" hwp:id="ref-14" hwp:rev-id="xref-ref-14-1 xref-ref-14-2"><label>14.</label><citation publication-type="journal" citation-type="journal" ref:id="101501v1.14" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-14"><string-name name-style="western" hwp:sortable="Eades P."><surname>Eades</surname>, <given-names>P.</given-names></string-name>, <string-name name-style="western" hwp:sortable="Lin X."><surname>Lin</surname>, <given-names>X.</given-names></string-name>, <string-name name-style="western" hwp:sortable="Smyth W."><surname>Smyth</surname>, <given-names>W.</given-names></string-name>: <article-title hwp:id="article-title-7">A fast and effective heuristic for the feedback arc set problem</article-title>. <source hwp:id="source-12">Information Processing Letters</source>. <volume>47</volume>, <fpage>319</fpage>–<lpage>323</lpage> (<year>1993</year>). doi: <pub-id pub-id-type="doi">10.1016/0020-0190(93)90079-O</pub-id></citation></ref><ref id="c15" hwp:id="ref-15" hwp:rev-id="xref-ref-15-1"><label>15.</label><citation publication-type="journal" citation-type="journal" ref:id="101501v1.15" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-15"><string-name name-style="western" hwp:sortable="Nguyen N."><surname>Nguyen</surname>, <given-names>N.</given-names></string-name>, <string-name name-style="western" hwp:sortable="Hickey G."><surname>Hickey</surname>, <given-names>G.</given-names></string-name>, <string-name name-style="western" hwp:sortable="Zerbino D."><surname>Zerbino</surname>, <given-names>D.</given-names></string-name>, <string-name name-style="western" hwp:sortable="Raney B."><surname>Raney</surname>, <given-names>B.</given-names></string-name>, <string-name name-style="western" hwp:sortable="Earl D."><surname>Earl</surname>, <given-names>D.</given-names></string-name>, <string-name name-style="western" hwp:sortable="Armstrong J."><surname>Armstrong</surname>, <given-names>J.</given-names></string-name>, <string-name name-style="western" hwp:sortable="Kent W."><surname>Kent</surname>, <given-names>W.</given-names></string-name>, <string-name name-style="western" hwp:sortable="Haussler D."><surname>Haussler</surname>, <given-names>D.</given-names></string-name>, <string-name name-style="western" hwp:sortable="Paten B."><surname>Paten</surname>, <given-names>B.</given-names></string-name>: <article-title hwp:id="article-title-8">Building a Pan-Genome Reference for a Population</article-title>. <source hwp:id="source-13">Journal of Computational Biology</source>. <volume>22</volume>, <fpage>387</fpage>–<lpage>401</lpage> (<year>2015</year>). doi: <pub-id pub-id-type="doi">10.1089/cmb.2014.0146</pub-id></citation></ref></ref-list></back></article>
