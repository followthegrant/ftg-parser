<article article-type="article" specific-use="production" xml:lang="en" xmlns:hw="org.highwire.hpp" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ali="http://www.niso.org/schemas/ali/1.0/" xmlns:ref="http://schema.highwire.org/Reference" xmlns:hwp="http://schema.highwire.org/Journal" xmlns:l="http://schema.highwire.org/Linking" xmlns:r="http://schema.highwire.org/Revision" xmlns:x="http://www.w3.org/1999/xhtml" xmlns:app="http://www.w3.org/2007/app" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:nlm="http://schema.highwire.org/NLM/Journal" xmlns:a="http://www.w3.org/2005/Atom" xmlns:c="http://schema.highwire.org/Compound" xmlns:hpp="http://schema.highwire.org/Publishing"><front><journal-meta><journal-id journal-id-type="hwp">biorxiv</journal-id><journal-id journal-id-type="publisher-id">BIORXIV</journal-id><journal-title>bioRxiv</journal-title><abbrev-journal-title abbrev-type="publisher">bioRxiv</abbrev-journal-title><publisher><publisher-name>Cold Spring Harbor Laboratory</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="doi">10.1101/060012</article-id><article-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;060012v3</article-id><article-id pub-id-type="other" hwp:sub-type="pisa-master">biorxiv;060012</article-id><article-id pub-id-type="other" hwp:sub-type="slug">060012</article-id><article-id pub-id-type="other" hwp:sub-type="atom-slug">060012</article-id><article-id pub-id-type="other" hwp:sub-type="tag">060012</article-id><article-version>1.3</article-version><article-categories><subj-group subj-group-type="author-type"><subject>Regular Article</subject></subj-group><subj-group subj-group-type="heading"><subject>New Results</subject></subj-group><subj-group subj-group-type="hwp-journal-coll" hwp:journal-coll-id="Bioinformatics" hwp:journal="biorxiv"><subject>Bioinformatics</subject></subj-group></article-categories><title-group><article-title hwp:id="article-title-1">Fast gene set enrichment analysis</article-title></title-group><author-notes hwp:id="author-notes-1"><fn id="n1" fn-type="equal" hwp:id="fn-1" hwp:rev-id="xref-fn-1-1 xref-fn-1-2"><label>*</label><p hwp:id="p-1">contributed equally</p></fn><corresp id="cor1" hwp:id="corresp-1" hwp:rev-id="xref-corresp-1-1"><label>**</label>corresponding author, e-mail: <email hwp:id="email-1">alserg@itmo.ru</email></corresp></author-notes><contrib-group hwp:id="contrib-group-1"><contrib contrib-type="author" hwp:id="contrib-1"><name name-style="western" hwp:sortable="Korotkevich Gennady"><surname>Korotkevich</surname><given-names>Gennady</given-names></name><xref ref-type="aff" rid="a1" hwp:id="xref-aff-1-1" hwp:rel-id="aff-1">1</xref><xref ref-type="fn" rid="n1" hwp:id="xref-fn-1-1" hwp:rel-id="fn-1">*</xref></contrib><contrib contrib-type="author" hwp:id="contrib-2"><name name-style="western" hwp:sortable="Sukhov Vladimir"><surname>Sukhov</surname><given-names>Vladimir</given-names></name><xref ref-type="aff" rid="a1" hwp:id="xref-aff-1-2" hwp:rel-id="aff-1">1</xref><xref ref-type="aff" rid="a2" hwp:id="xref-aff-2-1" hwp:rel-id="aff-2">2</xref><xref ref-type="fn" rid="n1" hwp:id="xref-fn-1-2" hwp:rel-id="fn-1">*</xref></contrib><contrib contrib-type="author" hwp:id="contrib-3"><name name-style="western" hwp:sortable="Budin Nikolay"><surname>Budin</surname><given-names>Nikolay</given-names></name><xref ref-type="aff" rid="a1" hwp:id="xref-aff-1-3" hwp:rel-id="aff-1">1</xref></contrib><contrib contrib-type="author" hwp:id="contrib-4"><name name-style="western" hwp:sortable="Shpak Boris"><surname>Shpak</surname><given-names>Boris</given-names></name><xref ref-type="aff" rid="a1" hwp:id="xref-aff-1-4" hwp:rel-id="aff-1">1</xref></contrib><contrib contrib-type="author" hwp:id="contrib-5"><name name-style="western" hwp:sortable="Artyomov Maxim N."><surname>Artyomov</surname><given-names>Maxim N.</given-names></name><xref ref-type="aff" rid="a3" hwp:id="xref-aff-3-1" hwp:rel-id="aff-3">3</xref></contrib><contrib contrib-type="author" corresp="yes" hwp:id="contrib-6"><name name-style="western" hwp:sortable="Sergushichev Alexey"><surname>Sergushichev</surname><given-names>Alexey</given-names></name><xref ref-type="aff" rid="a1" hwp:id="xref-aff-1-5" hwp:rel-id="aff-1">1</xref><xref ref-type="corresp" rid="cor1" hwp:id="xref-corresp-1-1" hwp:rel-id="corresp-1">**</xref></contrib><aff id="a1" hwp:id="aff-1" hwp:rev-id="xref-aff-1-1 xref-aff-1-2 xref-aff-1-3 xref-aff-1-4 xref-aff-1-5"><label>1</label><institution hwp:id="institution-1">Computer Technologies Laboratory, ITMO University</institution>, Saint Petersburg, 197101, <country>Russia</country></aff><aff id="a2" hwp:id="aff-2" hwp:rev-id="xref-aff-2-1"><label>2</label><institution hwp:id="institution-2">JetBrains Research</institution>, Saint Petersburg, <country>Russia</country></aff><aff id="a3" hwp:id="aff-3" hwp:rev-id="xref-aff-3-1"><label>3</label><institution hwp:id="institution-3">Washington University in St. Louis</institution>, St. Louis, MO, <country>USA</country></aff></contrib-group><pub-date pub-type="epub-original" date-type="pub" publication-format="electronic" hwp:start="2021"><year>2021</year></pub-date><pub-date pub-type="hwp-created" hwp:start="2016-06-20T17:21:16-07:00">
    <day>20</day><month>6</month><year>2016</year>
  </pub-date><pub-date pub-type="hwp-received" hwp:start="2021-02-01T01:39:18-08:00">
    <day>1</day><month>2</month><year>2021</year>
  </pub-date><pub-date pub-type="epub" hwp:start="2016-06-20T17:50:13-07:00">
    <day>20</day><month>6</month><year>2016</year>
  </pub-date><pub-date pub-type="epub-version" hwp:start="2021-02-01T01:42:39-08:00">
    <day>1</day><month>2</month><year>2021</year>
  </pub-date><elocation-id>060012</elocation-id><history hwp:id="history-1">
<date date-type="received" hwp:start="2016-06-20"><day>20</day><month>6</month><year>2016</year></date>
<date date-type="rev-recd" hwp:start="2021-02-01"><day>01</day><month>2</month><year>2021</year></date>
<date date-type="accepted" hwp:start="2021-02-01"><day>01</day><month>2</month><year>2021</year></date>
</history><permissions><copyright-statement hwp:id="copyright-statement-1">© 2021, Posted by Cold Spring Harbor Laboratory</copyright-statement><copyright-year>2021</copyright-year><license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by/4.0/" hwp:id="license-1"><p hwp:id="p-2">This pre-print is available under a Creative Commons License (Attribution 4.0 International), CC BY 4.0, as described at <ext-link l:rel="related" l:ref-type="uri" l:ref="http://creativecommons.org/licenses/by/4.0/" ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/" hwp:id="ext-link-1">http://creativecommons.org/licenses/by/4.0/</ext-link></p></license></permissions><self-uri xlink:href="060012.pdf" content-type="pdf" xlink:role="full-text"/><self-uri l:ref="forthcoming:yes" c:role="http://schema.highwire.org/variant/abstract" xlink:role="abstract" content-type="xhtml+xml" hwp:variant="yes"/><self-uri l:ref="forthcoming:yes" c:role="http://schema.highwire.org/variant/change-list" xlink:role="change-list" content-type="xhtml+xml" hwp:variant="yes"/><self-uri l:ref="forthcoming:yes" c:role="http://schema.highwire.org/variant/external-links" xlink:role="external-links" content-type="xhtml+xml" hwp:variant="yes"/><self-uri l:ref="forthcoming:yes" c:role="http://schema.highwire.org/variant/full-text" xlink:href="file:/content/biorxiv/vol0/issue2021/pdf/060012v3.pdf" hwp:variant="yes" content-type="pdf" xlink:role="full-text"/><self-uri l:ref="forthcoming:yes" c:role="http://schema.highwire.org/variant/full-text" xlink:role="full-text" content-type="xhtml+xml" hwp:variant="yes"/><self-uri l:ref="forthcoming:yes" c:role="http://schema.highwire.org/variant/source" xlink:role="source" content-type="xml" xlink:show="none" hwp:variant="yes"/><self-uri l:ref="forthcoming:yes" c:role="http://schema.highwire.org/variant/original" xlink:role="original" content-type="xml" xlink:show="none" hwp:variant="yes" xlink:href="060012.xml"/><self-uri content-type="abstract" xlink:href="file:/content/biorxiv/vol0/issue2021/abstracts/060012v3/060012v3.htslp"/><self-uri content-type="fulltext" xlink:href="file:/content/biorxiv/vol0/issue2021/fulltext/060012v3/060012v3.htslp"/><abstract hwp:id="abstract-1"><title hwp:id="title-1">Abstract</title><p hwp:id="p-3">Gene set enrichment analysis (GSEA) is an ubiquitously used tool for evaluating pathway enrichment in transcriptional data. Typical experimental design consists in comparing two conditions with several replicates using a differential gene expression test followed by preranked GSEA performed against a collection of hundreds and thousands of pathways. However, the reference implementation of this method cannot accurately estimate small P-values, which significantly limits its sensitivity due to multiple hypotheses correction procedure.</p><p hwp:id="p-4">Here we present FGSEA (Fast Gene Set Enrichment Analysis) method that is able to estimate arbitrarily low GSEA P-values with a high accuracy in a matter of minutes or even seconds. To confirm the accuracy of the method, we also developed an exact algorithm for GSEA P-values calculation for integer gene-level statistics. Using the exact algorithm as a reference we show that FGSEA is able to routinely estimate P-values up to 10<sup>−100</sup> with a small and predictable estimation error. We systematically evaluate FGSEA on a collection of 605 datasets and show that FGSEA recovers much more statistically significant pathways compared to other implementations.</p><p hwp:id="p-5">FGSEA is open source and available as an R package in Bioconductor (<ext-link l:rel="related" l:ref-type="uri" l:ref="http://bioconductor.org/packages/fgsea/" ext-link-type="uri" xlink:href="http://bioconductor.org/packages/fgsea/" hwp:id="ext-link-2">http://bioconductor.org/packages/fgsea/</ext-link>) and on GitHub (<ext-link l:rel="related" l:ref-type="uri" l:ref="https://github.com/ctlab/fgsea/" ext-link-type="uri" xlink:href="https://github.com/ctlab/fgsea/" hwp:id="ext-link-3">https://github.com/ctlab/fgsea/</ext-link>).</p></abstract><counts><page-count count="40"/></counts><custom-meta-wrap><custom-meta hwp:id="custom-meta-1"><meta-name>special-property</meta-name><meta-value>contains-inline-supplementary-material</meta-value></custom-meta></custom-meta-wrap><custom-meta-wrap>
    <custom-meta hwp:id="custom-meta-2">
      <meta-name>has-earlier-version</meta-name>
      <meta-value>yes</meta-value>
    </custom-meta>
  </custom-meta-wrap></article-meta><notes hwp:id="notes-1"><notes notes-type="competing-interest-statement" hwp:id="notes-2"><title hwp:id="title-2">Competing Interest Statement</title><p hwp:id="p-6">The authors have declared no competing interest.</p></notes><fn-group content-type="summary-of-updates" hwp:id="fn-group-1"><title hwp:id="title-3">Summary of Updates:</title><fn fn-type="update" hwp:id="fn-2"><p hwp:id="p-7">A systematic analysis of GSEA performance on 605 datasets has been added.</p></fn></fn-group><fn-group content-type="external-links" hwp:id="fn-group-2"><fn fn-type="dataset" hwp:id="fn-3"><p hwp:id="p-8">
<ext-link l:rel="related" l:ref-type="uri" l:ref="https://github.com/ctlab/fgsea/" ext-link-type="uri" xlink:href="https://github.com/ctlab/fgsea/" hwp:id="ext-link-4">https://github.com/ctlab/fgsea/</ext-link>
</p></fn></fn-group></notes></front><body><sec id="s1" hwp:id="sec-1"><label>1</label><title hwp:id="title-4">Main</title><p hwp:id="p-9">Preranked gene set enrichment analysis (GSEA) [<xref ref-type="bibr" rid="c1" hwp:id="xref-ref-1-1" hwp:rel-id="ref-1">1</xref>] is a widely used method for analyzing gene expression data, particularly for datasets with small number of replicates. It allows to select from an <italic toggle="yes">a priori</italic> defined collection of pathways those which have non-random behavior in a considered experiment (<xref ref-type="fig" rid="fig1" hwp:id="xref-fig-1-1" hwp:rel-id="F1">Fig 1a</xref>). The method uses an enrichment score (ES) statistic which is calculated based on a vector of gene-level signed statistics, such as <italic toggle="yes">t</italic>-statistic from a differential expression test. As the analytical form of the null distribution for the ES statistic is not known, empirical null distribution has to be calculated. That can be done in a straightforward manner by sampling random gene sets as was done in the reference implementation [<xref ref-type="bibr" rid="c1" hwp:id="xref-ref-1-2" hwp:rel-id="ref-1">1</xref>] and reimplementations [<xref ref-type="bibr" rid="c2" hwp:id="xref-ref-2-1" hwp:rel-id="ref-2">2</xref>, <xref ref-type="bibr" rid="c3" hwp:id="xref-ref-3-1" hwp:rel-id="ref-3">3</xref>], In this case for each of the input pathways a number of random gene sets of the same size are generated, and for each of them an ES value is calculated. Then a P-value is estimated as the number of random gene sets with the same or more extreme ES value divided by the total number of generated gene sets (a formal definition is available in the <xref ref-type="sec" rid="s2a" hwp:id="xref-sec-3-1" hwp:rel-id="sec-3">section 2.1</xref>). Finally, a multiple hypothesis correction procedure is applied to get adjusted P-values.</p><fig id="fig1" position="float" orientation="portrait" fig-type="figure" hwp:id="F1" hwp:rev-id="xref-fig-1-1 xref-fig-1-2 xref-fig-1-3 xref-fig-1-4"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;060012v3/FIG1</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F1</object-id><object-id pub-id-type="publisher-id">fig1</object-id><label>Figure 1:</label><caption hwp:id="caption-1"><p hwp:id="p-10">Gene Set Enrichment Analsyis (GSEA) sensitivity depends on the ability to reach high sampling depth, <bold>a</bold>, Overview of preranked GSEA method, <bold>b</bold>, The number of pathways reaching Benjamini-Hochberg adjusted P-value threshold depends on the sampling depth in a phase transition manner. The critical sampling depth, where the transition happens, varies with the dataset, <bold>c</bold>, Distribution of critical sampling depth values across 605 curated datasets from Gene Expression Omnibus, as estimated for three pathway collections, <bold>d</bold>, Time required for the reference GSEA implementation to estimate P-values for different gene set collections and sampling depth values for dataset GSE22293. N/A values indicate out of memory errors.</p></caption><graphic xlink:href="060012v3_fig1" position="float" orientation="portrait" hwp:id="graphic-1"/></fig><p hwp:id="p-11">However, a large number of generated random gene sets can be required to reach a given false discovery rate (FDR) level on some datasets. As an example, we calculated GSEA P-values for Gene Ontology Biological Pathways collection (C5_BP subset of MSigDB collection [<xref ref-type="bibr" rid="c1" hwp:id="xref-ref-1-3" hwp:rel-id="ref-1">1</xref>]) on four datasets from Gene Expression Omnibus (GEO) varying the sampling depth, and calculated the number of pathways reaching FDR level of 0.01 after Benjamini-Hochberg (BH) correction. Due to the properties of BH procedure, the dependence of the number of significant pathways in these experiments has a phase transition behavior (<xref ref-type="fig" rid="fig1" hwp:id="xref-fig-1-2" hwp:rel-id="F1">Fig 1b</xref>): for each of the datasets there exist a certain critical sampling depth after which the number of significant pathways becomes non-zero and stays on the same level. This critical sampling depth is different for different datasets, but ultimately can reach the order of <italic toggle="yes">M</italic>/<italic toggle="yes">α</italic>, where <italic toggle="yes">α</italic> is the selected FDR threshold and <italic toggle="yes">M</italic> is the number of considered pathways.</p><p hwp:id="p-12">To systematically asses the distribution of GSEA critical sampling depth on real datasets we prepared a collection of 605 microarray datasets from Gene Expression Omnibus (GEO) containing only two biological condistions. For each of these datasets we ran the differential expression analysis and used the results as gene-level statistics. We discovered that more than half of the datasets has the critical sampling depth of at least 10<sup>4</sup> and a noticeable portion (10–20% depending on the collection) has the critical sampling depth of at least 10<sup>5</sup> (<xref ref-type="fig" rid="fig1" hwp:id="xref-fig-1-3" hwp:rel-id="F1">Fig 1c</xref>). When a large pathway collection is considered (entire MSigDB collection) individual datasets has values of critical sampling depths reaching 5 · 10<sup>6</sup>. However, even running the reference implementation with the sampling depth of <italic toggle="yes">n</italic> = 10<sup>4</sup> routinely is inconvenient and running it with <italic toggle="yes">n</italic> = 10<sup>5</sup> can be impossible due to the time and memory consumption (<xref ref-type="fig" rid="fig1" hwp:id="xref-fig-1-4" hwp:rel-id="F1">Fig 1d</xref>): time and memory requirements grow linearly with the number of samples and the collection size.</p><p hwp:id="p-13">To improve applicability of preranked GSEA analysis we present a fast gene set enrichment analysis (FGSEA) method for accurate and efficient estimation of GSEA P-values for a collection of pathways. The method consist of two main procedures: <italic toggle="yes">FGSEA-simple</italic> and <italic toggle="yes">FGSEA-multilevel</italic>. FGSEA-simple procedure allows to efficiently estimate P-values with a limited accuracy but simultaneously for the whole <italic toggle="yes">collection</italic> of gene sets, while FGSEA-multilevel procedure allows to accurately estimate arbitrarily low P-values but for <italic toggle="yes">individual</italic> gene sets.</p><p hwp:id="p-14">FGSEA-simple procedure is based on an idea that generated random gene set samples can be shared between different input pathways. Indeed, consider <italic toggle="yes">M</italic> gene sets of the sizes <italic toggle="yes">K</italic><sub>1</sub> ⩽ <italic toggle="yes">K</italic><sub>2</sub> ⩽ … ⩽ <italic toggle="yes">K<sub>M</sub></italic> = <italic toggle="yes">K</italic> and a collection of <italic toggle="yes">n</italic> independent samples <italic toggle="yes">g<sub>i</sub></italic> of size <italic toggle="yes">K</italic> (<xref ref-type="fig" rid="fig2" hwp:id="xref-fig-2-1" hwp:rel-id="F2">Fig 2a</xref>). As in the naive approach, due to <italic toggle="yes">g<sub>i</sub></italic> being independent samples of the size <italic toggle="yes">K</italic> the P-value for the pathway <italic toggle="yes">M</italic> can be estimated as a proportion of samples <italic toggle="yes">g<sub>i</sub></italic> having the same or more extreme ES value as the pathway <italic toggle="yes">M</italic>. However, for any other pathway <italic toggle="yes">j</italic> we can construct a set of <italic toggle="yes">n</italic> independent samples of size <italic toggle="yes">K<sub>j</sub></italic> by considering the prefixes <italic toggle="yes">g</italic><sub><italic toggle="yes">i</italic>,1..<italic toggle="yes">K<sub>j</sub></italic></sub>. Again, given a set of independent samples, the P-value can be estimated as a proportion of the samples having the same or more extreme ES value.</p><fig id="fig2" position="float" orientation="portrait" fig-type="figure" hwp:id="F2" hwp:rev-id="xref-fig-2-1 xref-fig-2-2 xref-fig-2-3"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;060012v3/FIG2</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F2</object-id><object-id pub-id-type="publisher-id">fig2</object-id><label>Figure 2:</label><caption hwp:id="caption-2"><p hwp:id="p-15">Preranked gene set enrichment analysis can be sped up by sharing sampling information between different gene set sizes, <bold>a</bold>, It is sufficient to generate <italic toggle="yes">n</italic> independent samples of size <italic toggle="yes">K<sub>M</sub></italic> to calculate empirical distribution for any sizes <italic toggle="yes">K<sub>j</sub></italic> ⩽ <italic toggle="yes">K<sub>M</sub></italic> by considering only the prefix of the samples of the size <italic toggle="yes">K<sub>j</sub></italic> <bold>b</bold>, For a given gene sample enrichment scores for all the prefixes can be efficiently calculated by employing a square root heuristic, <bold>c</bold>, The P-values calculated with the FGSEA-simple method are consistent with the reference implementation, but the results are obtained hundreds times faster.</p></caption><graphic xlink:href="060012v3_fig2" position="float" orientation="portrait" hwp:id="graphic-2"/></fig><p hwp:id="p-16">The next important idea is that given a gene set sample <italic toggle="yes">g<sub>i</sub></italic> of the size <italic toggle="yes">K</italic> the ES values for <italic toggle="yes">all</italic> the prefixes <italic toggle="yes">g</italic><sub><italic toggle="yes">i</italic>,1..<italic toggle="yes">j</italic></sub> can be calculated in an efficient manner using a square root heuristic (<xref ref-type="fig" rid="fig2" hwp:id="xref-fig-2-2" hwp:rel-id="F2">Fig 2b</xref>). Briefly, a variant of an enrichment curve is considered: the genes are enumerated starting from the most up-regulated to the most down-regulated, with the curve going to the right if the gene is not present in the pathway, and the curve goes upward if the gene is present in the pathway. It can be shown that the enrichment score can be easily calculated if curve point most distant from the diagonal is known. Let us split <italic toggle="yes">K</italic> genes from the gene set into <inline-formula hwp:id="inline-formula-1"><alternatives hwp:id="alternatives-1"><inline-graphic xlink:href="060012v3_inline1.gif" hwp:id="inline-graphic-1"/></alternatives></inline-formula> consecutive blocks of size <inline-formula hwp:id="inline-formula-2"><alternatives hwp:id="alternatives-2"><inline-graphic xlink:href="060012v3_inline2.gif" hwp:id="inline-graphic-2"/></alternatives></inline-formula> and consider what happens with the curve when we change the prefix from <italic toggle="yes">g</italic><sub><italic toggle="yes">i</italic>,1..<italic toggle="yes">j</italic>−1</sub> to <italic toggle="yes">g</italic><sub><italic toggle="yes">i</italic>,1..<italic toggle="yes">j</italic></sub> by adding gene <italic toggle="yes">g<sub>i,j</sub></italic>. The curve in the blocks to the left of <italic toggle="yes">g<sub>i,j</sub></italic> are not changed at all, while the blocks to the right of <italic toggle="yes">g<sub>i,j</sub></italic> are uniformly shifted. This observation allows us to consider the prefixes in an increasing order and update the position of the most distant point in <inline-formula hwp:id="inline-formula-3"><alternatives hwp:id="alternatives-3"><inline-graphic xlink:href="060012v3_inline3.gif" hwp:id="inline-graphic-3"/></alternatives></inline-formula> time. Briefly, for the each block which is either not changed or shifted the update procedure takes <italic toggle="yes">O</italic>(1) time, while for the changed block the update procedure is proportional to its size and takes <inline-formula hwp:id="inline-formula-4"><alternatives hwp:id="alternatives-4"><inline-graphic xlink:href="060012v3_inline4.gif" hwp:id="inline-graphic-4"/></alternatives></inline-formula> time. Finally, aggregating the blocks takes additional <inline-formula hwp:id="inline-formula-5"><alternatives hwp:id="alternatives-5"><inline-graphic xlink:href="060012v3_inline5.gif" hwp:id="inline-graphic-5"/></alternatives></inline-formula> time. Overall this results in time complexity of <inline-formula hwp:id="inline-formula-6"><alternatives hwp:id="alternatives-6"><inline-graphic xlink:href="060012v3_inline6.gif" hwp:id="inline-graphic-6"/></alternatives></inline-formula> to calculate ES values for all the prefixes. In total, the time complexity of the calculating P-values for the set of <italic toggle="yes">M</italic> pathways is <inline-formula hwp:id="inline-formula-7"><alternatives hwp:id="alternatives-7"><inline-graphic xlink:href="060012v3_inline7.gif" hwp:id="inline-graphic-7"/></alternatives></inline-formula>, which gives around <inline-formula hwp:id="inline-formula-8"><alternatives hwp:id="alternatives-8"><inline-graphic xlink:href="060012v3_inline8.gif" hwp:id="inline-graphic-8"/></alternatives></inline-formula> speed up compared to a naive approach. The full description of the algorithm is given in the <xref ref-type="sec" rid="s2c" hwp:id="xref-sec-5-1" hwp:rel-id="sec-5">section 2.3</xref>.</p><p hwp:id="p-17">As an example we ran FGSEA-simple and the reference implementations on the same example dataset of genes differentially regulated on Thl activation [<xref ref-type="bibr" rid="c4" hwp:id="xref-ref-4-1" hwp:rel-id="ref-4">4</xref>] against a set of 700 Reactome [<xref ref-type="bibr" rid="c5" hwp:id="xref-ref-5-1" hwp:rel-id="ref-5">5</xref>] pathways (see <xref ref-type="sec" rid="s2b" hwp:id="xref-sec-4-1" hwp:rel-id="sec-4">section 2.2</xref>) and compared the resulting nominal P-values (<xref ref-type="fig" rid="fig2" hwp:id="xref-fig-2-3" hwp:rel-id="F2">Fig 2c</xref>). Both methods were ran with <italic toggle="yes">n</italic> = 10000 and the results are indistinguishable from each other up to the random noise inherent to both methods. However, on this example the reference implementation took about 420 seconds, while FGSEA-simple finished in about 4 seconds. The two order of magnitude speed-up is consistent with the theoretical one due to the algorithm time complexity. Given a highly parallel implementation of FGSEA-simple, its performance allows to routinely achieve sampling depth of 10<sup>5</sup> and accurately estimate P-values as low as 10<sup>−5</sup>.</p><p hwp:id="p-18">However, accurately estimating P-values lower than 10<sup>−5</sup> with FGSEA-simple can be impractical or even infeasible. To estimate such low P-values we developed <italic toggle="yes">FGSEA-multilevel</italic> method, which is based on an adaptive multi-level split Monte Carlo scheme [<xref ref-type="bibr" rid="c6" hwp:id="xref-ref-6-1" hwp:rel-id="ref-6">6</xref>], The method takes as an input an ES value <italic toggle="yes">γ</italic> &gt; 0 and a gene set size <italic toggle="yes">K</italic>, and calculates the probability <italic toggle="yes">P<sub>K</sub></italic> (ES ⩾ <italic toggle="yes">γ</italic>) of a random gene set of size <italic toggle="yes">K</italic> to have an enrichment score no less than <italic toggle="yes">γ</italic>. The method sequentially finds ES levels <italic toggle="yes">l<sub>i</sub></italic> for which the probability <italic toggle="yes">P<sub>K</sub></italic>(ES ⩾ <italic toggle="yes">l<sub>i</sub></italic>) is approximately equal to 2<sup>−<italic toggle="yes">i</italic></sup> (see <xref ref-type="fig" rid="fig3" hwp:id="xref-fig-3-1" hwp:rel-id="F3">Fig 3a</xref> for a toy example). The method stops when <italic toggle="yes">l<sub>i</sub></italic> becomes greater than <italic toggle="yes">γ</italic> and the P-value can be crudely approximated as 2<sup>−<italic toggle="yes">i</italic></sup>.</p><fig id="fig3" position="float" orientation="portrait" fig-type="figure" hwp:id="F3" hwp:rev-id="xref-fig-3-1 xref-fig-3-2 xref-fig-3-3 xref-fig-3-4 xref-fig-3-5 xref-fig-3-6 xref-fig-3-7"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;060012v3/FIG3</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F3</object-id><object-id pub-id-type="publisher-id">fig3</object-id><label>Figure 3:</label><caption hwp:id="caption-3"><p hwp:id="p-19">Adaptive multilevel Monte Carlo sampling scheme can be used to calculate arbitrarily low P-values. <bold>a</bold>, A toy illustration of the multilevel split Monte Carlo scheme for sample size of <italic toggle="yes">Z</italic> = 5. <bold>b</bold>, Comparison of GSEA P-values as calculated by FGSEA-simple method run with the sampleing depth <italic toggle="yes">n</italic> = 10<sup>8</sup> and FGSEA-multilevel with the sample size of Z=101. <bold>c</bold>, Comparison of P-values as calculated with an exact method and FGSEA-multilevel method. Both methods were run on gene-level statistic values rounded to integers. <bold>d</bold>, Comparison between estimated and an observed error of <italic toggle="yes">log</italic><sub>2</sub> P-values for different P-values (from 10<sup>−4</sup> to 10<sup>−100</sup>), gene set sizes (from 15 to 250) and sample sizes (from 101 to 1001). <bold>d</bold>, An example of FGSEA results as run with FGSEA-multilevel method for Th0 vs Th1 comparison and Reactome pathways. The analysis was run with sample size of <italic toggle="yes">Z</italic> =101. Redundant pathways were filtered.</p></caption><graphic xlink:href="060012v3_fig3" position="float" orientation="portrait" hwp:id="graphic-3"/></fig><p hwp:id="p-20">The intermediate <italic toggle="yes">l<sub>i</sub></italic> thresholds are calculated as follows. First, a set of <italic toggle="yes">Z</italic> (an odd number, parameter of the method) random gene sets of size <italic toggle="yes">K</italic> are generated uniformly and ES values for them are calculated. The median value of the ES values is calculated and assigned to <italic toggle="yes">l</italic><sub>1</sub>. By construction, the probability <italic toggle="yes">P<sub>K</sub></italic>(<italic toggle="yes">γ</italic> ⩾ <italic toggle="yes">l</italic><sub>1</sub>) of a random gene set to have an ES value no less than <italic toggle="yes">l</italic><sub>1</sub> can be approximated as <inline-formula hwp:id="inline-formula-9"><alternatives hwp:id="alternatives-9"><inline-graphic xlink:href="060012v3_inline9.gif" hwp:id="inline-graphic-9"/></alternatives></inline-formula>. Next <inline-formula hwp:id="inline-formula-10"><alternatives hwp:id="alternatives-10"><inline-graphic xlink:href="060012v3_inline10.gif" hwp:id="inline-graphic-10"/></alternatives></inline-formula> generated gene sets with the ES values less than <italic toggle="yes">l</italic><sub>1</sub> are discarded, while <inline-formula hwp:id="inline-formula-11"><alternatives hwp:id="alternatives-11"><inline-graphic xlink:href="060012v3_inline11.gif" hwp:id="inline-graphic-11"/></alternatives></inline-formula> gene sets with the ES values greater than <italic toggle="yes">l</italic><sub>1</sub> are duplicated. This results in a sample of <italic toggle="yes">Z</italic> gene sets with the ES values no less than <italic toggle="yes">l</italic><sub>1</sub>, but the distribution is non-uniform. However, it can be made into a uniform sample with a Metropolis algorithm. On each Metropolis algorithm step each gene set sample is tried to be modified by swapping a random gene from the set with a gene outside of the set. The change is accepted if an enrichment score of the new set is no less then current threshold <italic toggle="yes">l</italic><sub>1</sub>, otherwise the change is rejected. Metropolis algorithm guarantees, that after enough steps the sample becomes close to uniformly distributed. Thus, a median of the enrichment scores (<italic toggle="yes">l</italic><sub>2</sub>) would correspond to probability of <inline-formula hwp:id="inline-formula-12"><alternatives hwp:id="alternatives-12"><inline-graphic xlink:href="060012v3_inline12.gif" hwp:id="inline-graphic-12"/></alternatives></inline-formula> for a gene set to have an enrichment score no less than <italic toggle="yes">l</italic><sub>2</sub> given it has an enrichment score no less than <italic toggle="yes">l</italic><sub>1</sub>:
<disp-formula hwp:id="disp-formula-1">
<alternatives hwp:id="alternatives-13"><graphic xlink:href="060012v3_ueqn1.gif" position="float" orientation="portrait" hwp:id="graphic-4"/></alternatives>
</disp-formula></p><p hwp:id="p-21">Which means
<disp-formula hwp:id="disp-formula-2">
<alternatives hwp:id="alternatives-14"><graphic xlink:href="060012v3_ueqn2.gif" position="float" orientation="portrait" hwp:id="graphic-5"/></alternatives>
</disp-formula></p><p hwp:id="p-22">The same procedure is applied to calculate the next <italic toggle="yes">l<sub>i</sub></italic> values.</p><p hwp:id="p-23">The iterations stop when <italic toggle="yes">l<sub>i</sub></italic> becomes greater than <italic toggle="yes">γ</italic>. On this iteration the probability of a random gene set to have a ES value no less than <italic toggle="yes">γ</italic> can be approximated as:
<disp-formula hwp:id="disp-formula-3">
<alternatives hwp:id="alternatives-15"><graphic xlink:href="060012v3_ueqn3.gif" position="float" orientation="portrait" hwp:id="graphic-6"/></alternatives>
</disp-formula></p><p hwp:id="p-24">When estimating small P-values it becomes practical to carry out the estimation in logscale. In particular, the values become practically unbiased both in median and mean sense and it becomes simple to estimate the approximation error and condifence intervals (see <xref ref-type="sec" rid="s2e4" hwp:id="xref-sec-16-1" hwp:rel-id="sec-16">section 2.5.4</xref>).</p><p hwp:id="p-25">The full formal description of the algorithm is available in the <xref ref-type="sec" rid="s2e" hwp:id="xref-sec-12-1" hwp:rel-id="sec-12">section 2.5</xref>.</p><p hwp:id="p-26">For the example dataset we show that P-values are as low as 10<sup>−26</sup> for some of the pathways and the results are consistent with FGSEA-simple P-values ran on 10<sup>8</sup> permutations (<xref ref-type="fig" rid="fig3" hwp:id="xref-fig-3-2" hwp:rel-id="F3">Fig 3b</xref>). Note, that FGSEA-multilevel calculation with sample size of Z=lOl took only 10 seconds working on a single thread while 10<sup>8</sup> permutations on FGSEA-simple took 40 minutes working in 32 threads.</p><p hwp:id="p-27">To further prove the approximation quality of FGSEA-multilevel algorithm we developed an exact method for calculating GSEA P-values, but limited to integer weights. The method is based on dynamic programming, the full description is given in <xref ref-type="sec" rid="s2d" hwp:id="xref-sec-9-1" hwp:rel-id="sec-9">section 2.4</xref>. The complexity of the algorithm is <italic toggle="yes">O</italic>(<italic toggle="yes">NKT</italic><sup>2</sup>), where <italic toggle="yes">N</italic> is the number of genes, <italic toggle="yes">K</italic> is the size of gene sets and <italic toggle="yes">T</italic> is the sum of the top <italic toggle="yes">K</italic> absolute values of gene-level statistics. With a number of optimizations this method allows to calculate P-values for rounded weights in the example dataset in a couple of hours.</p><p hwp:id="p-28">When run on the same integer weights FGSEA-multilevel and the exact method give highly concordant results (<xref ref-type="fig" rid="fig3" hwp:id="xref-fig-3-3" hwp:rel-id="F3">Fig 3c</xref>). Additionally, using the exact P-values, real approximation errors can be compared with the estimated ones. We show, that the FGSEA-multilevel error estimation are highly concordant with the real errors (<xref ref-type="fig" rid="fig3" hwp:id="xref-fig-3-4" hwp:rel-id="F3">Fig 3d</xref>) for a wide range of P-values (from 10<sup>−4</sup> to 10<sup>−100</sup>), gene set sizes (from 15 to 250) and sample sizes (from 101 to 1001).</p><p hwp:id="p-29">In practice FGSEA-multilevel method is combined with FGSEA-simple. First, for all the input pathways FGSEA-simple method can be run with a limited sample size. Next, for the pathways that have high relative error after FGSEA-simple (i.e. pathways with low p-values) FGSEA-multilevel method is executed. As many of the pathways in an input collection usually are not enriched, they have a relatively high P-value and will be batch-processed with a highly efficient FGSEA-simple algorithm with deterministic time boundaries. The more interesting pathways with lower P-values will then be processed with FGSEA-multilevel algorithm individually and the amount of processing time will depend on their P-values.</p><p hwp:id="p-30">As FGSEA allows to practically estimate the P-values for a large collections of gene sets, it can lead to a large number of statistically significant hits with high overlaps. To deal with this issue and make the representation of FGSEA results more concise we developed a procedure to filter the redundant gene sets. The procedure is similar to GO Trimming method [<xref ref-type="bibr" rid="c7" hwp:id="xref-ref-7-1" hwp:rel-id="ref-7">7</xref>] but is based on the Bayesian network construction approaches. It considers the significant pathways one by one and tries to remove gene sets that do not provide new information given some other pathway already present in the output. In this case, we consider a pathway <italic toggle="yes">P</italic><sub>1</sub> to give a new information given a pathway <italic toggle="yes">P</italic><sub>2</sub> if the P-value of pathway <italic toggle="yes">P</italic><sub>1</sub> in the universe of genes just from <italic toggle="yes">P</italic><sub>2</sub>, or just from genes out side of <italic toggle="yes">P</italic><sub>2</sub>, is less than some threshold. This procedure allows to filter redundant pathways without requirement of having any explicit hierarchy of pathways. The full description of the procedure is given in <xref ref-type="sec" rid="s2f" hwp:id="xref-sec-19-1" hwp:rel-id="sec-19">section 2.6</xref>. The table resulting from running FGSEA on the example dataset with filtering of redundant hits is shown on <xref ref-type="fig" rid="fig3" hwp:id="xref-fig-3-5" hwp:rel-id="F3">Fig 3e</xref>.</p><p hwp:id="p-31">Finally, we have explored FGSEA performance on the collection of 605 curated GEO datasets described earlier and the C5_BP pathway collection. Notably, it took less then a minute per dataset of running time to finish FGSEA analysis with the multilevel algorithm (<xref ref-type="fig" rid="fig4" hwp:id="xref-fig-4-1" hwp:rel-id="F4">Fig 4a</xref>) on a laptop with 4-core Intel Core i5 processor, with a median time of 8 seconds. Besides the multilevel algorithm, the same analysis was carried out with FGSEA-simple algorithm with the sampling depth values of <italic toggle="yes">n</italic> = 10/ 10<sup>4</sup> and 10<sup>5</sup>, and the reference implementation (Broad GSEA) with the sampling depth of 10<sup>4</sup>. For all these methods we compared the number of pathways reaching FDR level of 0.01: BH-adjusted P-values were used for FGSEA and reported Q-values (<italic toggle="yes">Broad Q-values</italic>) were used for the reference implementation (<xref ref-type="fig" rid="fig4" hwp:id="xref-fig-4-2" hwp:rel-id="F4">Fig 4b</xref>). The results reiterate that even sampling depth of 10<sup>5</sup> is not enough to detect statistically significant enriched pathways for some of the datasets when BH-adjustment procedure is used.</p><fig id="fig4" position="float" orientation="portrait" fig-type="figure" hwp:id="F4" hwp:rev-id="xref-fig-4-1 xref-fig-4-2 xref-fig-4-3 xref-fig-4-4"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;060012v3/FIG4</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F4</object-id><object-id pub-id-type="publisher-id">fig4</object-id><label>Figure 4:</label><caption hwp:id="caption-4"><p hwp:id="p-32">FGSEA method with the multilevel approach detects more statistically significant pathways compared to other GSEA implementations in a fraction of time. All plots represent data from analysis of the collection of 605 cureated GEO datasets with C5_BP used as a gene set collection, <bold>a</bold>, Wall clock time of running FGSEA. <bold>b</bold>, The number of detected statistically significant pathways for different adjusted P-value calculation procedures. Pathways with small BH-adjusted P-value after FGSEA-multilevel are shown in grey. Pathways with small BH-adjusted P-value after FGSEA-simple are shown in blue, orange and green, depending on the sampling depth. Pathways with small Q-values as reported by Broad GSEA are shown in red. <bold>c</bold>, Comparison of BH-adjusted P-values for FGSEA-multilevel and Q-values reported by Broad GSEA. For illustration purposes all values are capped at 10<sup>−5</sup>. <bold>d</bold>, Same as <italic toggle="yes">c</italic> but average pathway sizes are shown.</p></caption><graphic xlink:href="060012v3_fig4" position="float" orientation="portrait" hwp:id="graphic-7"/></fig><p hwp:id="p-33">The <italic toggle="yes">ad hoc</italic> procedure implemented in Broad GSEA aggregates ES values generated across different pathways increasing the sensitivity on some of the datasets compared to BH-adjusted P-values for the same sampling depth of 10<sup>4</sup>, however this increase in sensitivity comes with overall more conservative behavior. The total number of pathways reaching FDR level of 0.01 for Broad Q-values is 39467, which is only 60% of 65690 pathways for BH-adjustment P-values with the sampling depth of 10<sup>4</sup> and 48% of 81628 pathways for the multilevel algorithm. We further characterized this behavior by directly comparing Broad Q-values with BH-adjusted P-values and have shown that Broad Q-values are individually more conservative (<xref ref-type="fig" rid="fig4" hwp:id="xref-fig-4-3" hwp:rel-id="F4">Fig 4c</xref>) in a pathway size dependent manner (<xref ref-type="fig" rid="fig4" hwp:id="xref-fig-4-4" hwp:rel-id="F4">Fig 4d</xref>).</p><p hwp:id="p-34">To conclude, here we have presented FGSEA method for fast preranked gene set enrichment analysis. The method allows to routinely estimate even very low P-values and can be used with conjunction with standard multiple hypothesis testing correction methods, such as Benjamini-Hochberg procedure. This, in turn, leads to better sensitivity and the ability to detect significant pathways in hard cases, where other implementations fail. FGSEA method is freely available as an R package at Bioconductor (<ext-link l:rel="related" l:ref-type="uri" l:ref="http://bioconductor.org/packages/fgsea" ext-link-type="uri" xlink:href="http://bioconductor.org/packages/fgsea" hwp:id="ext-link-5">http://bioconductor.org/packages/fgsea</ext-link>) and on GitHub (<ext-link l:rel="related" l:ref-type="uri" l:ref="https://github.com/ctlab/fgsea" ext-link-type="uri" xlink:href="https://github.com/ctlab/fgsea" hwp:id="ext-link-6">https://github.com/ctlab/fgsea</ext-link>).</p></sec><sec id="s2" hwp:id="sec-2"><label>2</label><title hwp:id="title-5">Methods</title><sec id="s2a" hwp:id="sec-3" hwp:rev-id="xref-sec-3-1"><label>2.1</label><title hwp:id="title-6">Formal definitions</title><p hwp:id="p-35">The preranked gene set enrichment analysis takes as input two objects: an array of gene-level statistic values <italic toggle="yes">S</italic> for the genes <italic toggle="yes">U</italic> = {1, 2,…, <italic toggle="yes">N</italic>} and a list of query gene sets (pathways) <italic toggle="yes">P</italic>. The goal of the analysis is to determine which of the gene sets from <italic toggle="yes">P</italic> has a non-random behavior.</p><p hwp:id="p-36">The statistic array <italic toggle="yes">S</italic> of the size |<italic toggle="yes">S</italic>| = <italic toggle="yes">N</italic> for each gene <italic toggle="yes">i</italic> ∈ <italic toggle="yes">U</italic> contains a value <inline-formula hwp:id="inline-formula-13"><alternatives hwp:id="alternatives-16"><inline-graphic xlink:href="060012v3_inline13.gif" hwp:id="inline-graphic-13"/></alternatives></inline-formula> that characterizes the gene behavior in a considered biological process. Commonly, if <italic toggle="yes">S<sub>i</sub></italic> &gt; 0 the expression of gene <italic toggle="yes">i</italic> goes up on treatment compared to control and <italic toggle="yes">S<sub>i</sub></italic> &lt; 0 means that the expression goes down. Absolute values |<italic toggle="yes">S<sub>i</sub></italic>| represent magnitude of the change. Array <italic toggle="yes">S</italic> is sorted in a decreasing order: <italic toggle="yes">S<sub>i</sub></italic> &gt; <italic toggle="yes">S<sub>j</sub></italic> for <italic toggle="yes">i</italic> &lt; <italic toggle="yes">j</italic>. The value of <italic toggle="yes">N</italic> in practice is about 10000–20000.</p><p hwp:id="p-37">The list of gene sets <italic toggle="yes">P</italic> = {<italic toggle="yes">P</italic><sub>1</sub>, <italic toggle="yes">P</italic><sub>2</sub>,…, <italic toggle="yes">P<sub>M</sub></italic>} of length <italic toggle="yes">M</italic> usually contains groups of genes that are commonly regulated in some biological process. We assume that the gene sets <italic toggle="yes">P<sub>i</sub></italic> are ordered by their size (denoted as <italic toggle="yes">K<sub>i</sub></italic>): <italic toggle="yes">K</italic><sub>1</sub> ⩽ <italic toggle="yes">K</italic><sub>2</sub> ⩽ … ⩽ <italic toggle="yes">K<sub>M</sub></italic> = <italic toggle="yes">K</italic>. Usually only relatively small gene sets are considered with <italic toggle="yes">K</italic> ≈ 500 genes.</p><p hwp:id="p-38">To quantify a co-regulation of genes in a gene set <italic toggle="yes">p</italic> Subramanian <italic toggle="yes">et al</italic>.[<xref ref-type="bibr" rid="c1" hwp:id="xref-ref-1-4" hwp:rel-id="ref-1">1</xref>] introduced a gene set enrichment score function <italic toggle="yes">s<sub>r</sub></italic>(<italic toggle="yes">p</italic>) that uses gene rankings (values of <italic toggle="yes">S</italic>). The more positive is the value of <italic toggle="yes">s<sub>r</sub></italic>(<italic toggle="yes">p</italic>) the more enriched the gene set is in the positively-regulated genes (with <italic toggle="yes">S<sub>i</sub></italic> &gt; 0). Accordingly, negative <italic toggle="yes">s<sub>r</sub></italic>(<italic toggle="yes">p</italic>) corresponds to enrichment in the negatively regulated genes.</p><p hwp:id="p-39">Value of <italic toggle="yes">s<sub>r</sub></italic>(<italic toggle="yes">p</italic>) can be calculated as follows. Let <italic toggle="yes">k</italic> = |<italic toggle="yes">p</italic>|, NS = Σ<sub><italic toggle="yes">i</italic>∈<italic toggle="yes">p</italic></sub>|<italic toggle="yes">S<sub>i</sub></italic>|. Let al so ES be an array specified by the following formula:
<disp-formula hwp:id="disp-formula-4">
<alternatives hwp:id="alternatives-17"><graphic xlink:href="060012v3_ueqn4.gif" position="float" orientation="portrait" hwp:id="graphic-8"/></alternatives>
</disp-formula></p><p hwp:id="p-40">The value of <italic toggle="yes">s<sub>r</sub></italic>(<italic toggle="yes">p</italic>) corresponds to the largest by the absolute value entry of ES:
<disp-formula hwp:id="disp-formula-5">
<alternatives hwp:id="alternatives-18"><graphic xlink:href="060012v3_ueqn5.gif" position="float" orientation="portrait" hwp:id="graphic-9"/></alternatives>
</disp-formula></p><p hwp:id="p-41">For convenience, we also introduce the following notation:
<disp-formula hwp:id="disp-formula-6">
<alternatives hwp:id="alternatives-19"><graphic xlink:href="060012v3_ueqn6.gif" position="float" orientation="portrait" hwp:id="graphic-10"/></alternatives>
</disp-formula></p><p hwp:id="p-42">From these two values it easy to find value of <italic toggle="yes">s<sub>r</sub></italic>(<italic toggle="yes">p</italic>), which is equal to <inline-formula hwp:id="inline-formula-14"><alternatives hwp:id="alternatives-20"><inline-graphic xlink:href="060012v3_inline14.gif" hwp:id="inline-graphic-14"/></alternatives></inline-formula> if <inline-formula hwp:id="inline-formula-15"><alternatives hwp:id="alternatives-21"><inline-graphic xlink:href="060012v3_inline15.gif" hwp:id="inline-graphic-15"/></alternatives></inline-formula> or <inline-formula hwp:id="inline-formula-16"><alternatives hwp:id="alternatives-22"><inline-graphic xlink:href="060012v3_inline16.gif" hwp:id="inline-graphic-16"/></alternatives></inline-formula> otherwise.</p><p hwp:id="p-43">Often we will consider only the positive values of the gene set enrichment score function since:
<disp-formula hwp:id="disp-formula-7">
<alternatives hwp:id="alternatives-23"><graphic xlink:href="060012v3_ueqn7.gif" position="float" orientation="portrait" hwp:id="graphic-11"/></alternatives>
</disp-formula>
where <inline-formula hwp:id="inline-formula-17"><alternatives hwp:id="alternatives-24"><inline-graphic xlink:href="060012v3_inline17.gif" hwp:id="inline-graphic-17"/></alternatives></inline-formula> and <inline-formula hwp:id="inline-formula-18"><alternatives hwp:id="alternatives-25"><inline-graphic xlink:href="060012v3_inline18.gif" hwp:id="inline-graphic-18"/></alternatives></inline-formula> corresponds to the gene set enrichment score function for array <italic toggle="yes">S</italic>′ such that <inline-formula hwp:id="inline-formula-19"><alternatives hwp:id="alternatives-26"><inline-graphic xlink:href="060012v3_inline19.gif" hwp:id="inline-graphic-19"/></alternatives></inline-formula>.</p><p hwp:id="p-44">Next, following Subramanian <italic toggle="yes">et al</italic> for a pathway <italic toggle="yes">p</italic> we define GSEA P-value as:
<disp-formula hwp:id="disp-formula-8">
<alternatives hwp:id="alternatives-27"><graphic xlink:href="060012v3_ueqn8.gif" position="float" orientation="portrait" hwp:id="graphic-12"/></alternatives>
</disp-formula>
where <italic toggle="yes">q</italic> is a random gene set of size <italic toggle="yes">k</italic>.</p></sec><sec id="s2b" hwp:id="sec-4" hwp:rev-id="xref-sec-4-1 xref-sec-4-2"><label>2.2</label><title hwp:id="title-7">The datasets</title><p hwp:id="p-45">A collection of 605 curated datasets was generated from a set of all curated datasets (GDS) in Gene Expression Omnibus. Only the datasets with two biological conditions were kept. Differential expression was done using limma. The moderated t-statistic was used for gene ranking. Only top 10000 genes by average expression were used in ranking. The final rankings are available at <ext-link l:rel="related" l:ref-type="uri" l:ref="https://ctlab.itmo.ru/files/software/fgsea/geo_ranks/" ext-link-type="uri" xlink:href="https://ctlab.itmo.ru/files/software/fgsea/geo_ranks/" hwp:id="ext-link-7">https://ctlab.itmo.ru/files/software/fgsea/geo_ranks/</ext-link>.</p><p hwp:id="p-46">Pathway collections C2_REACTOME, C5_BP, C2, C5, MSigDB were obtained via msigdbr package. LINCS perturbation collection was downloaded from Enrichr web-site. The corresponding gmt files are available at <ext-link l:rel="related" l:ref-type="uri" l:ref="https://ctlab.itmo.ru/files/software/fgsea/gmts/" ext-link-type="uri" xlink:href="https://ctlab.itmo.ru/files/software/fgsea/gmts/" hwp:id="ext-link-8">https://ctlab.itmo.ru/files/software/fgsea/gmts/</ext-link>.</p><p hwp:id="p-47">As the example ranking ThO vs Thl comparison was used from dataset GSE14308 [<xref ref-type="bibr" rid="c4" hwp:id="xref-ref-4-2" hwp:rel-id="ref-4">4</xref>], The differential expression was calculated using limma [<xref ref-type="bibr" rid="c8" hwp:id="xref-ref-8-1" hwp:rel-id="ref-8">8</xref>], Only top 12000 genes by mean expression were used. Limma t-statistic was used as gene-level statistic. The script to generate rankings is available on GitHub: <ext-link l:rel="related" l:ref-type="uri" l:ref="https://github.com/ctlab/fgsea/blob/master/inst/gen_gene_ranks.R" ext-link-type="uri" xlink:href="https://github.com/ctlab/fgsea/blob/master/inst/gen_gene_ranks.R" hwp:id="ext-link-9">https://github.com/ctlab/fgsea/blob/master/inst/gen_gene_ranks.R</ext-link>.</p><p hwp:id="p-48">Reactome [<xref ref-type="bibr" rid="c5" hwp:id="xref-ref-5-2" hwp:rel-id="ref-5">5</xref>] database was used as an example collection via reactome.db R package. For the analysis only the pathways of the size from 15 to 500 were used. The script to generate pathway collection is available on GitHub: <ext-link l:rel="related" l:ref-type="uri" l:ref="https://github.com/ctlab/fgsea/blob/master/inst/gene_reactome_pathwavs.R" ext-link-type="uri" xlink:href="https://github.com/ctlab/fgsea/blob/master/inst/gene_reactome_pathwavs.R" hwp:id="ext-link-10">https://github.com/ctlab/fgsea/blob/master/inst/gene_reactome_pathwavs.R</ext-link></p></sec><sec id="s2c" hwp:id="sec-5" hwp:rev-id="xref-sec-5-1"><label>2.3</label><title hwp:id="title-8">FGSEA-simple: an algorithm for fast calculation of GSEA P-values simultaneously for many pathways</title><p hwp:id="p-49">In this section we describe an algorithm for fast estimation of GSEA P-values simultaneously for a collection of pathways <italic toggle="yes">P</italic>. There, for each pathway <italic toggle="yes">p</italic> a set of <italic toggle="yes">n</italic> uniformly random gene sets <italic toggle="yes">q<sub>i</sub></italic> are considered. Then P-value is estimated as:
<disp-formula hwp:id="disp-formula-9">
<alternatives hwp:id="alternatives-28"><graphic xlink:href="060012v3_ueqn9.gif" position="float" orientation="portrait" hwp:id="graphic-13"/></alternatives>
</disp-formula>
for positively enriched pathway <italic toggle="yes">p</italic> and as:
<disp-formula hwp:id="disp-formula-10">
<alternatives hwp:id="alternatives-29"><graphic xlink:href="060012v3_ueqn10.gif" position="float" orientation="portrait" hwp:id="graphic-14"/></alternatives>
</disp-formula>
for negatively enriched pathway. These two formulas follow Subramanian <italic toggle="yes">et al</italic>. implementation, except of +1 terms, which are recommended by Phipson and Smyth [<xref ref-type="bibr" rid="c9" hwp:id="xref-ref-9-1" hwp:rel-id="ref-9">9</xref>], Otherwise, the nominal P-values from FGSEA-simple and reference implementation are indistinguishable, however FGSEA-simple works orders of magnitude faster.</p><sec id="s2c1" hwp:id="sec-6"><label>2.3.1</label><title hwp:id="title-9">Cumulative statistic calculation for the mean statistic</title><p hwp:id="p-50">Let first describe the idea of the proposed algorithm on a simple mean statistic <italic toggle="yes">s<sub>m</sub></italic>:
<disp-formula hwp:id="disp-formula-11">
<alternatives hwp:id="alternatives-30"><graphic xlink:href="060012v3_ueqn11.gif" position="float" orientation="portrait" hwp:id="graphic-15"/></alternatives>
</disp-formula></p><p hwp:id="p-51">The main idea of the algorithm is to reuse sampling for different query gene sets. This can be done due to the fact that for an estimation of null distributions samples have to be independent only for a specific gene set size, while they can be dependent between different sizes.</p><p hwp:id="p-52">Instead of generating <italic toggle="yes">nM</italic> independent random gene sets: <italic toggle="yes">n</italic> for each of <italic toggle="yes">M</italic> input gene sets, we will generate only <italic toggle="yes">n</italic> random gene sets of size <italic toggle="yes">K</italic>. Let <italic toggle="yes">π<sub>i</sub></italic> be an <italic toggle="yes">i</italic>-th random gene set of size <italic toggle="yes">K</italic>. From that gene set we can generate gene sets for a all the query pathways <italic toggle="yes">P<sub>j</sub></italic> by using its prefix: <italic toggle="yes">π<sub>i,j</sub></italic> = <italic toggle="yes">π<sub>i</sub></italic>[1..<italic toggle="yes">K<sub>j</sub></italic>].</p><p hwp:id="p-53">The next step is to calculate the enrichment scores for all gene sets <italic toggle="yes">π<sub>i,j</sub></italic>. Instead of calculating enrichment scores separately for each gene set we will calculate simultaneously scores for all <italic toggle="yes">π<sub>i,j</sub></italic> for a fixed <italic toggle="yes">i</italic>. Using a simple procedure it can be done in Θ(<italic toggle="yes">K</italic>) time.</p><p hwp:id="p-54">Let us find enrichment scores for all prefixes of <italic toggle="yes">π<sub>i</sub></italic>. This can be done by element-wise dividing of cumulative sums array by the length of the corresponding prefix:
<disp-formula hwp:id="disp-formula-12">
<alternatives hwp:id="alternatives-31"><graphic xlink:href="060012v3_ueqn12.gif" position="float" orientation="portrait" hwp:id="graphic-16"/></alternatives>
</disp-formula></p><p hwp:id="p-55">Selecting only the required prefixes takes an additional Θ(<italic toggle="yes">m</italic>) time.</p><p hwp:id="p-56">The described procedure allows to find P-values for all query gene sets in Θ(<italic toggle="yes">n</italic>(<italic toggle="yes">K</italic> + <italic toggle="yes">m</italic>)) time. This is about min(<italic toggle="yes">K, m</italic>) times faster than the straightforward procedure.</p></sec><sec id="s2c2" hwp:id="sec-7"><label>2.3.2</label><title hwp:id="title-10">Cumulative statistic calculation for enrichment score</title><p hwp:id="p-57">For the enrichment score <italic toggle="yes">S<sub>r</sub></italic> we use the similar idea as above: we will also be sampling only gene sets of size <italic toggle="yes">K</italic> and from that sample will calculate statistic values for all the other sizes. However, calculation of the cumulative statistic values for the subsamples is more complex in this case. In this section we only be considering the positive mode of enrichment statistic <inline-formula hwp:id="inline-formula-20"><alternatives hwp:id="alternatives-32"><inline-graphic xlink:href="060012v3_inline20.gif" hwp:id="inline-graphic-20"/></alternatives></inline-formula>.</p><p hwp:id="p-58">It is helpful to look at enrichment score from a geometric point of view. Let us consider for a pathway <italic toggle="yes">p</italic> of size |<italic toggle="yes">p</italic>| = <italic toggle="yes">k</italic> a graph of <italic toggle="yes">N</italic> + 1 points (<xref ref-type="fig" rid="figS1" hwp:id="xref-fig-5-1" hwp:rel-id="F5">Fig. S1</xref>) with the coordinates (<italic toggle="yes">x<sub>i</sub>, y<sub>i</sub></italic>) for 0 ⩽ <italic toggle="yes">i</italic> ⩽ <italic toggle="yes">N</italic> such that:
<disp-formula id="eqn1" hwp:id="disp-formula-13">
<alternatives hwp:id="alternatives-33"><graphic xlink:href="060012v3_eqn1.gif" position="float" orientation="portrait" hwp:id="graphic-17"/></alternatives>
</disp-formula>
<disp-formula id="eqn2" hwp:id="disp-formula-14">
<alternatives hwp:id="alternatives-34"><graphic xlink:href="060012v3_eqn2.gif" position="float" orientation="portrait" hwp:id="graphic-18"/></alternatives>
</disp-formula>
<disp-formula id="eqn3" hwp:id="disp-formula-15">
<alternatives hwp:id="alternatives-35"><graphic xlink:href="060012v3_eqn3.gif" position="float" orientation="portrait" hwp:id="graphic-19"/></alternatives>
</disp-formula></p><fig id="figS1" position="float" orientation="portrait" fig-type="figure" hwp:id="F5" hwp:rev-id="xref-fig-5-1 xref-fig-5-2"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;060012v3/FIGS1</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F5</object-id><object-id pub-id-type="publisher-id">figS1</object-id><label>Figure S1:</label><caption hwp:id="caption-5"><p hwp:id="p-168">A graph that corresponds to a calculation of enrichment score. Each breakpoint on a graph corresponds to a gene present in the pathway. Dotted lines cross at a point which is the farthest up from a diagonal (dashed line). This point correspond to gene <italic toggle="yes">i</italic><sup>+</sup>, where the maximal value of ES<sub><italic toggle="yes">i</italic></sub> is reached.</p></caption><graphic xlink:href="060012v3_figS1" position="float" orientation="portrait" hwp:id="graphic-51"/></fig><p hwp:id="p-59">The calculation of <inline-formula hwp:id="inline-formula-21"><alternatives hwp:id="alternatives-36"><inline-graphic xlink:href="060012v3_inline21.gif" hwp:id="inline-graphic-21"/></alternatives></inline-formula> corresponds to finding the point farthest up from a diagonal ((<italic toggle="yes">x</italic><sub>0</sub>, <italic toggle="yes">y</italic><sub>0</sub>), (<italic toggle="yes">x<sub>N</sub>, y<sub>N</sub></italic>)). Indeed, it is easy to see that <italic toggle="yes">x<sub>N</sub></italic> = <italic toggle="yes">N</italic> – |<italic toggle="yes">p</italic>| = <italic toggle="yes">N</italic> – <italic toggle="yes">K</italic> and <italic toggle="yes">y<sub>N</sub></italic> = Σ<sub><italic toggle="yes">j</italic>∈<italic toggle="yes">p</italic></sub>|<italic toggle="yes">S<sub>j</sub></italic>| = NS, while the individual enrichment scores ES<sub><italic toggle="yes">i</italic></sub> can be calculated as <inline-formula hwp:id="inline-formula-22"><alternatives hwp:id="alternatives-37"><inline-graphic xlink:href="060012v3_inline22.gif" hwp:id="inline-graphic-22"/></alternatives></inline-formula>. Value of ES<sub><italic toggle="yes">i</italic></sub> is proportional to the directed distance from the line going through (<italic toggle="yes">x</italic><sub>0</sub>, <italic toggle="yes">y</italic><sub>0</sub>) and (<italic toggle="yes">x<sub>N</sub>, y<sub>N</sub></italic>) to the point (<italic toggle="yes">x<sub>i</sub>, y<sub>i</sub></italic>).</p><p hwp:id="p-60">Let us fix a sample <italic toggle="yes">π</italic> of size <italic toggle="yes">K</italic>. To efficiently calculate cumulative values <inline-formula hwp:id="inline-formula-23"><alternatives hwp:id="alternatives-38"><inline-graphic xlink:href="060012v3_inline23.gif" hwp:id="inline-graphic-23"/></alternatives></inline-formula> for all <italic toggle="yes">k</italic> ⩽ <italic toggle="yes">K</italic> we need a fast method of updating the farthest point when a new gene is added. In that case we can add genes from <italic toggle="yes">π</italic> one by one and calculate values <inline-formula hwp:id="inline-formula-24"><alternatives hwp:id="alternatives-39"><inline-graphic xlink:href="060012v3_inline24.gif" hwp:id="inline-graphic-24"/></alternatives></inline-formula> from the corresponding maximal distances.</p><p hwp:id="p-61">Because we are calculating values for <italic toggle="yes">π</italic>[1..<italic toggle="yes">k</italic>] for <italic toggle="yes">k</italic> ⩽ <italic toggle="yes">K</italic> we know in advance which <italic toggle="yes">K</italic> genes will be added. This allows us to consider <italic toggle="yes">K</italic> + 1 points instead of <italic toggle="yes">N</italic> + 1 for each iteration <italic toggle="yes">k</italic>. Let array <italic toggle="yes">o</italic> of size <italic toggle="yes">K</italic> contain the sorted order of genes in <italic toggle="yes">π</italic>: that is, <italic toggle="yes">π</italic><sub><italic toggle="yes">o</italic><sub>1</sub></sub> is the minimal among <italic toggle="yes">π, π</italic><sub><italic toggle="yes">θ</italic><sub>2</sub></sub> is the second minimal and so on. The coordinates can be calculated as follows:
<disp-formula id="eqn4" hwp:id="disp-formula-16">
<alternatives hwp:id="alternatives-40"><graphic xlink:href="060012v3_eqn4.gif" position="float" orientation="portrait" hwp:id="graphic-20"/></alternatives>
</disp-formula>
<disp-formula id="eqn5" hwp:id="disp-formula-17">
<alternatives hwp:id="alternatives-41"><graphic xlink:href="060012v3_eqn5.gif" position="float" orientation="portrait" hwp:id="graphic-21"/></alternatives>
</disp-formula>
<disp-formula id="eqn6" hwp:id="disp-formula-18">
<alternatives hwp:id="alternatives-42"><graphic xlink:href="060012v3_eqn6.gif" position="float" orientation="portrait" hwp:id="graphic-22"/></alternatives>
</disp-formula>
where we set <italic toggle="yes">π</italic><sub><italic toggle="yes">θ</italic><sub>0</sub></sub> to be zero.</p><p hwp:id="p-62">It can be shown that finding the farthest up point among (4)–(6) is equivalent to finding the farthest up point among (1)–(3) with <inline-formula hwp:id="inline-formula-25"><alternatives hwp:id="alternatives-43"><inline-graphic xlink:href="060012v3_inline25.gif" hwp:id="inline-graphic-25"/></alternatives></inline-formula> being equal to <inline-formula hwp:id="inline-formula-26"><alternatives hwp:id="alternatives-44"><inline-graphic xlink:href="060012v3_inline26.gif" hwp:id="inline-graphic-26"/></alternatives></inline-formula> calculated for <italic toggle="yes">p</italic> = <italic toggle="yes">π</italic>[1..<italic toggle="yes">k</italic>]. Consider <inline-formula hwp:id="inline-formula-27"><alternatives hwp:id="alternatives-45"><inline-graphic xlink:href="060012v3_inline27.gif" hwp:id="inline-graphic-27"/></alternatives></inline-formula>. By the definition of <italic toggle="yes">x</italic> it is equal to:
<disp-formula hwp:id="disp-formula-19">
<alternatives hwp:id="alternatives-46"><graphic xlink:href="060012v3_ueqn13.gif" position="float" orientation="portrait" hwp:id="graphic-23"/></alternatives>
</disp-formula></p><p hwp:id="p-63">By the definition of <italic toggle="yes">o</italic>, in the interval [<italic toggle="yes">π</italic><sub><italic toggle="yes">o</italic><sub><italic toggle="yes">i</italic>-1</sub></sub> + 1, <italic toggle="yes">π<sub>o<sub>i</sub></sub></italic> – 1] there are no genes from <italic toggle="yes">π</italic> and, thus, from <italic toggle="yes">π</italic>[1..<italic toggle="yes">k</italic>]. Thus we can replace the sum with its last member:
<disp-formula hwp:id="disp-formula-20">
<alternatives hwp:id="alternatives-47"><graphic xlink:href="060012v3_ueqn14.gif" position="float" orientation="portrait" hwp:id="graphic-24"/></alternatives>
</disp-formula></p><p hwp:id="p-64">We got the same difference as in (5).</p><p hwp:id="p-65">Now consider <inline-formula hwp:id="inline-formula-28"><alternatives hwp:id="alternatives-48"><inline-graphic xlink:href="060012v3_inline28.gif" hwp:id="inline-graphic-28"/></alternatives></inline-formula>. By the definition of <italic toggle="yes">y</italic> it is equal to:
<disp-formula hwp:id="disp-formula-21">
<alternatives hwp:id="alternatives-49"><graphic xlink:href="060012v3_ueqn15.gif" position="float" orientation="portrait" hwp:id="graphic-25"/></alternatives>
</disp-formula></p><p hwp:id="p-66">Again, in the interval [<italic toggle="yes">π</italic><sub><italic toggle="yes">o</italic><sub><italic toggle="yes">i</italic>−1</sub></sub> + 1, <italic toggle="yes">π<sub>o<sub>i</sub></sub></italic> – 1] there are no genes from <italic toggle="yes">π</italic>[1..<italic toggle="yes">k</italic>]. Thus we can replace the sum with only the last member:
<disp-formula hwp:id="disp-formula-22">
<alternatives hwp:id="alternatives-50"><graphic xlink:href="060012v3_ueqn16.gif" position="float" orientation="portrait" hwp:id="graphic-26"/></alternatives>
</disp-formula></p><p hwp:id="p-67">We got the same difference as in (6).</p><p hwp:id="p-68">We do not need to consider other points, because points from <italic toggle="yes">o</italic><sub><italic toggle="yes">i</italic>−1</sub> to <italic toggle="yes">o<sub>i</sub></italic> − 1 have the same <italic toggle="yes">y</italic> coordinate and <italic toggle="yes">o</italic><sub><italic toggle="yes">i</italic>−1</sub> is the leftmost of them. Thus, when at least one gene is added the diagonal ((<italic toggle="yes">x</italic><sub>0</sub>, <italic toggle="yes">y</italic><sub>0</sub>), (<italic toggle="yes">x<sub>N</sub>, y<sub>N</sub></italic>)) is not horizontal and <italic toggle="yes">o</italic><sub><italic toggle="yes">i</italic>−1</sub> is the farthest point among <italic toggle="yes">o</italic><sub><italic toggle="yes">i</italic>−1</sub>,…, <italic toggle="yes">o<sub>i</sub></italic> − 1.</p><p hwp:id="p-69">Now let consider what happens with the enrichment score graph when gene <italic toggle="yes">π<sub>k</sub></italic> is added to the query set <italic toggle="yes">π</italic>[1..<italic toggle="yes">k</italic> – 1] (<xref ref-type="fig" rid="figS2" hwp:id="xref-fig-6-1" hwp:rel-id="F6">Fig. S2</xref>). Let <italic toggle="yes">r<sub>k</sub></italic> be a rank of gene <italic toggle="yes">π</italic><sub>2</sub> among genes <italic toggle="yes">π</italic>, then coordinate of points (<italic toggle="yes">x<sub>i</sub>, y<sub>i</sub></italic>) for <italic toggle="yes">i</italic> &lt; <italic toggle="yes">r<sub>k</sub></italic> do not change, while all (<italic toggle="yes">x<sub>i</sub>, y<sub>i</sub></italic>) for <italic toggle="yes">i</italic> ⩾ <italic toggle="yes">r<sub>k</sub></italic> are changed on (Δ<sub><italic toggle="yes">x</italic></sub>, Δ<sub><italic toggle="yes">y</italic></sub>) = (−1, |<italic toggle="yes">S<sub>π<sub>k</sub></sub></italic>|).</p><fig id="figS2" position="float" orientation="portrait" fig-type="figure" hwp:id="F6" hwp:rev-id="xref-fig-6-1"><object-id pub-id-type="other" hwp:sub-type="pisa">biorxiv;060012v3/FIGS2</object-id><object-id pub-id-type="other" hwp:sub-type="slug">F6</object-id><object-id pub-id-type="publisher-id">figS2</object-id><label>Figure S2:</label><caption hwp:id="caption-6"><p hwp:id="p-169">Update of an enrichment score graph when gene <italic toggle="yes">π<sub>k</sub></italic> ≈ 800 is added. Only a fragment is shown. Black graph corresponds to a graph for gene set <italic toggle="yes">π</italic>[1..<italic toggle="yes">k</italic> − 1], gray graph corresponds to <italic toggle="yes">π</italic>[1..<italic toggle="yes">k</italic>], A part of the graph to the left of <italic toggle="yes">x</italic> = <italic toggle="yes">x<sub>r<sub>k</sub></sub></italic> does not change and the other part is shifted to the top-left corner. The diagonal ((<italic toggle="yes">x</italic><sub>0</sub>, <italic toggle="yes">y</italic><sub>0</sub>), (<italic toggle="yes">x<sub>N</sub>, y<sub>N</sub></italic>)) is rotated counterclockwise.</p></caption><graphic xlink:href="060012v3_figS2" position="float" orientation="portrait" hwp:id="graphic-52"/></fig><p hwp:id="p-70">To make fast incremental updates we will decompose the problem into multiple smaller ones. For simplicity we assume that <italic toggle="yes">K</italic> + 1 is an exact square of an integer <italic toggle="yes">b</italic>. Let split <italic toggle="yes">K</italic> +1 points into <italic toggle="yes">b</italic> consecutive blocks of the size <italic toggle="yes">b</italic>:<inline-formula hwp:id="inline-formula-29"><alternatives hwp:id="alternatives-51"><inline-graphic xlink:href="060012v3_inline29.gif" hwp:id="inline-graphic-29"/></alternatives></inline-formula> and so on.</p><p hwp:id="p-71">For each of <italic toggle="yes">b</italic> blocks we will store and update the farthest up point from the diagonal. When we know for each block its farthest point we can find the globally farthest point by a simple pass in <italic toggle="yes">O</italic>(<italic toggle="yes">b</italic>) time.</p><p hwp:id="p-72">Next, we show how to update the farthest points in blocks in amortized time <italic toggle="yes">O</italic>(<italic toggle="yes">b</italic>). This taken together with one <italic toggle="yes">O</italic>(<italic toggle="yes">b</italic>) pass will get us an algorithm to update the globally farthest point in amortized <italic toggle="yes">O</italic>(<italic toggle="yes">b</italic>) time.</p><p hwp:id="p-73">Below we use <italic toggle="yes">c</italic> = ⌊<italic toggle="yes">r<sub>k</sub></italic>/<italic toggle="yes">b</italic>⌋ as an index of a block where gene <italic toggle="yes">π<sub>k</sub></italic> belongs, where <italic toggle="yes">r<sub>k</sub></italic> is the ranking of the genes from <italic toggle="yes">π</italic>, i.e. <italic toggle="yes">r<sub>o<sub>i</sub></sub></italic> = <italic toggle="yes">i</italic>.</p><p hwp:id="p-74">First, we describe the procedure to update point coordinates. We will store <italic toggle="yes">x<sub>i</sub></italic> coordinates using two vectors: <italic toggle="yes">B</italic> of size <italic toggle="yes">b</italic> and D of size <italic toggle="yes">K</italic> + 1, such th at <italic toggle="yes">x<sub>i</sub></italic> = <italic toggle="yes">B<sub>i/b</sub></italic> + <italic toggle="yes">D<sub>i</sub></italic>. When gene <italic toggle="yes">π<sub>k</sub></italic> is added all <italic toggle="yes">x<sub>i</sub></italic> for <italic toggle="yes">i</italic> ⩾ <italic toggle="yes">r<sub>k</sub></italic> are decremented by one. To reflect this we will decrement all <italic toggle="yes">B<sub>j</sub></italic> for <italic toggle="yes">j</italic> &gt; <italic toggle="yes">c</italic> and decrement all <italic toggle="yes">D<sub>i</sub></italic> for <italic toggle="yes">r<sub>k</sub></italic> ⩽ <italic toggle="yes">i</italic> &lt; <italic toggle="yes">cb</italic>. The update takes <italic toggle="yes">O</italic>(<italic toggle="yes">b</italic>) time. After this update procedure we can get value <italic toggle="yes">x<sub>i</sub></italic> in <italic toggle="yes">O</italic>(1) time. The same procedure is applied for <italic toggle="yes">y</italic> coordinates.</p><p hwp:id="p-75">Second, for each block we will maintain an upper part of its convex hull. Having convex hull is useful because the farthest point in block always lays on its convex hull. All blocks except <italic toggle="yes">c</italic> have the points either not changed or shifted simultaneously on the same value. That means that the lists of points on the convex hulls for these blocks remain unchanged. For the block <italic toggle="yes">c</italic> we can reconstruct convex hull from scratch using Graham scan algorithm [<xref ref-type="bibr" rid="c10" hwp:id="xref-ref-10-1" hwp:rel-id="ref-10">10</xref>].</p><p hwp:id="p-76">Because the points are already sorted by <italic toggle="yes">x</italic> coordinate, this reconstruction takes <italic toggle="yes">O</italic>(<italic toggle="yes">b</italic>) time. In total, it takes <italic toggle="yes">O</italic>(<italic toggle="yes">b</italic>) time to update the convex hulls.</p><p hwp:id="p-77">Third, the farthest points in blocks can be updated using the stored convex hulls. Consider a block where the convex hull was not changed (every block except, possibly, block <italic toggle="yes">c</italic>). Because diagonal always rotates in the same counterclockwise direction, the farthest point in block on iteration <italic toggle="yes">k</italic> either stays the same or moves on the convex hull to the left of the farthest point on the (<italic toggle="yes">k</italic> − 1)-th iteration. Thus, for each such block we can compare current farthest point with its left neighbor on the convex hull and update the point if necessary. It is repeated until the next neighbor is closer to the diagonal than the current farthest point. In the block c we just find the farthest point in a single pass by the points on the convex hull.</p><p hwp:id="p-78">To show that the updating the farthest points takes <italic toggle="yes">O</italic>(<italic toggle="yes">b</italic>) amortized time we will use potential method. Let a potential after adding <italic toggle="yes">k</italic>-th gene Φ<sub><italic toggle="yes">k</italic></sub> be a sum of relative indexes of the farthest points for all the blocks. As there are <italic toggle="yes">b</italic> blocks of size <italic toggle="yes">b</italic> the sum of relative indexes lies between 0 and <italic toggle="yes">b</italic><sup>2</sup>. Thus, Φ<sub><italic toggle="yes">k</italic></sub> = <italic toggle="yes">O</italic>(<italic toggle="yes">b</italic><sup>2</sup>). For an update of all <italic toggle="yes">b</italic> − 1 blocks except <italic toggle="yes">c</italic> we need to make <italic toggle="yes">t<sub>k</sub></italic> = <italic toggle="yes">b</italic> − 1 + <italic toggle="yes">z</italic> operations of comparing two points, where <italic toggle="yes">z</italic> is the number of times the farthest points were updated. This can take up to Θ(<italic toggle="yes">b</italic><sup>2</sup>) time in the worst case. However, it can be noticed, that potential change Φ<sub><italic toggle="yes">k</italic></sub> − Φ<sub><italic toggle="yes">k</italic>−1</sub> is equal to −<italic toggle="yes">z</italic> + <italic toggle="yes">O</italic>(<italic toggle="yes">b</italic>): the sum of indexes is decreased by a number of times the farthest points were updated plus <italic toggle="yes">O</italic>(<italic toggle="yes">b</italic>) for the block c where the index can go from 0 to <italic toggle="yes">b</italic> − 1. This gives an amortized cost of <italic toggle="yes">k</italic>-th iteration to be <italic toggle="yes">a<sub>k</sub></italic> = <italic toggle="yes">t<sub>k</sub></italic> + Φ<sub><italic toggle="yes">k</italic></sub> − Φ<sub><italic toggle="yes">k</italic>−1</sub> = <italic toggle="yes">b</italic> − 1 + <italic toggle="yes">z</italic> − <italic toggle="yes">z</italic> + <italic toggle="yes">O</italic>(<italic toggle="yes">b</italic>) = <italic toggle="yes">O</italic>(<italic toggle="yes">b</italic>). The total real cost of <italic toggle="yes">K</italic> iterations is <inline-formula hwp:id="inline-formula-30"><alternatives hwp:id="alternatives-52"><inline-graphic xlink:href="060012v3_inline30.gif" hwp:id="inline-graphic-30"/></alternatives></inline-formula>, which means amortized cost of one iteration to be <italic toggle="yes">O</italic>(<italic toggle="yes">b</italic>).</p><p hwp:id="p-79">Taken together the algorithm allows to find all cumulative enrichment scores <italic toggle="yes">s<sub>r</sub></italic>(<italic toggle="yes">π</italic>[1..<italic toggle="yes">k</italic>]) in <inline-formula hwp:id="inline-formula-31"><alternatives hwp:id="alternatives-53"><inline-graphic xlink:href="060012v3_inline31.gif" hwp:id="inline-graphic-31"/></alternatives></inline-formula> time. The straightforward implementation of calculating cumulative values from scratch would take <italic toggle="yes">O</italic>(<italic toggle="yes">K</italic><sup>2</sup> log <italic toggle="yes">K</italic>) time. Thus, we have improved the performance <inline-formula hwp:id="inline-formula-32"><alternatives hwp:id="alternatives-54"><inline-graphic xlink:href="060012v3_inline32.gif" hwp:id="inline-graphic-32"/></alternatives></inline-formula> times.</p></sec><sec id="s2c3" hwp:id="sec-8"><label>2.3.3</label><title hwp:id="title-11">Implementation details</title><p hwp:id="p-80">We also implemented an optimization so that the algorithm does not build convex hull from scratch for a changed block <italic toggle="yes">c</italic>, but only updates the changed points. This does not influence the asymptotic performance, but decreases the constant factor.</p><p hwp:id="p-81">First, we start updating the convex hull from position <italic toggle="yes">r<sub>k</sub></italic> and not from the start. To be able to do this, we have an array <monospace>prev</monospace> that for each gene <italic toggle="yes">g</italic> ∈ <italic toggle="yes">π</italic> stores the previous point on the convex hull if <italic toggle="yes">g</italic> were the last gene in the block. This actually is the same as the top of the stack in Graham algorithm and represent the algorithms state for any given point. As all points <italic toggle="yes">h</italic> to the left of <italic toggle="yes">g</italic> are not changed <monospace>prev</monospace><sub><italic toggle="yes">h</italic></sub> also remains unchanged and need not to be recalculated.</p><p hwp:id="p-82">Second, we stop updating the hull, when we reach the point on the previous iteration convex hull. We can do this because every point to the left of <italic toggle="yes">g</italic> is rotated counterclockwise of any point to the right of <italic toggle="yes">g</italic>, which means that the first point on the convex hull right of <italic toggle="yes">g</italic> on (<italic toggle="yes">k</italic> – 1)-th iteration remains being a convex hull point at <italic toggle="yes">k</italic>-th iteration.</p></sec></sec><sec id="s2d" hwp:id="sec-9" hwp:rev-id="xref-sec-9-1"><label>2.4</label><title hwp:id="title-12">An algorithm for exact calculation of GSEA P-values for integer gene-level statistics</title><p hwp:id="p-83">In this section we describe a polynomial algorithm to calculate GSEA P-value exactly, but only for the case when gene-level statistics are integer numbers: <inline-formula hwp:id="inline-formula-33"><alternatives hwp:id="alternatives-55"><inline-graphic xlink:href="060012v3_inline33.gif" hwp:id="inline-graphic-33"/></alternatives></inline-formula>. For simplicity we will consider a problem of calculating the following probability:
<disp-formula hwp:id="disp-formula-23">
<alternatives hwp:id="alternatives-56"><graphic xlink:href="060012v3_ueqn17.gif" position="float" orientation="portrait" hwp:id="graphic-27"/></alternatives>
</disp-formula>
where <italic toggle="yes">q</italic> is a random gene set of size <italic toggle="yes">k</italic>. We also assume <italic toggle="yes">γ</italic> &gt; 0.</p><p hwp:id="p-84">Let denote the sum of <italic toggle="yes">k</italic> largest absolute values of gene ranks by <italic toggle="yes">T</italic>. The algorithm will be polynomial in terms of <italic toggle="yes">N, k</italic> and <italic toggle="yes">T</italic>.</p><sec id="s2d1" hwp:id="sec-10"><label>2.4.1</label><title hwp:id="title-13">The basic algorithm</title><p hwp:id="p-85">Let us consider a gene set <italic toggle="yes">q</italic> = {<italic toggle="yes">q</italic><sub>1</sub>, <italic toggle="yes">q</italic><sub>2</sub>,…, <italic toggle="yes">q<sub>k</sub></italic>}. Recall the formula for <italic toggle="yes">s</italic><sup>+</sup>(<italic toggle="yes">q</italic>):
<disp-formula hwp:id="disp-formula-24">
<alternatives hwp:id="alternatives-57"><graphic xlink:href="060012v3_ueqn18.gif" position="float" orientation="portrait" hwp:id="graphic-28"/></alternatives>
</disp-formula></p><p hwp:id="p-86">First, let rewrite the formula for ES<sub><italic toggle="yes">i</italic></sub> in an equivalent fashion, grouping positive and negative summands:
<disp-formula hwp:id="disp-formula-25">
<alternatives hwp:id="alternatives-58"><graphic xlink:href="060012v3_ueqn19.gif" position="float" orientation="portrait" hwp:id="graphic-29"/></alternatives>
</disp-formula></p><p hwp:id="p-87">Then for calculating ES<sub><italic toggle="yes">i</italic></sub> the following values are sufficient:
<list list-type="bullet" hwp:id="list-1"><list-item hwp:id="list-item-1"><p hwp:id="p-88"><italic toggle="yes">i</italic>: the index of the current gene;</p></list-item><list-item hwp:id="list-item-2"><p hwp:id="p-89"><inline-formula hwp:id="inline-formula-34"><alternatives hwp:id="alternatives-59"><inline-graphic xlink:href="060012v3_inline34.gif" hwp:id="inline-graphic-34"/></alternatives></inline-formula>: the number of genes included into the set <italic toggle="yes">q</italic> among genes 1..<italic toggle="yes">i</italic>;</p></list-item><list-item hwp:id="list-item-3"><p hwp:id="p-90"><inline-formula hwp:id="inline-formula-35"><alternatives hwp:id="alternatives-60"><inline-graphic xlink:href="060012v3_inline35.gif" hwp:id="inline-graphic-35"/></alternatives></inline-formula>: the sum of the absolute values of gene-level statistics for genes included in the set among genes 1..<italic toggle="yes">i</italic>;</p></list-item><list-item hwp:id="list-item-4"><p hwp:id="p-91"><inline-formula hwp:id="inline-formula-36"><alternatives hwp:id="alternatives-61"><inline-graphic xlink:href="060012v3_inline36.gif" hwp:id="inline-graphic-36"/></alternatives></inline-formula>: the sum of the absolute values of gene-level statistics for <italic toggle="yes">all</italic> genes in the set.</p></list-item></list></p><p hwp:id="p-92">Knowing the values above, ES<sub><italic toggle="yes">i</italic></sub> can be calculated as <inline-formula hwp:id="inline-formula-37"><alternatives hwp:id="alternatives-62"><inline-graphic xlink:href="060012v3_inline37.gif" hwp:id="inline-graphic-37"/></alternatives></inline-formula>.</p><p hwp:id="p-93">Notice that NS can take only integer values from 0 to <italic toggle="yes">T</italic> (for a set of genes with the largest absolute values of gene-level statistics). Let us split the desired probability to a sum of independent probabilities based on the value of NS:
<disp-formula hwp:id="disp-formula-26">
<alternatives hwp:id="alternatives-63"><graphic xlink:href="060012v3_ueqn20.gif" position="float" orientation="portrait" hwp:id="graphic-30"/></alternatives>
</disp-formula></p><p hwp:id="p-94">Our algorithm will be based on <italic toggle="yes">dynamic programming</italic>. For each possible value of NS we will process the genes one by one in increasing order of index and calculate an array <italic toggle="yes">f</italic><sub>NS</sub>(<italic toggle="yes">i, c, s</italic>). The value <italic toggle="yes">f</italic><sub>NS</sub>(<italic toggle="yes">i, c, s</italic>) will contain the probability for a uniformly random gene set <italic toggle="yes">q</italic>′ of <italic toggle="yes">c</italic> genes selected from genes 1..<italic toggle="yes">i</italic> to simultaneously have the following two properties:
<list list-type="order" hwp:id="list-2"><list-item hwp:id="list-item-5"><p hwp:id="p-95">the sum of the absolute values of gene-level statistics of genes from <italic toggle="yes">q</italic>′ is equal to <italic toggle="yes">s</italic>;</p></list-item><list-item hwp:id="list-item-6"><p hwp:id="p-96">ES<sub><italic toggle="yes">j</italic></sub> &lt; <italic toggle="yes">γ</italic> holds for all <italic toggle="yes">j</italic> ⩽ <italic toggle="yes">i</italic>, where the values of ES are calculated for the gene set <italic toggle="yes">q</italic>′ but using the selected values of NS and <italic toggle="yes">k</italic>, not the ones calculated for the set <italic toggle="yes">q</italic>′.</p><p hwp:id="p-97">Suppose that we have calculated all values of <italic toggle="yes">f</italic><sub>NS</sub>(<italic toggle="yes">i, c, s</italic>), then
<disp-formula hwp:id="disp-formula-27">
<alternatives hwp:id="alternatives-64"><graphic xlink:href="060012v3_ueqn21.gif" position="float" orientation="portrait" hwp:id="graphic-31"/></alternatives>
</disp-formula>
and
<disp-formula hwp:id="disp-formula-28">
<alternatives hwp:id="alternatives-65"><graphic xlink:href="060012v3_ueqn22.gif" position="float" orientation="portrait" hwp:id="graphic-32"/></alternatives>
</disp-formula></p><p hwp:id="p-98">Finally, the sought probability is equal to:
<disp-formula hwp:id="disp-formula-29">
<alternatives hwp:id="alternatives-66"><graphic xlink:href="060012v3_ueqn23.gif" position="float" orientation="portrait" hwp:id="graphic-33"/></alternatives>
</disp-formula></p><p hwp:id="p-99">Let us find a formula for <italic toggle="yes">f</italic><sub>NS</sub>(<italic toggle="yes">i, c, s</italic>). The base case of dynamic programming is <italic toggle="yes">i</italic> = 0 for all NS:
<disp-formula hwp:id="disp-formula-30">
<alternatives hwp:id="alternatives-67"><graphic xlink:href="060012v3_ueqn24.gif" position="float" orientation="portrait" hwp:id="graphic-34"/></alternatives>
</disp-formula></p><p hwp:id="p-100">Suppose we want to calculate <italic toggle="yes">f</italic><sub>NS</sub>(<italic toggle="yes">i, c, s</italic>) for some <italic toggle="yes">i</italic> &gt; 0. First, calculate
<disp-formula hwp:id="disp-formula-31">
<alternatives hwp:id="alternatives-68"><graphic xlink:href="060012v3_ueqn25.gif" position="float" orientation="portrait" hwp:id="graphic-35"/></alternatives>
</disp-formula>
and compare it to <italic toggle="yes">γ</italic>. If ES<sub><italic toggle="yes">i</italic></sub> ⩾ <italic toggle="yes">γ</italic>, then <italic toggle="yes">f</italic><sub>NS</sub>(<italic toggle="yes">i, c, s</italic>) = 0 by definition.</p></list-item></list></p><p hwp:id="p-101">Otherwise, condition “ES<sub><italic toggle="yes">j</italic></sub> &lt; <italic toggle="yes">γ</italic> holds for all <italic toggle="yes">j</italic> ⩽ <italic toggle="yes">i</italic>” can be simplified to “ES<sub><italic toggle="yes">j</italic></sub> &lt; <italic toggle="yes">γ</italic> holds for all <italic toggle="yes">j</italic> ⩽ <italic toggle="yes">i</italic> – 1”. This observation allows us to use values of <italic toggle="yes">f</italic> that have already been calculated. Consider two cases:
<list list-type="order" hwp:id="list-3"><list-item hwp:id="list-item-7"><p hwp:id="p-102">Gene <italic toggle="yes">i</italic> does not belong to the set <italic toggle="yes">q</italic>′. As <italic toggle="yes">q</italic>′ is a set of <italic toggle="yes">c</italic> genes chosen uniformly at random from <italic toggle="yes">i</italic> genes, this case happens with the probability <inline-formula hwp:id="inline-formula-38"><alternatives hwp:id="alternatives-69"><inline-graphic xlink:href="060012v3_inline38.gif" hwp:id="inline-graphic-38"/></alternatives></inline-formula>. The conditional probability that such set satisfies the two necessary properties is <italic toggle="yes">f</italic><sub>NS</sub>(<italic toggle="yes">i</italic> – 1, <italic toggle="yes">c, s</italic>). Indeed, any set of size <italic toggle="yes">c</italic> with the sum of absolute values of gene-level statistics values equal to <italic toggle="yes">s</italic>, chosen among genes 1..<italic toggle="yes">i</italic> – 1 and satisfying the conditions on ES, is a valid set chosen among genes 1..<italic toggle="yes">i</italic>. Similarly, if a set does not satisfy the condition on ES<sub><italic toggle="yes">j</italic></sub> for some <italic toggle="yes">j</italic> ⩽ <italic toggle="yes">i</italic> – 1, this set should not be counted towards <italic toggle="yes">f</italic><sub>NS</sub>(<italic toggle="yes">i, c, s</italic>) since obviously <italic toggle="yes">j</italic> ⩽ <italic toggle="yes">i</italic>.</p></list-item><list-item hwp:id="list-item-8"><p hwp:id="p-103">Gene <italic toggle="yes">i</italic> belongs to the set. This case happens with the probability <inline-formula hwp:id="inline-formula-39"><alternatives hwp:id="alternatives-70"><inline-graphic xlink:href="060012v3_inline39.gif" hwp:id="inline-graphic-39"/></alternatives></inline-formula>. The probability that this set satisfies the necessary conditions is <italic toggle="yes">f</italic><sub>NS</sub>(<italic toggle="yes">i</italic> − 1, <italic toggle="yes">c</italic> − 1, <italic toggle="yes">s</italic> − <italic toggle="yes">S<sub>i</sub></italic>). Indeed, any set of size <italic toggle="yes">c</italic> − 1 with the sum of absolute values of gene-level statistics equal to <italic toggle="yes">s</italic> − <italic toggle="yes">S<sub>i</sub></italic>, chosen among genes 1..<italic toggle="yes">i</italic> − 1 and satisfying the conditions on ES, can be extended with gene <italic toggle="yes">i</italic>, thus forming a set of size <italic toggle="yes">c</italic> satisfying both necessary properties. Similarly, if a set does not satisfy the condition on ES<sub><italic toggle="yes">j</italic></sub> for some <italic toggle="yes">j</italic> ⩽ <italic toggle="yes">i</italic> − 1, adding gene <italic toggle="yes">i</italic> will not fix the situation.</p><p hwp:id="p-104">Then we can calculate <italic toggle="yes">f</italic><sub>NS</sub>(<italic toggle="yes">i, c, s</italic>) using the law of total probability:
<disp-formula hwp:id="disp-formula-32">
<alternatives hwp:id="alternatives-71"><graphic xlink:href="060012v3_ueqn26.gif" position="float" orientation="portrait" hwp:id="graphic-36"/></alternatives>
</disp-formula>
in the case when <italic toggle="yes">i</italic> &gt; 0 and ES<sub><italic toggle="yes">i</italic></sub> &lt; <italic toggle="yes">γ</italic>.</p><p hwp:id="p-105">Putting all the cases together, we arrive to the final formula for <italic toggle="yes">f</italic><sub>NS</sub>(<italic toggle="yes">i, c, s</italic>):
<disp-formula hwp:id="disp-formula-33">
<alternatives hwp:id="alternatives-72"><graphic xlink:href="060012v3_ueqn27.gif" position="float" orientation="portrait" hwp:id="graphic-37"/></alternatives>
</disp-formula></p><p hwp:id="p-106">The overall complexity of the algorithm is <italic toggle="yes">O</italic>(<italic toggle="yes">NkT</italic><sup>2</sup>). The values of <italic toggle="yes">f</italic> can be evaluated sequentially in increasing order of <italic toggle="yes">i</italic>. It is enough to evaluate <italic toggle="yes">f</italic><sub>NS</sub>(<italic toggle="yes">i, c, s</italic>) for 0 ⩽ <italic toggle="yes">i</italic> ⩽ <italic toggle="yes">N</italic>, 0 ⩽ <italic toggle="yes">c</italic> ⩽ <italic toggle="yes">k</italic>, and 0 ⩽ <italic toggle="yes">s</italic> ⩽ NS ⩽ <italic toggle="yes">T</italic>. Each value of <italic toggle="yes">f</italic> can be evaluated in constant time.</p></list-item></list></p></sec><sec id="s2d2" hwp:id="sec-11"><label>2.4.2</label><title hwp:id="title-14">Optimizations and implementation details</title><p hwp:id="p-107">While the algorithm described above is polynomial, a number of further optimizations are required to make execution on real size inputs feasible.</p><p hwp:id="p-108">First, let note that the following property holds: <italic toggle="yes">f</italic><sub>NS<sub>2</sub></sub>(<italic toggle="yes">i, c, s</italic>) ⩾ <italic toggle="yes">f</italic><sub>NS<sub>1</sub></sub>(<italic toggle="yes">i, c, s</italic>) as long as NS<sub>2</sub> ⩾ NS<sub>1</sub>. Indeed, ES values calculated using different values of NS are decreasing when NS is increased. That means all gene sets counted towards <italic toggle="yes">f</italic><sub>NS<sub>1</sub></sub>(<italic toggle="yes">i, c, s</italic>) should also be counted towards <italic toggle="yes">f</italic><sub>NS<sub>2</sub></sub>(<italic toggle="yes">i, c, s</italic>) if NS<sub>2</sub> ⩾ NS<sub>1</sub>.</p><p hwp:id="p-109">Following the observation above, instead of calculating values of <italic toggle="yes">f</italic><sub>NS</sub>(<italic toggle="yes">i, c, s</italic>) we will con-sider the values <italic toggle="yes">g</italic>(<italic toggle="yes">i, c, s, b</italic>) = <italic toggle="yes">f</italic><sub><italic toggle="yes">b</italic>+1</sub>(<italic toggle="yes">i, c, s</italic>) − <italic toggle="yes">f<sub>b</sub></italic>(<italic toggle="yes">i, c, s</italic>). These values will contain the probability of a random gene set <italic toggle="yes">q</italic> of size <italic toggle="yes">k</italic> selected uniformly from genes 1..<italic toggle="yes">N</italic> to satisfy simultaneously the following three properties:
<list list-type="order" hwp:id="list-4"><list-item hwp:id="list-item-9"><p hwp:id="p-110">set <italic toggle="yes">q</italic> contains exactly <italic toggle="yes">c</italic> genes from the genes 1..<italic toggle="yes">i</italic>.</p></list-item><list-item hwp:id="list-item-10"><p hwp:id="p-111">the sum of the absolute values of gene-level statistics of the first <italic toggle="yes">c</italic> genes from <italic toggle="yes">q</italic> is equal to <italic toggle="yes">s</italic>;</p></list-item><list-item hwp:id="list-item-11"><p hwp:id="p-112">ES<sub><italic toggle="yes">j</italic></sub> &lt; <italic toggle="yes">γ</italic> holds for all <italic toggle="yes">j</italic> ⩽ <italic toggle="yes">i</italic>, where the values of ES are calculated for the gene set <italic toggle="yes">q</italic> using NS = <italic toggle="yes">b</italic> +1 (and for all higher values of NS);</p></list-item><list-item hwp:id="list-item-12"><p hwp:id="p-113">ES<sub><italic toggle="yes">j</italic></sub> ⩾ <italic toggle="yes">γ</italic> holds for at least one <italic toggle="yes">j</italic> ⩽ <italic toggle="yes">i</italic>, where the values of ES are calculated for the gene set <italic toggle="yes">q</italic> using NS = <italic toggle="yes">b</italic> (and for all lower values of NS).</p></list-item></list></p><p hwp:id="p-114">The sought probability can be calculated from values of <italic toggle="yes">g</italic> as follows:
<disp-formula hwp:id="disp-formula-34">
<alternatives hwp:id="alternatives-73"><graphic xlink:href="060012v3_ueqn28.gif" position="float" orientation="portrait" hwp:id="graphic-38"/></alternatives>
</disp-formula></p><p hwp:id="p-115">To calculate the values of <italic toggle="yes">g</italic> we will use the forward dynamic programming algorithm. In this algorithm we expand a tree of reachable dynamic programming states, starting from <italic toggle="yes">g</italic>(0, 0, 0, 0) which is equal to 1.</p><p hwp:id="p-116">The states will be considered by “levels” in an increasing order of <italic toggle="yes">i</italic>. The values <italic toggle="yes">g</italic>(<italic toggle="yes">i</italic> + 1, <italic toggle="yes">c, s, b</italic>) from (<italic toggle="yes">i</italic> + 1)-th level are calculated based on level <italic toggle="yes">i</italic>. Note, that the sum of values on <italic toggle="yes">i</italic>-th level is always equal to 1.</p><p hwp:id="p-117">To calculate all values from the (<italic toggle="yes">i</italic> + 1)-th level all non-zero values from the <italic toggle="yes">i</italic>-th level are considered sequentially. Let consider state (<italic toggle="yes">i, c, s, b</italic>) and let define <italic toggle="yes">p</italic> = (<italic toggle="yes">k</italic> – <italic toggle="yes">c</italic>)/(<italic toggle="yes">N</italic> – <italic toggle="yes">i</italic>) – the probability that gene <italic toggle="yes">i</italic> + 1 will be added to the set. The corresponding set <italic toggle="yes">G</italic>(<italic toggle="yes">i, c, s, b</italic>) can be divided into two groups.
<list list-type="order" hwp:id="list-5"><list-item hwp:id="list-item-13"><p hwp:id="p-118">The gene sets from <italic toggle="yes">G</italic>(<italic toggle="yes">i, c, s, b</italic>) that do not include gene <italic toggle="yes">i</italic> + 1. These gene sets are included into gene sets <italic toggle="yes">G</italic>(<italic toggle="yes">i</italic> + 1, <italic toggle="yes">c, s, b</italic>) on the level <italic toggle="yes">i</italic> + 1. Thus the corresponding probability <italic toggle="yes">g</italic>(<italic toggle="yes">i, c, s, b</italic>) · (1 – <italic toggle="yes">p</italic>) is added to the value of <italic toggle="yes">g</italic>(<italic toggle="yes">i</italic> + 1, <italic toggle="yes">c, s, b</italic>).</p></list-item><list-item hwp:id="list-item-14"><p hwp:id="p-119">The gene sets from <italic toggle="yes">G</italic>(<italic toggle="yes">i, c, s, b</italic>) that do include gene <italic toggle="yes">i</italic> + 1. These gene sets are included into <italic toggle="yes">G</italic>(<italic toggle="yes">i</italic> + 1, <italic toggle="yes">c</italic> + 1, <italic toggle="yes">s</italic>′ = <italic toggle="yes">s</italic> + |<italic toggle="yes">S</italic><sub><italic toggle="yes">i</italic>+1</sub>|, <italic toggle="yes">b</italic>′) where <italic toggle="yes">b</italic>′ is an updated bound. To calculate <italic toggle="yes">b</italic>′ let note th at ES<sub><italic toggle="yes">j</italic></sub> will be greater or equal to <italic toggle="yes">γ</italic> iff <inline-formula hwp:id="inline-formula-40"><alternatives hwp:id="alternatives-74"><inline-graphic xlink:href="060012v3_inline40.gif" hwp:id="inline-graphic-40"/></alternatives></inline-formula> which is equivalent to <inline-formula hwp:id="inline-formula-41"><alternatives hwp:id="alternatives-75"><inline-graphic xlink:href="060012v3_inline41.gif" hwp:id="inline-graphic-41"/></alternatives></inline-formula>. Thus <inline-formula hwp:id="inline-formula-42"><alternatives hwp:id="alternatives-76"><inline-graphic xlink:href="060012v3_inline42.gif" hwp:id="inline-graphic-42"/></alternatives></inline-formula> The probability that is added to <italic toggle="yes">g</italic>(<italic toggle="yes">i</italic> + 1, <italic toggle="yes">c</italic> + 1, <italic toggle="yes">s</italic>′, <italic toggle="yes">b</italic>′) is equal to <italic toggle="yes">g</italic>(<italic toggle="yes">i, c, s, b</italic>) · <italic toggle="yes">p</italic>.</p></list-item></list></p><p hwp:id="p-120">While the asymptotic number of states remains to be <italic toggle="yes">O</italic>(<italic toggle="yes">NkT</italic><sup>2</sup>) the forward dynamic programming allows to consider only “reachable” gene stats with <italic toggle="yes">g</italic>(<italic toggle="yes">i, c, s, b</italic>) &gt; 0. In practice the number of reachable stats can be several orders of magnitude smaller then the total states.</p><p hwp:id="p-121">Furthermore, for the algorithm we can consider only states with <italic toggle="yes">g</italic>(<italic toggle="yes">i, c, s, b</italic>) &gt; <italic toggle="yes">ε</italic> to be reachable for some small value of <italic toggle="yes">ε</italic>. If we do not consider the unreachable states we would not be able to calculated the desired probability exactly. However, if we calculate the value of <italic toggle="yes">δ</italic> as a sum of all the skipped states values, the desired probability will be calculated with the absolute error no more than <italic toggle="yes">δ</italic>.</p><p hwp:id="p-122">The algorithm implementation with few other optimizations is available at: <ext-link l:rel="related" l:ref-type="uri" l:ref="https://github.com/ctlab/fgsea/blob/master/inst/exact/exact.cpp" ext-link-type="uri" xlink:href="https://github.com/ctlab/fgsea/blob/master/inst/exact/exact.cpp" hwp:id="ext-link-11">https://github.com/ctlab/fgsea/blob/master/inst/exact/exact.cpp</ext-link>.</p></sec></sec><sec id="s2e" hwp:id="sec-12" hwp:rev-id="xref-sec-12-1"><label>2.5</label><title hwp:id="title-15">FGSEA-multilevel: an algorithm for calculation of arbitrarily low P-values using adaptive multilevel split Monte Carlo scheme</title><p hwp:id="p-123">In this section we describe FGSEA-multilevel algorithm that can accurately estimate GSEA P-value for a pathway <italic toggle="yes">p</italic> of size <italic toggle="yes">k</italic> even when the true P-value is very small.</p><p hwp:id="p-124">Let <italic toggle="yes">γ</italic> = <italic toggle="yes">s<sub>r</sub></italic>(<italic toggle="yes">p</italic>) &gt; 0 be the enrichment score of the query pathway <italic toggle="yes">p</italic> for which we want to calculate the following value:
<disp-formula hwp:id="disp-formula-35">
<alternatives hwp:id="alternatives-77"><graphic xlink:href="060012v3_ueqn29.gif" position="float" orientation="portrait" hwp:id="graphic-39"/></alternatives>
</disp-formula>
where <italic toggle="yes">q</italic> is a random gene set of size <italic toggle="yes">k</italic>. This probability can be rewritten as follows:
<disp-formula hwp:id="disp-formula-36">
<alternatives hwp:id="alternatives-78"><graphic xlink:href="060012v3_ueqn30.gif" position="float" orientation="portrait" hwp:id="graphic-40"/></alternatives>
</disp-formula></p><p hwp:id="p-125">First, we focus on determining the probability <inline-formula hwp:id="inline-formula-43"><alternatives hwp:id="alternatives-79"><inline-graphic xlink:href="060012v3_inline43.gif" hwp:id="inline-graphic-43"/></alternatives></inline-formula>. This probability can be extremely small, so using a naive sampling gives a bad estimation. We use the adaptive multilevel split Monte Carlo method [<xref ref-type="bibr" rid="c6" hwp:id="xref-ref-6-2" hwp:rel-id="ref-6">6</xref>] to solve this problem.</p><p hwp:id="p-126">To estimate the probability <inline-formula hwp:id="inline-formula-44"><alternatives hwp:id="alternatives-80"><inline-graphic xlink:href="060012v3_inline44.gif" hwp:id="inline-graphic-44"/></alternatives></inline-formula> we split the enrichment scores into levels 0 = <italic toggle="yes">l</italic><sub>0</sub> &lt; <italic toggle="yes">l</italic><sub>1</sub> &lt; … &lt; <italic toggle="yes">l<sub>t</sub></italic> = <italic toggle="yes">γ</italic>. Then we can define the following probabilities:
<disp-formula hwp:id="disp-formula-37">
<alternatives hwp:id="alternatives-81"><graphic xlink:href="060012v3_ueqn31.gif" position="float" orientation="portrait" hwp:id="graphic-41"/></alternatives>
</disp-formula></p><p hwp:id="p-127">Now the probability <inline-formula hwp:id="inline-formula-45"><alternatives hwp:id="alternatives-82"><inline-graphic xlink:href="060012v3_inline45.gif" hwp:id="inline-graphic-45"/></alternatives></inline-formula> can be rewritten as <inline-formula hwp:id="inline-formula-46"><alternatives hwp:id="alternatives-83"><inline-graphic xlink:href="060012v3_inline46.gif" hwp:id="inline-graphic-46"/></alternatives></inline-formula>.</p><p hwp:id="p-128">To estimate <italic toggle="yes">α<sub>i</sub></italic> we can draw a sample <inline-formula hwp:id="inline-formula-47"><alternatives hwp:id="alternatives-84"><inline-graphic xlink:href="060012v3_inline47.gif" hwp:id="inline-graphic-47"/></alternatives></inline-formula> of size <italic toggle="yes">Z</italic> from a conditional distribution <inline-formula hwp:id="inline-formula-48"><alternatives hwp:id="alternatives-85"><inline-graphic xlink:href="060012v3_inline48.gif" hwp:id="inline-graphic-48"/></alternatives></inline-formula>. Then
<disp-formula hwp:id="disp-formula-38">
<alternatives hwp:id="alternatives-86"><graphic xlink:href="060012v3_ueqn32.gif" position="float" orientation="portrait" hwp:id="graphic-42"/></alternatives>
</disp-formula>
where <italic toggle="yes">Z<sub>i</sub></italic> is the number of elements in the set <inline-formula hwp:id="inline-formula-49"><alternatives hwp:id="alternatives-87"><inline-graphic xlink:href="060012v3_inline49.gif" hwp:id="inline-graphic-49"/></alternatives></inline-formula>.</p><p hwp:id="p-129">Below we show how levels <italic toggle="yes">l<sub>i</sub></italic> can be chosen and how to sample from the corresponding conditional distributions.</p><sec id="s2e1" hwp:id="sec-13"><label>2.5.1</label><title hwp:id="title-16">Choosing the enrichment score levels</title><p hwp:id="p-130">We propose to chose value for a level <italic toggle="yes">l<sub>i</sub></italic> as a median of the enrichment scores for the <inline-formula hwp:id="inline-formula-50"><alternatives hwp:id="alternatives-88"><inline-graphic xlink:href="060012v3_inline50.gif" hwp:id="inline-graphic-50"/></alternatives></inline-formula> sample. For simplicity <italic toggle="yes">Z</italic> is required to be an odd number.</p><p hwp:id="p-131">Then the procedure for estimating probability <inline-formula hwp:id="inline-formula-51"><alternatives hwp:id="alternatives-89"><inline-graphic xlink:href="060012v3_inline51.gif" hwp:id="inline-graphic-51"/></alternatives></inline-formula> consists of repetition of the following steps:
<list list-type="order" hwp:id="list-6"><list-item hwp:id="list-item-15"><p hwp:id="p-132">On iteration <italic toggle="yes">i</italic> ⩾ 1 sample <italic toggle="yes">Z</italic> gene sets <inline-formula hwp:id="inline-formula-52"><alternatives hwp:id="alternatives-90"><inline-graphic xlink:href="060012v3_inline52.gif" hwp:id="inline-graphic-52"/></alternatives></inline-formula> of size <italic toggle="yes">k</italic> from the distribution <inline-formula hwp:id="inline-formula-53"><alternatives hwp:id="alternatives-91"><inline-graphic xlink:href="060012v3_inline53.gif" hwp:id="inline-graphic-53"/></alternatives></inline-formula>.</p></list-item><list-item hwp:id="list-item-16"><p hwp:id="p-133">Set the level <inline-formula hwp:id="inline-formula-54"><alternatives hwp:id="alternatives-92"><inline-graphic xlink:href="060012v3_inline54.gif" hwp:id="inline-graphic-54"/></alternatives></inline-formula> to be equal to the median of values <inline-formula hwp:id="inline-formula-55"><alternatives hwp:id="alternatives-93"><inline-graphic xlink:href="060012v3_inline55.gif" hwp:id="inline-graphic-55"/></alternatives></inline-formula>.</p></list-item><list-item hwp:id="list-item-17"><p hwp:id="p-134">If <inline-formula hwp:id="inline-formula-56"><alternatives hwp:id="alternatives-94"><inline-graphic xlink:href="060012v3_inline56.gif" hwp:id="inline-graphic-56"/></alternatives></inline-formula> then stop the iterations and set <italic toggle="yes">l<sub>i</sub></italic> = <italic toggle="yes">γ</italic> mid <italic toggle="yes">t</italic> = <italic toggle="yes">i</italic>, otherwise set <inline-formula hwp:id="inline-formula-57"><alternatives hwp:id="alternatives-95"><inline-graphic xlink:href="060012v3_inline57.gif" hwp:id="inline-graphic-57"/></alternatives></inline-formula>.</p></list-item></list></p><p hwp:id="p-135">As a result, by construction, <italic toggle="yes">α<sub>i</sub></italic> ≈ 1/2 for 1 ⩽ <italic toggle="yes">i</italic> ⩽ <italic toggle="yes">t</italic> − 1. The value of can be approximated as <italic toggle="yes">Z<sub>t</sub></italic>/<italic toggle="yes">Z</italic> (which is always ⩾ 1/2). Together we get the following expression for estimating the desired probability:
<disp-formula hwp:id="disp-formula-39">
<alternatives hwp:id="alternatives-96"><graphic xlink:href="060012v3_ueqn33.gif" position="float" orientation="portrait" hwp:id="graphic-43"/></alternatives>
</disp-formula></p></sec><sec id="s2e2" hwp:id="sec-14"><label>2.5.2</label><title hwp:id="title-17">The conditional sampling implementation</title><p hwp:id="p-136">To generate a uniform sample <inline-formula hwp:id="inline-formula-58"><alternatives hwp:id="alternatives-97"><inline-graphic xlink:href="060012v3_inline58.gif" hwp:id="inline-graphic-58"/></alternatives></inline-formula> from the conditional distribution <inline-formula hwp:id="inline-formula-59"><alternatives hwp:id="alternatives-98"><inline-graphic xlink:href="060012v3_inline59.gif" hwp:id="inline-graphic-59"/></alternatives></inline-formula> we use the Metropolis algorithm.</p><p hwp:id="p-137">First, we generate a sample <inline-formula hwp:id="inline-formula-60"><alternatives hwp:id="alternatives-99"><inline-graphic xlink:href="060012v3_inline60.gif" hwp:id="inline-graphic-60"/></alternatives></inline-formula> of size <italic toggle="yes">Z</italic> from the distribution <inline-formula hwp:id="inline-formula-61"><alternatives hwp:id="alternatives-100"><inline-graphic xlink:href="060012v3_inline61.gif" hwp:id="inline-graphic-61"/></alternatives></inline-formula>. Since <italic toggle="yes">l</italic><sub>0</sub> = 0 and values of <inline-formula hwp:id="inline-formula-62"><alternatives hwp:id="alternatives-101"><inline-graphic xlink:href="060012v3_inline62.gif" hwp:id="inline-graphic-62"/></alternatives></inline-formula> are always non-negative it can be done by generating a uniformly random subset of size <italic toggle="yes">k</italic> from the genes {1, 2,…, <italic toggle="yes">N</italic>}.</p><p hwp:id="p-138">Now let consider a sample <inline-formula hwp:id="inline-formula-63"><alternatives hwp:id="alternatives-102"><inline-graphic xlink:href="060012v3_inline63.gif" hwp:id="inline-graphic-63"/></alternatives></inline-formula> at a step <italic toggle="yes">i</italic> &gt; 1. The sample can be sorted in an increasing order of enrichment score values: <inline-formula hwp:id="inline-formula-64"><alternatives hwp:id="alternatives-103"><inline-graphic xlink:href="060012v3_inline64.gif" hwp:id="inline-graphic-64"/></alternatives></inline-formula>. Let <italic toggle="yes">d</italic> = ⌈<italic toggle="yes">Z</italic>/2⌉. The level <italic toggle="yes">l</italic><sub><italic toggle="yes">i</italic>−1</sub> is the median of the values <inline-formula hwp:id="inline-formula-65"><alternatives hwp:id="alternatives-104"><inline-graphic xlink:href="060012v3_inline65.gif" hwp:id="inline-graphic-65"/></alternatives></inline-formula> and, thus, is equal to <inline-formula hwp:id="inline-formula-66"><alternatives hwp:id="alternatives-105"><inline-graphic xlink:href="060012v3_inline66.gif" hwp:id="inline-graphic-66"/></alternatives></inline-formula>.</p><p hwp:id="p-139">Let first populate <inline-formula hwp:id="inline-formula-67"><alternatives hwp:id="alternatives-106"><inline-graphic xlink:href="060012v3_inline67.gif" hwp:id="inline-graphic-67"/></alternatives></inline-formula> in the following way:
<disp-formula hwp:id="disp-formula-40">
<alternatives hwp:id="alternatives-107"><graphic xlink:href="060012v3_ueqn34.gif" position="float" orientation="portrait" hwp:id="graphic-44"/></alternatives>
</disp-formula></p><p hwp:id="p-140">This gives us a sample from the conditional distribution <inline-formula hwp:id="inline-formula-68"><alternatives hwp:id="alternatives-108"><inline-graphic xlink:href="060012v3_inline68.gif" hwp:id="inline-graphic-68"/></alternatives></inline-formula>, however it is not uniform.</p><p hwp:id="p-141">To make the sample uniform we apply a number of the Metropolis algorithm iterations. On each iteration for each gene set <inline-formula hwp:id="inline-formula-69"><alternatives hwp:id="alternatives-109"><inline-graphic xlink:href="060012v3_inline69.gif" hwp:id="inline-graphic-69"/></alternatives></inline-formula> we apply the following steps:
<list list-type="order" hwp:id="list-7"><list-item hwp:id="list-item-18"><p hwp:id="p-142">Choose a random gene <inline-formula hwp:id="inline-formula-70"><alternatives hwp:id="alternatives-110"><inline-graphic xlink:href="060012v3_inline70.gif" hwp:id="inline-graphic-70"/></alternatives></inline-formula>.</p></list-item><list-item hwp:id="list-item-19"><p hwp:id="p-143">Choose a random gene <inline-formula hwp:id="inline-formula-71"><alternatives hwp:id="alternatives-111"><inline-graphic xlink:href="060012v3_inline71.gif" hwp:id="inline-graphic-71"/></alternatives></inline-formula>.</p></list-item><list-item hwp:id="list-item-20"><p hwp:id="p-144">Consider <inline-formula hwp:id="inline-formula-72"><alternatives hwp:id="alternatives-112"><inline-graphic xlink:href="060012v3_inline72.gif" hwp:id="inline-graphic-72"/></alternatives></inline-formula>. If <inline-formula hwp:id="inline-formula-73"><alternatives hwp:id="alternatives-113"><inline-graphic xlink:href="060012v3_inline73.gif" hwp:id="inline-graphic-73"/></alternatives></inline-formula> then we replace <inline-formula hwp:id="inline-formula-74"><alternatives hwp:id="alternatives-114"><inline-graphic xlink:href="060012v3_inline74.gif" hwp:id="inline-graphic-74"/></alternatives></inline-formula> with <inline-formula hwp:id="inline-formula-75"><alternatives hwp:id="alternatives-115"><inline-graphic xlink:href="060012v3_inline75.gif" hwp:id="inline-graphic-75"/></alternatives></inline-formula>.</p></list-item></list></p><p hwp:id="p-145">The iterations are repeated until the total number of successful replacements becomes greater or equal to <italic toggle="yes">k</italic> · <italic toggle="yes">Z</italic>. In practice, this number of steps is enough to get a sufficiently uniform sample to obtain a good estimation of probability, without a significant increase in the running time of the algorithm.</p></sec><sec id="s2e3" hwp:id="sec-15"><label>2.5.3</label><title hwp:id="title-18">Estimating the P-value</title><p hwp:id="p-146">In order to estimate the desired P-value we also need to calculate the probabilities P (<italic toggle="yes">s<sub>r</sub></italic>(<italic toggle="yes">q</italic>) ⩾ 0) and <inline-formula hwp:id="inline-formula-76"><alternatives hwp:id="alternatives-116"><inline-graphic xlink:href="060012v3_inline76.gif" hwp:id="inline-graphic-76"/></alternatives></inline-formula>.</p><p hwp:id="p-147">To calculate the probability P (<italic toggle="yes">s<sub>r</sub></italic>(<italic toggle="yes">q</italic>) ⩾ 0) we generate gene sets <italic toggle="yes">q</italic><sub>1</sub>, <italic toggle="yes">q</italic><sub>2</sub>,…, <italic toggle="yes">q<sub>Z</sub></italic>′, where each sample <italic toggle="yes">q<sub>i</sub></italic> is selected uniformly at random from all the subsets of size <italic toggle="yes">k</italic> from the set {1, 2,…, <italic toggle="yes">N</italic>}. The samples are generated until the number of samples <italic toggle="yes">q<sub>i</sub></italic> with <italic toggle="yes">s<sub>r</sub></italic>(<italic toggle="yes">q<sub>i</sub></italic>) ⩾ 0 becomes equal to <italic toggle="yes">Z</italic>. Then the probability P (<italic toggle="yes">s<sub>r</sub></italic>(<italic toggle="yes">q</italic>) ⩾ 0) is estimated as follows
<disp-formula hwp:id="disp-formula-41">
<alternatives hwp:id="alternatives-117"><graphic xlink:href="060012v3_ueqn35.gif" position="float" orientation="portrait" hwp:id="graphic-45"/></alternatives>
</disp-formula></p><p hwp:id="p-148">To determine the remaining probability <inline-formula hwp:id="inline-formula-77"><alternatives hwp:id="alternatives-118"><inline-graphic xlink:href="060012v3_inline77.gif" hwp:id="inline-graphic-77"/></alternatives></inline-formula> we calculate the number of gene sets in <inline-formula hwp:id="inline-formula-78"><alternatives hwp:id="alternatives-119"><inline-graphic xlink:href="060012v3_inline78.gif" hwp:id="inline-graphic-78"/></alternatives></inline-formula> with value of the enrichment score function <italic toggle="yes">s<sub>r</sub></italic> is greater than zero. After that, the probability can be estimated as follows:
<disp-formula hwp:id="disp-formula-42">
<alternatives hwp:id="alternatives-120"><graphic xlink:href="060012v3_ueqn36.gif" position="float" orientation="portrait" hwp:id="graphic-46"/></alternatives>
</disp-formula></p></sec><sec id="s2e4" hwp:id="sec-16" hwp:rev-id="xref-sec-16-1"><label>2.5.4</label><title hwp:id="title-19">Estimating log-probability</title><p hwp:id="p-149">To properly estimate a logarithm of the desired probability let note that the <italic toggle="yes">j</italic>-th order statistic of a standard uniform sample of size <italic toggle="yes">Z</italic> is a random variable from the beta distribution Beta (<italic toggle="yes">j, Z</italic> + 1 − <italic toggle="yes">j</italic>). Therefore, we can use the properties of the beta distribution and make correct transition to the logarithm of probability. So for the median value of sample of odd size <italic toggle="yes">Z</italic> we have:
<disp-formula hwp:id="disp-formula-43">
<alternatives hwp:id="alternatives-121"><graphic xlink:href="060012v3_ueqn37.gif" position="float" orientation="portrait" hwp:id="graphic-47"/></alternatives>
</disp-formula>
where <italic toggle="yes">ψ</italic> is digamma function. In the same way, we can calculate the expectation of the logarithm <italic toggle="yes">α<sub>t</sub></italic>:
<disp-formula hwp:id="disp-formula-44">
<alternatives hwp:id="alternatives-122"><graphic xlink:href="060012v3_ueqn38.gif" position="float" orientation="portrait" hwp:id="graphic-48"/></alternatives>
</disp-formula></p><p hwp:id="p-150">Then the logarithm of probability <inline-formula hwp:id="inline-formula-79"><alternatives hwp:id="alternatives-123"><inline-graphic xlink:href="060012v3_inline79.gif" hwp:id="inline-graphic-79"/></alternatives></inline-formula> is estimated as
<disp-formula hwp:id="disp-formula-45">
<alternatives hwp:id="alternatives-124"><graphic xlink:href="060012v3_ueqn39.gif" position="float" orientation="portrait" hwp:id="graphic-49"/></alternatives>
</disp-formula></p><p hwp:id="p-151">Similarly, we can estimate the variance of the estimates <inline-formula hwp:id="inline-formula-80"><alternatives hwp:id="alternatives-125"><inline-graphic xlink:href="060012v3_inline80.gif" hwp:id="inline-graphic-80"/></alternatives></inline-formula>, where <italic toggle="yes">ψ</italic><sub>1</sub> is trigamma function. From this we can approximate a standard error of our estimator as:
<disp-formula hwp:id="disp-formula-46">
<alternatives hwp:id="alternatives-126"><graphic xlink:href="060012v3_ueqn40.gif" position="float" orientation="portrait" hwp:id="graphic-50"/></alternatives>
</disp-formula></p><p hwp:id="p-152">The same approach with digamma functions is used to calculate the logarithm of the probabilities <inline-formula hwp:id="inline-formula-81"><alternatives hwp:id="alternatives-127"><inline-graphic xlink:href="060012v3_inline81.gif" hwp:id="inline-graphic-81"/></alternatives></inline-formula> and P (<italic toggle="yes">s<sub>r</sub></italic> (<italic toggle="yes">q</italic>) ⩾ 0).</p></sec><sec id="s2e5" hwp:id="sec-17"><label>2.5.5</label><title hwp:id="title-20">Optimizations and implementation details</title><p hwp:id="p-153">The most demanding step of FGSEA-multilevel algorithm is to check whether the newly obtained gene set has the enrichments score value of at least <italic toggle="yes">l<sub>i</sub></italic>. Importantly, this does not require full computation of enrichment score value. It is enough to show that there is at least one gene that has the running enrichment score value of at least <italic toggle="yes">l<sub>i</sub></italic> or, in other words, that at least one point on the enrichment score graph is farther away from the diagonal (<xref ref-type="fig" rid="figS1" hwp:id="xref-fig-5-2" hwp:rel-id="F5">Fig. S1</xref>) than some value calculated from <italic toggle="yes">l<sub>i</sub></italic>.</p><p hwp:id="p-154">Similarly to FGSEA-simple algorithm, a square root decomposition is used to split all the genes into approximately <inline-formula hwp:id="inline-formula-82"><alternatives hwp:id="alternatives-128"><inline-graphic xlink:href="060012v3_inline82.gif" hwp:id="inline-graphic-82"/></alternatives></inline-formula> blocks. The block boundaries are determined automatically on each level based on the existing sample in such a way, that each block contains approximately <inline-formula hwp:id="inline-formula-83"><alternatives hwp:id="alternatives-129"><inline-graphic xlink:href="060012v3_inline83.gif" hwp:id="inline-graphic-83"/></alternatives></inline-formula> genes. In particular this decomposition enables adding and removing genes in <inline-formula hwp:id="inline-formula-84"><alternatives hwp:id="alternatives-130"><inline-graphic xlink:href="060012v3_inline84.gif" hwp:id="inline-graphic-84"/></alternatives></inline-formula> time while keeping the gene set sorted.</p><p hwp:id="p-155">Unlike FGSEA-simple algorithm we will not maintain the convex hull but will apply a few heuristics to do the required check faster.</p><p hwp:id="p-156">First we check a “candidate” point which has a high chance to be at the required distance from the diagonal. If it is so, we do not have to continue the check. The “candidate” gene is carried our from the previous iterations, as the point where the successful check has been interrupted.</p><p hwp:id="p-157">Next we go block by block. At the beginning we construct a “rectangle” upper bound on the enrichment score value at the block, which can be obtained by moving all the genes of the block to its start. If this upper bound does not satisfy our criterion we can skip the block. Otherwise, we go gene by gene and calculate the enrichment score values until it reaches the required value or the end of the block is reached. In the former case the check is interrupted with a successful result.</p></sec><sec id="s2e6" hwp:id="sec-18"><label>2.5.6</label><title hwp:id="title-21">Comparison with the exact method</title><p hwp:id="p-158">To compare FGSEA-multilevel and the exact method on the same dataset we used rounded values of the gene-level statistics from the example data (<xref ref-type="sec" rid="s2b" hwp:id="xref-sec-4-2" hwp:rel-id="sec-4">section 2.2</xref>) as input data for both algorithms. Both algorithms calculated the probability <inline-formula hwp:id="inline-formula-85"><alternatives hwp:id="alternatives-131"><inline-graphic xlink:href="060012v3_inline85.gif" hwp:id="inline-graphic-85"/></alternatives></inline-formula>.</p><p hwp:id="p-159">The results of the algorithms for the pathways from the example data are shown on <xref ref-type="fig" rid="fig3" hwp:id="xref-fig-3-6" hwp:rel-id="F3">Fig 3c</xref>. The exact algorithm was run with <italic toggle="yes">ε</italic> = 10<sup>−40</sup>, all the probabilities were obtained with accuracy of at least six significant digits. For FGSEA-multilevel <italic toggle="yes">Z</italic> = 101 was used.</p><p hwp:id="p-160">We also calculated empirical estimation errors and compared it to the theoretical ones (<xref ref-type="fig" rid="fig3" hwp:id="xref-fig-3-7" hwp:rel-id="F3">Fig 3d</xref>). For this we generated 100 independent estimates for a range of ES values (corresponding to P-values of 10<sup>−4</sup> to 10<sup>−100</sup>, gene set sizes (from 15 to 250) and sample size (from 101 to 1001). The raw values are available in the Supplementary Table.</p></sec></sec><sec id="s2f" hwp:id="sec-19" hwp:rev-id="xref-sec-19-1"><label>2.6</label><title hwp:id="title-22">Filtering redundant pathways</title><p hwp:id="p-161">In this section we describe an algorithm to filter redundant pathways from the results of FGSEA.</p><p hwp:id="p-162">Let consider two pathways <italic toggle="yes">p</italic><sub>1</sub> and <italic toggle="yes">p</italic><sub>2</sub> that both have a significant GSEA P-value. There are two situations in which we will consider <italic toggle="yes">p</italic><sub>2</sub> to be non-redundant given <italic toggle="yes">p</italic><sub>1</sub>:
<list list-type="order" hwp:id="list-8"><list-item hwp:id="list-item-21"><p hwp:id="p-163">If pathway <italic toggle="yes">p</italic><sub>2</sub> is enriched even if we do not consider the genes from <italic toggle="yes">p</italic><sub>1</sub> at all. Formally, we calculate GSEA P-value for gene set <italic toggle="yes">p</italic><sub>2</sub> \<italic toggle="yes">p</italic><sub>1</sub> and gene-level statistics vector <italic toggle="yes">S</italic>[<italic toggle="yes">U</italic> \<italic toggle="yes">p</italic><sub>1</sub>] for all the genes except <italic toggle="yes">p</italic><sub>1</sub>. If the P-value is less than a pre-defined threshold, then pathway <italic toggle="yes">p</italic><sub>2</sub> is considered as non-redundant given <italic toggle="yes">p</italic><sub>1</sub>.</p></list-item><list-item hwp:id="list-item-22"><p hwp:id="p-164">If pathway <italic toggle="yes">p</italic><sub>2</sub> is enriched even if we consider only genes from <italic toggle="yes">p</italic><sub>1</sub>. Formally, we calculate GSEA P-value for gene set <italic toggle="yes">p</italic><sub>2</sub> ∩ <italic toggle="yes">p</italic><sub>1</sub> and gene-level statistics vector <italic toggle="yes">S</italic>[<italic toggle="yes">p</italic><sub>1</sub>] for the genes from <italic toggle="yes">p</italic><sub>1</sub>. Again, if the P-value is less than a pre-defined thresh old, then pathway <italic toggle="yes">p</italic><sub>2</sub> is considered as non-redundant given <italic toggle="yes">p</italic><sub>1</sub>.</p></list-item></list></p><p hwp:id="p-165">Otherwise pathway <italic toggle="yes">p</italic><sub>2</sub> is considered to be redundant.</p><p hwp:id="p-166">The filtering procedure starts with a set of significantly enriched pathways <italic toggle="yes">P<sub>sig</sub></italic> selected by the user: for example the pathways with GSEA P-values less than 0.01 after Benjamini-Hochberg correction, sorted by P-value. The output of the procedure is a list <italic toggle="yes">P<sub>main</sub></italic> ⊂ <italic toggle="yes">P<sub>sig</sub></italic> of pathways that are pairwise non-redundant. At the same time, all the other pathways <italic toggle="yes">P<sub>red</sub></italic> = <italic toggle="yes">P<sub>sig</sub></italic> \ <italic toggle="yes">P<sub>main</sub></italic> are redundant given some pathway from <italic toggle="yes">P<sub>sig</sub></italic>.</p><p hwp:id="p-167">The procedure itself is similar to Sieve of Eratothenes algorithm. The pathways are considered one by one and some of them are marked as redundant. For a pathway <italic toggle="yes">p</italic> we first check if it is already marked as redundant, if yes, we go to the next pathway. Otherwise, we first run FGSEA-simple algorithm on a vector of statistics <italic toggle="yes">S</italic>[<italic toggle="yes">U</italic> \ <italic toggle="yes">p</italic>] and all the pathway currently not marked as redundant (including the ones that already have been considered, but excluding pathway <italic toggle="yes">p</italic>). Then, similarly, we run FGSEA-simple algorithm on a vector of statistics <italic toggle="yes">S</italic>[<italic toggle="yes">p</italic>]. Pathways that do not achieve non-redundant P-value threshold in both tests are marked as redundant.</p></sec></sec><sec sec-type="supplementary-material" hwp:id="sec-20"><title hwp:id="title-23">Supporting information</title><supplementary-material position="float" orientation="portrait" hwp:id="DC1"><object-id pub-id-type="other" hwp:sub-type="slug">DC1</object-id><label>Supplementary Table</label><media xlink:href="supplements/060012_file02.xlsx" position="float" orientation="portrait" hwp:id="media-1"/></supplementary-material></sec></body><back><ref-list hwp:id="ref-list-1"><title hwp:id="title-24">References</title><ref id="c1" hwp:id="ref-1" hwp:rev-id="xref-ref-1-1 xref-ref-1-2 xref-ref-1-3 xref-ref-1-4"><label>[1]</label><citation publication-type="journal" citation-type="journal" ref:id="060012v3.1" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-1"><string-name name-style="western" hwp:sortable="Subramanian Aravind"><given-names>Aravind</given-names> <surname>Subramanian</surname></string-name>, <string-name name-style="western" hwp:sortable="Tamayo Pablo"><given-names>Pablo</given-names> <surname>Tamayo</surname></string-name>, <string-name name-style="western" hwp:sortable="Mootha Vamsi K"><given-names>Vamsi K</given-names> <surname>Mootha</surname></string-name>, <string-name name-style="western" hwp:sortable="Mukherjee Sayan"><given-names>Sayan</given-names> <surname>Mukherjee</surname></string-name>, <string-name name-style="western" hwp:sortable="Ebert Benjamin L"><given-names>Benjamin L</given-names> <surname>Ebert</surname></string-name>, <string-name name-style="western" hwp:sortable="Gillette Michael A"><given-names>Michael A</given-names> <surname>Gillette</surname></string-name>, <string-name name-style="western" hwp:sortable="Paulovich Amanda"><given-names>Amanda</given-names> <surname>Paulovich</surname></string-name>, <string-name name-style="western" hwp:sortable="Pomeroy Scott L"><given-names>Scott L</given-names> <surname>Pomeroy</surname></string-name>, <string-name name-style="western" hwp:sortable="Golub Todd R"><given-names>Todd R</given-names> <surname>Golub</surname></string-name>, <string-name name-style="western" hwp:sortable="Lander Eric S"><given-names>Eric S</given-names> <surname>Lander</surname></string-name>, and <string-name name-style="western" hwp:sortable="Mesirov Jill P"><given-names>Jill P</given-names> <surname>Mesirov</surname></string-name>. <article-title hwp:id="article-title-2">Gene set enrichment analysis: a knowledge-based approach for interpreting genome-wide expression profiles</article-title>. <source hwp:id="source-1">Proceedings of the National Academy of Sciences of the United States of America</source>, <volume>102</volume>(<issue>43</issue>): <fpage>15545</fpage>–<lpage>50</lpage>, <year>2005</year>.</citation></ref><ref id="c2" hwp:id="ref-2" hwp:rev-id="xref-ref-2-1"><label>[2]</label><citation publication-type="journal" citation-type="journal" ref:id="060012v3.2" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-2"><string-name name-style="western" hwp:sortable="Yu G."><given-names>G.</given-names> <surname>Yu</surname></string-name>, <string-name name-style="western" hwp:sortable="Wang L. G."><given-names>L. G.</given-names> <surname>Wang</surname></string-name>, <string-name name-style="western" hwp:sortable="Yan G. R."><given-names>G. R.</given-names> <surname>Yan</surname></string-name>, and <string-name name-style="western" hwp:sortable="He Q. Y."><given-names>Q. Y.</given-names> <surname>He</surname></string-name>. <article-title hwp:id="article-title-3">DOSE: an R/Bioconductor package for disease ontology semantic and enrichment analysis</article-title>. <source hwp:id="source-2">Bioinformatics</source>, <volume>3l</volume>(<issue>4</issue>):<fpage>6O8</fpage>–<lpage>6O9</lpage>, <month>Feb</month> <year>2015</year>.</citation></ref><ref id="c3" hwp:id="ref-3" hwp:rev-id="xref-ref-3-1"><label>[3]</label><citation publication-type="journal" citation-type="journal" ref:id="060012v3.3" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-3"><string-name name-style="western" hwp:sortable="Varemo L."><given-names>L.</given-names> <surname>Varemo</surname></string-name>, <string-name name-style="western" hwp:sortable="Nielsen J."><given-names>J.</given-names> <surname>Nielsen</surname></string-name>, and <string-name name-style="western" hwp:sortable="Nookaew I."><given-names>I.</given-names> <surname>Nookaew</surname></string-name>. <article-title hwp:id="article-title-4">Enriching the gene set analysis of genomewide data by incorporating directionality of gene expression and combining statistical hypotheses and methods</article-title>. <source hwp:id="source-3">Nucleic Acids Res</source>., <volume>4l</volume>(<issue>8</issue>):<fpage>4378</fpage>–<lpage>439l</lpage>, <month>Apr</month> <year>2013</year>.</citation></ref><ref id="c4" hwp:id="ref-4" hwp:rev-id="xref-ref-4-1 xref-ref-4-2"><label>[4]</label><citation publication-type="journal" citation-type="journal" ref:id="060012v3.4" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-4"><string-name name-style="western" hwp:sortable="Wei Gang"><given-names>Gang</given-names> <surname>Wei</surname></string-name>, <string-name name-style="western" hwp:sortable="Wei Lai"><given-names>Lai</given-names> <surname>Wei</surname></string-name>, <string-name name-style="western" hwp:sortable="Zhu Jinfang"><given-names>Jinfang</given-names> <surname>Zhu</surname></string-name>, <string-name name-style="western" hwp:sortable="Zang Chongzhi"><given-names>Chongzhi</given-names> <surname>Zang</surname></string-name>, <string-name name-style="western" hwp:sortable="Hu-Li Jane"><given-names>Jane</given-names> <surname>Hu-Li</surname></string-name>, <string-name name-style="western" hwp:sortable="Yao Zhengju"><given-names>Zhengju</given-names> <surname>Yao</surname></string-name>, <string-name name-style="western" hwp:sortable="Cui Kairong"><given-names>Kairong</given-names> <surname>Cui</surname></string-name>, <string-name name-style="western" hwp:sortable="Kanno Yuka"><given-names>Yuka</given-names> <surname>Kanno</surname></string-name>, <string-name name-style="western" hwp:sortable="Roh Tae-Young"><given-names>Tae-Young</given-names> <surname>Roh</surname></string-name>, <string-name name-style="western" hwp:sortable="Watford Wendy T"><given-names>Wendy T</given-names> <surname>Watford</surname></string-name>, <string-name name-style="western" hwp:sortable="Schones Dustin E"><given-names>Dustin E</given-names> <surname>Schones</surname></string-name>, <string-name name-style="western" hwp:sortable="Peng Weiqun"><given-names>Weiqun</given-names> <surname>Peng</surname></string-name>, <string-name name-style="western" hwp:sortable="Sun Hong-Wei"><given-names>Hong-Wei</given-names> <surname>Sun</surname></string-name>, <string-name name-style="western" hwp:sortable="Paul William E"><given-names>William E</given-names> <surname>Paul</surname></string-name>, <string-name name-style="western" hwp:sortable="O’Shea John J"><given-names>John J</given-names> <surname>O’Shea</surname></string-name>, and <string-name name-style="western" hwp:sortable="Zhao Keji"><given-names>Keji</given-names> <surname>Zhao</surname></string-name>. <article-title hwp:id="article-title-5">Global mapping of H3K4me3 and H3K27me3 reveals specificity and plasticity in lineage fate determination of differentiating CD4+ T cells</article-title>. <source hwp:id="source-4">Immunity</source>, <volume>3O</volume>(<issue>l</issue>):<fpage>l55</fpage>—<lpage>67</lpage>, <year>2009</year>.</citation></ref><ref id="c5" hwp:id="ref-5" hwp:rev-id="xref-ref-5-1 xref-ref-5-2"><label>[5]</label><citation publication-type="journal" citation-type="journal" ref:id="060012v3.5" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-5"><string-name name-style="western" hwp:sortable="Joshi-Tope G"><given-names>G</given-names> <surname>Joshi-Tope</surname></string-name>, <string-name name-style="western" hwp:sortable="Gillespie M"><given-names>M</given-names> <surname>Gillespie</surname></string-name>, <string-name name-style="western" hwp:sortable="Vastrik I"><given-names>I</given-names> <surname>Vastrik</surname></string-name>, <string-name name-style="western" hwp:sortable="D’Eustachio P"><given-names>P</given-names> <surname>D’Eustachio</surname></string-name>, <string-name name-style="western" hwp:sortable="Schmidt E"><given-names>E</given-names> <surname>Schmidt</surname></string-name>, <string-name name-style="western" hwp:sortable="de Bono B"><given-names>B</given-names> <surname>de Bono</surname></string-name>, <string-name name-style="western" hwp:sortable="Jassal B"><given-names>B</given-names> <surname>Jassal</surname></string-name>, <string-name name-style="western" hwp:sortable="Gopinath G R"><given-names>G R</given-names> <surname>Gopinath</surname></string-name>, <string-name name-style="western" hwp:sortable="Wu G R"><given-names>G R</given-names> <surname>Wu</surname></string-name>, <string-name name-style="western" hwp:sortable="Matthews L"><given-names>L</given-names> <surname>Matthews</surname></string-name>, <string-name name-style="western" hwp:sortable="Lewis S"><given-names>S</given-names> <surname>Lewis</surname></string-name>, <string-name name-style="western" hwp:sortable="Birney E"><given-names>E</given-names> <surname>Birney</surname></string-name>, and <string-name name-style="western" hwp:sortable="Stein L"><given-names>L</given-names> <surname>Stein</surname></string-name>. <article-title hwp:id="article-title-6">Reactome: a knowledgebase of biological pathways</article-title>. <source hwp:id="source-5">Nucleic acids research</source>, <volume>33</volume>(<issue>Database issue</issue>):<fpage>D428</fpage>–<lpage>32</lpage>, <year>2005</year>.</citation></ref><ref id="c6" hwp:id="ref-6" hwp:rev-id="xref-ref-6-1 xref-ref-6-2"><label>[6]</label><citation publication-type="journal" citation-type="journal" ref:id="060012v3.6" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-6"><string-name name-style="western" hwp:sortable="Botev Zdravko I"><given-names>Zdravko I</given-names> <surname>Botev</surname></string-name> and <string-name name-style="western" hwp:sortable="Kroese Dirk P"><given-names>Dirk P</given-names> <surname>Kroese</surname></string-name>. <article-title hwp:id="article-title-7">An efficient algorithm for rare-event probability estimation, combinatorial optimization, and counting</article-title>. <source hwp:id="source-6">Methodology and Computing in Applied Probability</source>, <volume>lO</volume>(<issue>4</issue>):<fpage>47l</fpage>–<lpage>5O5</lpage>, <year>2008</year>.</citation></ref><ref id="c7" hwp:id="ref-7" hwp:rev-id="xref-ref-7-1"><label>[7]</label><citation publication-type="journal" citation-type="journal" ref:id="060012v3.7" ref:linkable="yes" ref:use-reference-as-is="yes" hwp:id="citation-7"><string-name name-style="western" hwp:sortable="Jantzen S. G."><given-names>S. G.</given-names> <surname>Jantzen</surname></string-name>, <string-name name-style="western" hwp:sortable="Sutherland B. J."><given-names>B. J.</given-names> <surname>Sutherland</surname></string-name>, <string-name name-style="western" hwp:sortable="Minkley D. R."><given-names>D. R.</given-names> <surname>Minkley</surname></string-name>, and <string-name name-style="western" hwp:sortable="Koop B. F."><given-names>B. F.</given-names> <surname>Koop</surname></string-name>. <article-title hwp:id="article-title-8">GO Trimming: Systematically reducing redundancy in large Gene Ontology datasets</article-title>. <source hwp:id="source-7">BMC Res Notes</source>, <volume>4</volume>:<fpage>267</fpage>, <month>Jul</month> <year>2011</year>.</citation></ref><ref id="c8" hwp:id="ref-8" hwp:rev-id="xref-ref-8-1"><label>[8]</label><citation publication-type="other" citation-type="journal" ref:id="060012v3.8" ref:linkable="no" ref:use-reference-as-is="yes" hwp:id="citation-8"><string-name name-style="western" hwp:sortable="Ritchie M. E."><given-names>M. E.</given-names> <surname>Ritchie</surname></string-name>, <string-name name-style="western" hwp:sortable="Phipson B."><given-names>B.</given-names> <surname>Phipson</surname></string-name>, <string-name name-style="western" hwp:sortable="Wu D."><given-names>D.</given-names> <surname>Wu</surname></string-name>, <string-name name-style="western" hwp:sortable="Hu Y."><given-names>Y.</given-names> <surname>Hu</surname></string-name>, <string-name name-style="western" hwp:sortable="Law C. W."><given-names>C. W.</given-names> <surname>Law</surname></string-name>, <string-name name-style="western" hwp:sortable="Shi W."><given-names>W.</given-names> <surname>Shi</surname></string-name>, and <string-name name-style="western" hwp:sortable="Smyth G. K."><given-names>G. K.</given-names> <surname>Smyth</surname></string-name>, <article-title hwp:id="article-title-9">limma powers differential expression analyses for RNA-sequencing and microarray studies</article-title>. <source hwp:id="source-8">Nucleic Acids Research</source>, pages <fpage>gkvOO7</fpage>-, <year>2015</year>.</citation></ref><ref id="c9" hwp:id="ref-9" hwp:rev-id="xref-ref-9-1"><label>[9]</label><citation publication-type="journal" citation-type="journal" ref:id="060012v3.9" ref:linkable="no" ref:use-reference-as-is="yes" hwp:id="citation-9"><string-name name-style="western" hwp:sortable="Phipson Belinda"><given-names>Belinda</given-names> <surname>Phipson</surname></string-name> and <string-name name-style="western" hwp:sortable="Smyth Gordon K"><given-names>Gordon K</given-names> <surname>Smyth</surname></string-name>. <article-title hwp:id="article-title-10">Permutation p-values should never be zero: calculating exact p-values when permutations are randomly drawn</article-title>. <source hwp:id="source-9">Statistical applications in genetics and molecular biology</source>, <volume>9</volume>(<issue>1</issue>), <year>2010</year>.</citation></ref><ref id="c10" hwp:id="ref-10" hwp:rev-id="xref-ref-10-1"><label>[10]</label><citation publication-type="journal" citation-type="journal" ref:id="060012v3.10" ref:linkable="no" ref:use-reference-as-is="yes" hwp:id="citation-10"><string-name name-style="western" hwp:sortable="Cormen Thomas H"><given-names>Thomas H</given-names> <surname>Cormen</surname></string-name>, <string-name name-style="western" hwp:sortable="Leiserson Charles E"><given-names>Charles E</given-names> <surname>Leiserson</surname></string-name>, <string-name name-style="western" hwp:sortable="Rivest Ronald L"><given-names>Ronald L</given-names> <surname>Rivest</surname></string-name>, and <string-name name-style="western" hwp:sortable="Stein Clifford"><given-names>Clifford</given-names> <surname>Stein</surname></string-name>. <source hwp:id="source-10">Intro-duction to Algorithms</source>, <edition>Second</edition> Edition, volume <volume>7</volume>. <year>2001</year>.</citation></ref></ref-list></back></article>
