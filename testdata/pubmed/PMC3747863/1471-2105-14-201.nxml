<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.0 20120330//EN" "JATS-archivearticle1.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="product-review" xml:lang="en"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id><journal-title-group><journal-title>BMC Bioinformatics</journal-title></journal-title-group><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">23786315</article-id><article-id pub-id-type="pmc">3747863</article-id><article-id pub-id-type="publisher-id">1471-2105-14-201</article-id><article-id pub-id-type="doi">10.1186/1471-2105-14-201</article-id><article-categories><subj-group subj-group-type="heading"><subject>Software</subject></subj-group></article-categories><title-group><article-title>Bioinformatic pipelines in Python with Leaf</article-title></title-group><contrib-group><contrib contrib-type="author" corresp="yes" id="A1"><name><surname>Napolitano</surname><given-names>Francesco</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>fnapolitano@unisa.it</email></contrib><contrib contrib-type="author" id="A2"><name><surname>Mariani-Costantini</surname><given-names>Renato</given-names></name><xref ref-type="aff" rid="I2">2</xref><xref ref-type="aff" rid="I3">3</xref><email>rmc@unich.it</email></contrib><contrib contrib-type="author" id="A3"><name><surname>Tagliaferri</surname><given-names>Roberto</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>rtagliaferri@unisa.it</email></contrib></contrib-group><aff id="I1"><label>1</label>Department of Computer Science (DI),University of Salerno, Fisciano (SA) 84084, Italy</aff><aff id="I2"><label>2</label>Department of Medicine, Dentistry and Biotechnology &#x0201c;G. d&#x02019;Annunzio&#x0201d; University, Chieti-Pescara, Italy</aff><aff id="I3"><label>3</label>Unit of General Pathology, Aging Research Center (CeSI) &#x0201c;G. d&#x02019;Annunzio&#x0201d; University Foundation, Via Luigi Polacchi 15/17, Chieti 66100, Italy</aff><pub-date pub-type="collection"><year>2013</year></pub-date><pub-date pub-type="epub"><day>21</day><month>6</month><year>2013</year></pub-date><volume>14</volume><fpage>201</fpage><lpage>201</lpage><history><date date-type="received"><day>25</day><month>2</month><year>2013</year></date><date date-type="accepted"><day>10</day><month>6</month><year>2013</year></date></history><permissions><copyright-statement>Copyright &#x000a9; 2013 Napolitano et al; licensee BioMed Central Ltd.</copyright-statement><copyright-year>2013</copyright-year><copyright-holder>Napolitano et al; licensee BioMed Central Ltd.</copyright-holder><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0"><license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0">http://creativecommons.org/licenses/by/2.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p></license></permissions><self-uri xlink:href="http://www.biomedcentral.com/1471-2105/14/201"/><abstract><sec><title>Background</title><p>An incremental, loosely planned development approach is often used in bioinformatic studies when dealing with custom data analysis in a rapidly changing environment. Unfortunately, the lack of a rigorous software structuring can undermine the maintainability, communicability and replicability of the process. To ameliorate this problem we propose the Leaf system, the aim of which is to seamlessly introduce the pipeline formality on top of a dynamical development process with minimum overhead for the programmer, thus providing a simple layer of software structuring.</p></sec><sec><title>Results</title><p>Leaf includes a formal language for the definition of pipelines with code that can be transparently inserted into the user&#x02019;s Python code. Its syntax is designed to visually highlight dependencies in the pipeline structure it defines. While encouraging the developer to think in terms of bioinformatic pipelines, Leaf supports a number of automated features including data and session persistence, consistency checks between steps of the analysis, processing optimization and publication of the analytic protocol in the form of a hypertext.</p></sec><sec><title>Conclusions</title><p>Leaf offers a powerful balance between plan-driven and change-driven development environments in the design, management and communication of bioinformatic pipelines. Its unique features make it a valuable alternative to other related tools.</p></sec></abstract><kwd-group><kwd>Data analysis</kwd><kwd>Bioinformatic pipelines</kwd><kwd>Python</kwd></kwd-group></article-meta></front><body><sec><title>Background</title><p>Systemic Bioinformatic analysis requires heterogeneously composed research groups, including data producers, data miners and application domain experts (such as biologists). Data producers use dedicated technology on biological specimen to extract data; data miners analyze data and try to highlight relevant information; biologists examine the filtered data, which thy then validate through targeted experiments and use to support their hypothesis or to formulate new ones (See Figure <xref ref-type="fig" rid="F1">1</xref>). Custom bioinformatic analysis requires programmers to implement new methods and/or put together existing ones in order to build new data analysis frameworks (data flows [<xref ref-type="bibr" rid="B1">1</xref>], commonly known as bioinformatic pipelines). In such cases, high level scripting languages are used (such as Python, Perl, R, Matlab) to quickly implement and test new methodologies and present results to other research groups, while statically typed languages (like C, C++, Java) are generally preferred when computational performance is crucial [<xref ref-type="bibr" rid="B2">2</xref>-<xref ref-type="bibr" rid="B4">4</xref>].</p><fig id="F1" position="float"><label>Figure 1</label><caption><p><bold>Example of bioinformatic collaboration.</bold> Bioinformatic research collaboration scheme. This is a representation of a typical process in a bioinformatic study where different research units are involved. The left part of the scheme represents a loop with iterations that are usually cheaper (no consumables or expensive technologies involved) and more prone to be iterated over time in order to refine the analysis based on partial results. This loop represents a major challenge in terms of code maintainability.</p></caption><graphic xlink:href="1471-2105-14-201-1"/></fig><p>Indeed the priority of custom data analysis software is above all about results, while features like code maintainability, documentation and portability are often considered secondary. In our experience, a precise design of the analysis process is usually impossible to achieve in advance, since the feedback produced by preliminary results may drive the study in unpredictable directions. In fact, the main shortcoming of plan-based development paradigms is in their lack of responsiveness to change. Software Engineering deals with such issue by means of dedicated development models (Extreme Programming, Prototype-based Programming [<xref ref-type="bibr" rid="B5">5</xref>], Agile development [<xref ref-type="bibr" rid="B6">6</xref>]) that try to relax formal constraints in order to more easily adapt to dynamic conditions [<xref ref-type="bibr" rid="B6">6</xref>].</p><p>However, if taken to an extreme, prototype-based approaches tend to undermine the integrity of the system&#x02019;s architecture [<xref ref-type="bibr" rid="B7">7</xref>], accumulating patches as more requests are fulfilled. The resulting analysis is often hard to reproduce, which is also due to difficulties with establishing its execution provenance [<xref ref-type="bibr" rid="B8">8</xref>-<xref ref-type="bibr" rid="B10">10</xref>]. Such challenges have been recently evinced in [<xref ref-type="bibr" rid="B11">11</xref>], where urgency for open source code in scientific development was emphasized as a consequence of the difficulty of reproducing bioinformatic results and accounting for all the technical aspects of a bioinformatic analysis. In addition, we note that loosely structured and poorly documented processes can hardly be reproduced even when source code is available.</p><p>In order to take into account the need to reduce planning and at the same time maintain high level structuring in bioinformatic analyses, we developed the <italic>Leaf </italic>[<xref ref-type="bibr" rid="B12">12</xref>,<xref ref-type="bibr" rid="B13">13</xref>] system (Figures <xref ref-type="fig" rid="F2">2</xref> and <xref ref-type="fig" rid="F3">3</xref>). Its purpose is to allow for the transparent association of regular code written in a high-level programming languages with a pipeline structure. To this aim, Leaf implements a graph design language (namely LGL, Leaf Graph Language, see Figure <xref ref-type="fig" rid="F4">4</xref> for a brief overview) that allows the programmer to define the high level pipeline describing his analysis directly within his source code in other languages. Specifically, we developed LGL support for the Python language, implemented as the Pyleaf library. Python was chosen as a high level, dynamically typed, general purpose, interpreted language, that offers interoperability with other languages (like R) and clean, readable code [<xref ref-type="bibr" rid="B2">2</xref>]. Moreover, a growing community of Bioinformaticians has shown interest in the Python language, also through the development of tools like those collected in the Biopython project [<xref ref-type="bibr" rid="B14">14</xref>]. The LGL language provides an extremely minimalist approach, enforcing almost no conventions as to how the pipeline nodes must be implemented.</p><fig id="F2" position="float"><label>Figure 2</label><caption><p><bold>Leaf architecture.</bold> A Leaf project is carried out by three different layers. On the top layer, a high level definition of a pipeline is coded through the Leaf Graph Language (LGL). The Pyleaf library is able to interpret an LGL graph as a computational pipeline and bind the nodes of the pipeline to the user&#x02019;s Python code.</p></caption><graphic xlink:href="1471-2105-14-201-2"/></fig><fig id="F3" position="float"><label>Figure 3</label><caption><p><bold>User interaction.</bold> The interaction between the user&#x02019;s Python code and the Leaf system happens through the definition of an LGL graph (the high level pipeline) and the use of Pyleaf. The user creates a new Leaf project by providing Pyleaf with the pipeline definition, the Python code implementing each node of the pipeline and the primary resources to work on. The project is then used to request the production of resources.</p></caption><graphic xlink:href="1471-2105-14-201-3"/></fig><fig id="F4" position="float"><label>Figure 4</label><caption><p><bold>LGL syntax examples.</bold> This figure shows some examples of graph structures defined through the Leaf Graph Language (LGL). Tree structures of any depth and degree can be encoded using the fork arrow (<monospace>&#x0003c;</monospace>) and void node (<monospace>.</monospace>) mechanisms. Note that through LGL it is possible to define graphs that are not DAGs (see main text), though they are not allowed by Pyleaf.</p></caption><graphic xlink:href="1471-2105-14-201-4"/></fig><p>The formal definition of a pipeline is used by Leaf to provide a number of automated features described in the next sections. As a final output, Leaf is able to generate a hypertext document describing both the high level design and all the details of the analysis (the <italic>bioinformatic protocol</italic>), including provenance information.</p><sec><title>Previous work</title><p>The development of data flow management systems has recently become a very active area in bioinformatics [<xref ref-type="bibr" rid="B15">15</xref>]. Though an extensive review of the existing tools is out of the scope of this paper, a simple overview will be useful in order to identify the strengths and weaknesses of Leaf with respect to related software. In order to correctly place Leaf in the landscape of other tools, we divide them into three categories, based on the thickness of the abstraction layer between the pipeline definition and its implementation. Of course the three categories are not perfectly disjoint, as some tools may cross their boundaries.</p><p>In general, the most high-level tools try to encapsulate implementation details as much as possible in order to facilitate interactions with the top layer of the analysis. The user is presented with a Graphical User Interface and builds a bioinformatic pipeline with point-and-click applications. Examples of graphical approaches include Galaxy [<xref ref-type="bibr" rid="B16">16</xref>], Taverna [<xref ref-type="bibr" rid="B17">17</xref>], Pegasys [<xref ref-type="bibr" rid="B18">18</xref>], Conveyor [<xref ref-type="bibr" rid="B19">19</xref>], Kepler [<xref ref-type="bibr" rid="B20">20</xref>]. Such tools often include support for extending their functionality through either dedicated or existing scripting languages, allowing for additional flexibility. However, their main focus and strength is about simplifying the management of the data flow structure, while lower level changes are not as immediate. Most of these tools are also suitable for researchers without programming skills.</p><p>A thinner abstraction layer is provided by a number of pipeline design tools based on formal languages, such as Anduril [<xref ref-type="bibr" rid="B21">21</xref>] and Biopipe [<xref ref-type="bibr" rid="B22">22</xref>]. The purpose of these tools is to provide robust general frameworks for data analysis that can recognize and integrate heterogeneous data structures. Unlike the higher-level tools, these approaches usually require the user to make the effort of formally describing data formats and processing semantics, after learning the adopted conventions. Their strength is in their ability to ensure the robustness of the processes while at the same time granting access to low level details.</p><p>The thinnest abstraction layers allow the user to easily bypass the pipeline manager itself, if needed. Leaf sits in this category, together with other tools like Ruffus [<xref ref-type="bibr" rid="B23">23</xref>] and Bpipe [<xref ref-type="bibr" rid="B24">24</xref>]. These systems are specifically designed for users with programming skills and their aim is neither to broaden pipeline management accessibility to a wider audience nor to guarantee a particular robustness of the process through the rigorous specification of data and exchange formats. On the contrary, their aim is to provide an easy data flow management support within existing development environments in order to simplify the coding process and encourage direct modifications of low level details. They are usually the most light-weight tools among data flow managers and are implemented as libraries or ad-hoc scripting languages. In the following we justify the development of Leaf by detailing the main differences between it and the other tools in the same category just mentioned: Bpipe and Ruffus.</p><p>The major shortcoming of Ruffus has been highlighted in [<xref ref-type="bibr" rid="B24">24</xref>] as their own motivation: the syntactic mechanism of Python &#x0201c;decoration&#x0201d;, which is the basis of Ruffus implementation, spreads the design of the pipeline structure throughout the code. Tasks like reading or modifying the data flow structure can be quite involved, since no general overview of the pipeline is actually present in the code. Conversely, the LGL formal language developed for Leaf is intended to be intuitively readable, having the unique feature that its code visually represents the pipeline it encodes (Figure <xref ref-type="fig" rid="F4">4</xref>). Most importantly, the Leaf system keeps the definition of the pipeline in one place and completely separated from the Python code implementing the single nodes (though still in the same Python source file). The LGL is a dedicated language with its own syntax, thus requiring some additional effort that is not required for Ruffus. However, the overall learning curves of the two systems on the whole are comparable. It should also be pointed out that an advanced LGL coding style, while producing visually rich code, also makes it harder to maintain. This is why, in addition to complex syntactic constructs, we also provided simple shortcuts, which allow the programmer to choose his preferred level of balance between easy to read and easy to write code. Figure <xref ref-type="fig" rid="F5">5</xref> shows a comparison between two Leaf and Ruffus code fragments and describes some additional Leaf features that are not currently supported by Ruffus.</p><fig id="F5" position="float"><label>Figure 5</label><caption><p><bold>Comparison between Ruffus and Leaf code.</bold> Code for pipeline definition and use is highlighted in bold. Both samples implement the same simple pipeline made of three nodes (namely <monospace>first_task</monospace>, <monospace>second_task</monospace> and <monospace>third_task</monospace>), the first passes a text string to the other two, which in turn append some additional text to it. In Ruffus (left) the pipeline structure is defined through the &#x0201c;@follows&#x0201d; decorator, which must be attached to each function definition in order to specify its ascendants. In Leaf (right) the pipeline structure is visually defined as standalone LGL code (first lines in the example). Ruffus keeps track of produced resources by checking files specified through the &#x0201c;@files&#x0201d; decorator, which is the main tool for exchanging data between nodes. Leaf uses common function parameters while seamlessly caching their content on the disk to track the processing status. Leaf also caches the source code that produces each resource, and is thus able to detect changes in the code and invalidate all the resources affected by the change. The Ruffus file-based mechanism is also supported by Leaf through the &#x0201c;F&#x0201d; flag in LGL with the only requirement being that the function producing the files as their resources must return the corresponding file names (see main text).</p></caption><graphic xlink:href="1471-2105-14-201-5"/></fig><p>Like Leaf, Bpipe includes a dedicated language to define pipeline structures. However, Bpipe is primarily intended to be a pipeline-oriented replacement of shell scripts, built to run a pipeline of system commands that exchange data through files on the disk. This approach is the most straightforward, for example, in any environment where nodes of the pipeline are standalone programs. On the contrary, Leaf is meant to provide pipeline management support for general purpose scripting languages, such as Python. Nodes are implemented as functions that can exchange structured variables of arbitrary complexity in primary memory (the use of files is optional). With Leaf (and Ruffus), the definition of such functions can be provided together with the pipeline structure in the same source file.</p></sec></sec><sec><title>Concepts</title><p>In this section we introduce the concepts that formalizes the idea of bioinformatic pipeline implemented in Leaf. A Leaf pipeline is designed incrementally throughout the development phase of a bioinformatic analysis. Once the analysis is completed, a final protocol can be generated that documents the analysis process.</p><sec><title>Resources and processors</title><p>In our view, there are two kinds of actors in a data analysis process: Resources and processors. Resources are any type of data, including raw data, processed data, images, files etc. Here, by &#x0201c;raw data&#x0201d; we mean data at any stage that does not represent a final result of the analysis. Processors are computer routines that can modify existing resources or create new ones.</p><p>We subsequently distinguish between <italic>primary</italic> and <italic>derived</italic> resources. Primary resources are the initial input to the process and should be regarded as the ground truth of the analysis. Derived resources are obtained exclusively as automatic elaborations of primary resources. Exceptions to this constraint, like the introduction of manual interventions or implicit dependence on resources that are not part of the pipeline, could cause any automatic consistency check to fail. Derived resources can be further divided into <italic>raw</italic> resources (representing data at an intermediate processing stage) and <italic>final</italic> resources (representing the results of the analysis).</p></sec><sec><title>Bioinformatic protocols as annotated DAGs</title><p>A graph [<xref ref-type="bibr" rid="B25">25</xref>] is an ordered couple (<italic>V</italic>,<italic>E</italic>), where <italic>V</italic> is a set of nodes and <italic>E</italic>&#x02009;&#x02208;&#x02009;<italic>V</italic>&#x02009;&#x000d7;&#x02009;<italic>V</italic> is a set of edges between nodes. Let us consider processors as nodes in a graph and resources as edges, such that, for example, a graph (<italic>V</italic>&#x02009;=&#x02009;{<italic>x</italic>,<italic>y</italic>,<italic>z</italic>}, <italic>E</italic>&#x02009;=&#x02009;{(<italic>x</italic>,<italic>y</italic>),(<italic>y</italic>,<italic>z</italic>)}) represents a data flow where the processor <italic>x</italic> provides (imports or generates) a primary resource passed through the edge (<italic>x</italic>,<italic>y</italic>) to the node <italic>y</italic>. The node <italic>y</italic> produces the raw derived resource passed through the node (<italic>y</italic>,<italic>z</italic>) to the node <italic>z</italic>. The node <italic>z</italic> produces a final derived resource. In our context a graph describing a data flow must be directed and acyclic (DAG).</p><p>We define a bioinformatic protocol as an annotated DAG. Here, annotations are all the details that are necessary to understand and execute the procedure described by the graph, including source code and documentation of the processors and the produced resources. Leaf protocols also include statistics detailing the time and space consumed by the execution of each node. Finally, since the actual implementation of Leaf requires each node to produce only one resource (even though it can be a structured object), the association of resources with edges is equivalent to the association of resources with nodes.</p></sec></sec><sec><title>Implementation</title><p>Leaf is a software tool that supports the generation and use of bioinformatic pipelines as defined in the previous section. The Leaf system is composed of two subsystems (see Figure <xref ref-type="fig" rid="F2">2</xref>): the Leaf Graph Language (LGL) and the Pyleaf Python library, which are described in the following subsections. The user provides the description of a graph in LGL language together with the Python source code implementing the nodes. Then he has access to Leaf features through the Pyleaf interface (see Figure <xref ref-type="fig" rid="F3">3</xref>). Pyleaf transparently runs an external compiler that translates the LGL code into a simpler description of a graph structure. It then uses this structure to understand dependencies between nodes in the pipeline and to run the necessary nodes according to the user&#x02019;s requests. In general, LGL source code is meant to be embedded into source code of other languages (see Figure <xref ref-type="fig" rid="F6">6</xref>) and exploited through ad hoc libraries. Pyleaf is the library that implements the Leaf system for the Python language (see Figure <xref ref-type="fig" rid="F7">7</xref>).</p><fig id="F6" position="float"><label>Figure 6</label><caption><p><bold>Source code embedded pipeline definition.</bold> Any programming language supporting multi-line text can include the definition of a pipeline as LGL code. Left: a Python example including an LGL graph definition whose nodes are implemented in the same source file. Right: a graphic representation of the corresponding pipeline.</p></caption><graphic xlink:href="1471-2105-14-201-6"/></fig><fig id="F7" position="float"><label>Figure 7</label><caption><p><bold>Coexistence of leaf and python.</bold> (<bold>A</bold>) Python source code including a pipeline definition as an LGL graph (Section &#x0201c;Concepts&#x0201d; in the source code), the implementation of the corresponding nodes and a function creating and returning a Leaf project object accordingly. (<bold>B</bold>) Example of a Python interactive session where the user loads the previous Python code, creates the Leaf project and request the production of a resource. The user can directly call pipeline nodes as regular Python functions by passing the input parameters manually. Leaf can call them automatically for the production of a resource as necessary. The thinness of the Pyleaf library abstraction layer allows for quick prototyping and experimentation.</p></caption><graphic xlink:href="1471-2105-14-201-7"/></fig><p>The LGL compiler (lglc) was built using the <italic>Flex </italic>[<xref ref-type="bibr" rid="B26">26</xref>] lexical analyzer and the <italic>Bison </italic>[<xref ref-type="bibr" rid="B27">27</xref>] parser generator. The compiler currently supports basic error handling, pointing out the line of code where a syntax error is detected. This proves very useful when editing complex graphs. On the other hand, errors detected in the node implementations are handled by the Python interpreter as usual: Leaf does not interfere with this mechanism other than adding its methods to the call stack.</p><p>Graph visualizations are produced using <italic>Graphviz</italic> tools [<xref ref-type="bibr" rid="B28">28</xref>]. More details can be found on the home page of Leaf [<xref ref-type="bibr" rid="B12">12</xref>] and on its public source code repository [<xref ref-type="bibr" rid="B13">13</xref>].</p><sec><title>The leaf graph language</title><p>The Leaf Graph Language (LGL) is a formal language with the unique feature of having a graphical appearance even though it is written in regular text. The purpose of LGL is to encode general graph structures (including graphs containing cycles, which are not supported by Pyleaf). An LGL graph definition can be directly embedded in the code of other programming languages to serve as a high level pipeline description. While a formal description of the language&#x02019;s grammar is beyond the scope of this paper, in this subsection we present a few examples as well as the main syntax rules in order to illustrate its basic philosophy.</p><p>The fundamental objects in LGL are items, item sets, and arrows connecting items or item sets. Each item may represent a graph node or an entire graph by itself, while an arrow may represent a single edge or a set of edges. For example, the statement:<disp-formula><graphic xlink:href="1471-2105-14-201-i1.gif"/></disp-formula></p><p>is an LGL instruction that creates a graph with three nodes, <italic>A</italic>,<italic>B</italic> and <italic>C</italic>, and connects node <monospace>A</monospace> (single item) to the set of nodes composed of <monospace>B</monospace> and <monospace>C</monospace> (item set). LGL automatically translates an arrow into a set of graph edges according to the type and number of items. In the previous example the arrow is translated into the set of edges {(<italic>A</italic>,<italic>B</italic>),(<italic>A</italic>,<italic>C</italic>)}. The left arrow is also allowed:<disp-formula><graphic xlink:href="1471-2105-14-201-i2.gif"/></disp-formula></p><p>which defines the set of edges {(<italic>B</italic>,<italic>A</italic>),(<italic>C</italic>,<italic>A</italic>)}. Formally, this happens based on the fact that the comma operator takes precedence over the arrow operator.</p><p>An item can represent a complex object when using named graphs. A named graph is a graph preceded by a text label and a colon, like in the following statement:<disp-formula><graphic xlink:href="1471-2105-14-201-i3.gif"/></disp-formula></p><p>After the definition of a named graph, its label (<monospace>G1</monospace> in this example) can be used wherever an item can be used: the compiler will replace it with a copy of the graph it represents. In particular, the statement <monospace>D -&#x0003e; G1;</monospace> creates a new graph <italic>G</italic><sub>2</sub>(<italic>V</italic><sub>2</sub>,<italic>E</italic><sub>2</sub>), where <italic>V</italic><sub>2</sub>&#x02009;=&#x02009;{<italic>A</italic>,<italic>B</italic>,<italic>C</italic>,<italic>D</italic>} and <italic>E</italic><sub>2</sub>&#x02009;=&#x02009;{(<italic>A</italic>,<italic>B</italic>),(<italic>A</italic>,<italic>C</italic>),(<italic>D</italic>,<italic>A</italic>)}. This happens because in this case the arrow operator connects the new node <monospace>D</monospace> to all the root nodes (nodes with no incoming edges) of <monospace>G1</monospace>. Analogously, the statement <monospace>G1 -&#x0003e; D;</monospace> creates a new graph <italic>G</italic><sub>3</sub>(<italic>V</italic><sub>3</sub>,<italic>E</italic><sub>3</sub>), where <italic>V</italic><sub>3</sub>&#x02009;=&#x02009;<italic>V</italic><sub>2</sub>&#x02009;=&#x02009;{<italic>A</italic>,<italic>B</italic>,<italic>C</italic>,<italic>D</italic>} and <italic>E</italic><sub>3</sub>&#x02009;=&#x02009;{(<italic>A</italic>,<italic>B</italic>),(<italic>A</italic>,<italic>C</italic>),(<italic>B</italic>,<italic>D</italic>),(<italic>C</italic>,<italic>D</italic>)}. In this case the arrow operator connects all <monospace>G1</monospace> leaves to <monospace>D</monospace>. Note that the sequence of instructions:<disp-formula><graphic xlink:href="1471-2105-14-201-i4.gif"/></disp-formula></p><p>creates three graph objects: the named graph <monospace>G1</monospace> and two unnamed graphs (corresponding to <italic>G</italic><sub>2</sub> and <italic>G</italic><sub>3</sub> which are previously defined). This is because as the LGL compiler encounters a previously defined label it creates a new copy of the corresponding object. If the intention is instead to create a unique graph by incrementally adding nodes and edges, it must be explicitly stated through the mechanism of object reference. From the syntactic point of view this simply amounts to prefixing each referenced object with the <monospace>@</monospace> symbol. When a reference object is encountered, the previously defined object with the same name is used instead of a new copy. For example, the following code:<disp-formula><graphic xlink:href="1471-2105-14-201-i5.gif"/></disp-formula></p><p>creates a single graph <italic>G</italic><sub>4</sub>(<italic>V</italic><sub>4</sub>,<italic>E</italic><sub>4</sub>), where <italic>V</italic><sub>4</sub>&#x02009;=&#x02009;{<italic>A</italic>,<italic>B</italic>,<italic>C</italic>,<italic>D</italic>} and <italic>E</italic><sub>3</sub>&#x02009;=&#x02009;{(<italic>A</italic>,<italic>B</italic>),(<italic>A</italic>,<italic>C</italic>),(<italic>D</italic>,<italic>A</italic>),(<italic>B</italic>,<italic>D</italic>),(<italic>C</italic>,<italic>D</italic>)}. Note that the <monospace>@</monospace> symbol is used only with items defined in previous statements.</p><p>The mechanisms described above are sufficient to describe any graph in LGL. However, another syntax construct, the fork arrow, is introduced to improve readability. The fork arrow allows the user to define a tree structure that is visually evident. The <monospace>G1</monospace> graph, indeed, can be equivalently defined in LGL as follows:<disp-formula><graphic xlink:href="1471-2105-14-201-i6.gif"/></disp-formula></p><p>The fork operator is composed of the <italic>less-than</italic> character (<monospace>&#x0003c;</monospace>), visually representing a binary split, and the <italic>slash</italic> (<monospace>/</monospace>) and <italic>backslash</italic> (<monospace>\</monospace>) characters signaling the beginning of a left child and a right child. LGL syntax includes mechanisms to nest fork structures at arbitrary levels and with any number of children per level. See Figure <xref ref-type="fig" rid="F4">4</xref> for additional examples. In addition, arrows can be mixed with forks. Let us consider the following example:<disp-formula><graphic xlink:href="1471-2105-14-201-i7.gif"/></disp-formula></p><p>Any fork can indeed be redefined as an arrow. Finally, special flags can be associated with nodes by enclosing them in square brackets, as in the following example:<disp-formula><graphic xlink:href="1471-2105-14-201-i8.gif"/></disp-formula></p><p>This instruction creates the graph <monospace>G1</monospace> and associates the flag <italic>F</italic> to its node <monospace>B</monospace>. The <italic>F</italic> flag tells Pyleaf (described in the next subsection) to consider the output of the associated processor as a file name and to support dedicated features.</p></sec><sec><title>Pyleaf</title><p>Pyleaf is a Python library that is able to bind the node names of an LGL graph to Python functions in order to interpret it as an analysis pipeline. As previously mentioned, the semantics of the graph see nodes as processors and edges as input/output connections between them. Root nodes are meant to be associated with primary resources, terminal nodes with final resources, and other nodes with raw resources. With Pyleaf the user can request the production of a resource by identifying it directly with the name of the processor producing it.</p><p>For Pyleaf to work two objects are needed: the pipeline structure in the form of a multi-line Python string containing a graph in LGL code; and the name of the Python source code file where the functions implementing the pipeline nodes are defined. Indeed, the binding between the nodes and the corresponding Python functions is performed by searching for LGL nodes and Python functions having the same name. With this information Pyleaf can build a <monospace>leaf.prj.project</monospace> Python object, which is the main interface to all of Leaf&#x02019;s features (see Table <xref ref-type="table" rid="T1">1</xref> for a summary of the main implemented methods). Let us consider the following piece of Python code as an example:<disp-formula><graphic xlink:href="1471-2105-14-201-i9.gif"/></disp-formula></p><table-wrap position="float" id="T1"><label>Table 1</label><caption><p>Protocol methods summary</p></caption><table frame="hsides" rules="groups" border="1"><colgroup><col align="left"/><col align="center"/></colgroup><thead valign="top"><tr><th align="left"><bold>Method</bold></th><th align="left"><bold>Description</bold></th></tr></thead><tbody valign="top"><tr><td align="left" valign="bottom">clear<hr/></td><td align="left" valign="bottom">Clears a resource from RAM.<hr/></td></tr><tr><td align="left" valign="bottom">clearall<hr/></td><td align="left" valign="bottom">Clears all resources from RAM.<hr/></td></tr><tr><td align="left" valign="bottom">dumpOff<hr/></td><td align="left" valign="bottom">Switches dumping OFF.<hr/></td></tr><tr><td align="left" valign="bottom">dumpOn<hr/></td><td align="left" valign="bottom">Switches dumping ON.<hr/></td></tr><tr><td align="left" valign="bottom">export<hr/></td><td align="left" valign="bottom">Exports the graph to a pdf file, including docstrings.<hr/></td></tr><tr><td align="left" valign="bottom">getinputs<hr/></td><td align="left" valign="bottom">Collects all input resources that are input to the given node and returns a copy of them in a list.<hr/></td></tr><tr><td align="left" valign="bottom">list<hr/></td><td align="left" valign="bottom">Lists the state (unavailable / dumped / to be built) of all resources.<hr/></td></tr><tr><td align="left" valign="bottom">provide<hr/></td><td align="left" valign="bottom">Provides a resource. The resource is returned if available, loaded from disk if dumped, built on the fly otherwise.<hr/></td></tr><tr><td align="left" valign="bottom">publish<hr/></td><td align="left" valign="bottom">Exports the analysis as an HTML bioinformatic protocol.<hr/></td></tr><tr><td align="left" valign="bottom">rebuild<hr/></td><td align="left" valign="bottom">Clears a resource, then provides it.<hr/></td></tr><tr><td align="left" valign="bottom">run<hr/></td><td align="left" valign="bottom">Provides all leaf (final) resources.<hr/></td></tr><tr><td align="left" valign="bottom">trust<hr/></td><td align="left" valign="bottom">Assigns a resource to a node without invalidating dependent resources.<hr/></td></tr><tr><td align="left" valign="bottom">undump<hr/></td><td align="left" valign="bottom">Clears a dumped resource from the disk.<hr/></td></tr><tr><td align="left" valign="bottom">undumpall<hr/></td><td align="left" valign="bottom">Clears all dumped resources from the disk.<hr/></td></tr><tr><td align="left">untrust</td><td align="left">Clears a resource and all its dependent.</td></tr></tbody></table><table-wrap-foot><p>This methods are designed to be used through a Python shell to perform pipeline operations. <italic>Dumping</italic> is the automatic management of produced resources in permanent memory. A resource is said to be <italic>available</italic> if present in primary memory, <italic>dumped</italic> if previuosly stored on the disk.</p></table-wrap-foot></table-wrap><p>In order to create the object <monospace>pr</monospace>, Pyleaf passes the <monospace>lglGraph</monospace> object to the LGL compiler, reads the resulting graph structure and searches the <monospace>ex1.py</monospace> file for the Python functions <monospace>loadData</monospace>, <monospace>visualize</monospace>, <monospace>analyze</monospace> and <monospace>exportResults</monospace>. The <monospace>pr</monospace> object is a high-level interface that primarily deals with analyzing the user&#x02019;s code in order to create one or more <monospace>protocol</monospace> objects (a Leaf feature that is currently under development will allow the user to create and manage variants of a protocol). In order to easily access the <monospace>protocol</monospace> object, the following code is used:<disp-formula><graphic xlink:href="1471-2105-14-201-i10.gif"/></disp-formula></p><p>The interaction between functions bound to pipeline nodes happens as follows. Each function has only one output resource, though it can be an arbitrarily structured object, as usual in programming languages. If a node in the pipeline has more than one outgoing edge, it will provide the same resource along each edge. On the other hand, a node having <italic>N</italic> incoming edges in the pipeline must be bound to a function having <italic>N</italic> input parameters and is called accordingly. This is an alternative to the approach where nodes with multiple inputs correspond to the same function called multiple times with different inputs. Leaf supports both semantic styles: to use the latter, multiple copies of the same node can be added to the pipeline (this is permitted by LGL syntax), where each one is connected with different input nodes. However, we prefer the former approach, that uses multiple inputs and a single output per function, as it tends to align more naturally with common programming practices.</p><p>When the user requests a resource, Pyleaf is able to identify the part of the pipeline that needs to be executed in order to build the resource. A sequence of function calls is thus performed according to the pipeline structure, where the output of each node forwarded to all of its descendants, according to the rules explained above. In order to optimize pipeline execution, Pyleaf supports parallel processing of independent nodes and mechanisms for &#x0201c;lazy processing&#x0201d;, which means it doesn&#x02019;t execute processors that are not required to satisfy a user request. When referring to &#x0201c;unnecessary nodes&#x0201d; we mean nodes that are not in the path between a primary resource and the requested resource, as well as nodes that are in said path but whose output has been previously computed (and whose source code has not changed since then). This is possible because Pyleaf automatically stores all derived resources in primary and permanent memory as soon as they are produced. As an example, let us suppose that a user requests the production of the resource that is produced by the processor <monospace>analyze</monospace> from the previous example. This is done through the Python shell using the Pyleaf <monospace>provide</monospace> method:<disp-formula><graphic xlink:href="1471-2105-14-201-i11.gif"/></disp-formula></p><p>Pyleaf will refer to the protocol&#x02019;s graph and run the <monospace>loadData</monospace> function accordingly (with no argument), pass its output to the <monospace>analyze</monospace> function and return the result in the variable <monospace>x</monospace>. Both outputs will be transparently stored in primary and permanent memory (even if the output was not assigned to a variable). If the user later requests, for example, the resource produced by <monospace>exportResults</monospace>, Pyleaf will load its input from the disk or directly from primary memory, if it is still available. Variables containing processors&#x02019; outputs are automatically created and cleared internally as needed. The corresponding objects are referred to using node labels from the pipeline definition. This feature is very important during the development of a bioinformatic data analysis, where massive computations and several data files may be involved. The user is not forced to manually save and restore variables, thus preventing data inconsistency across development sessions. Moreover the definition of mnemonic names associated with derived resources is not necessary since the direct use of node names from the pipeline ensures a clear and simple way to identify them.</p><p>As mentioned, Pyleaf also supports parallel computing by exploiting multicore machines. For example, if the execution of the entire pipeline is requested (using the <monospace>run</monospace> method), Pyleaf will detect that the nodes <monospace>visualize</monospace> and <monospace>analyze</monospace> have no common ancestors and will run them in parallel.</p><p>Pyleaf also maintains a database that stores the source code of all the processors in order to ensure consistency between the current state of the pipeline and the produced resources. If a processor is modified, all dependant resources are automatically cleared (unless the user explicitly requests to <italic>trust</italic> an existing resource). Pyleaf also tracks files created by nodes marked with the flag &#x0201c;F&#x0201d; in order to verify that their content has not changed. This is currently performed by checking the time stamp of the most recent modification.</p><p>Finally, Pyleaf can automatically export the entire analysis as a hypertext document implementing our concept of bioinformatic protocol. The document includes a visualization of the pipeline, with nodes containing hypertext links to processor details. Such details include processor source code, documentation (automatically extracted from the original source code), execution time, and hypertext links to produced files together with their size. Overall time and space consumption as well as other statistics for the pipeline as a whole are also included. See Table <xref ref-type="table" rid="T2">2</xref> for an example.</p><table-wrap position="float" id="T2"><label>Table 2</label><caption><p>Example of statistics generated for the CNV analysis</p></caption><table frame="hsides" rules="groups" border="1"><colgroup><col align="left"/><col align="center"/></colgroup><thead valign="top"><tr><th align="left">&#x000a0;</th><th align="left"><bold>Statistics for the entire analysis</bold></th></tr></thead><tbody valign="top"><tr><td align="left" valign="bottom">Number of nodes<hr/></td><td align="left" valign="bottom">24<hr/></td></tr><tr><td align="left" valign="bottom">Number of <italic>F</italic>-nodes<hr/></td><td align="left" valign="bottom">12<hr/></td></tr><tr><td align="left" valign="bottom">Total number of output files<hr/></td><td align="left" valign="bottom">76<hr/></td></tr><tr><td align="left" valign="bottom">Total size of output files<hr/></td><td align="left" valign="bottom">2.32G<hr/></td></tr><tr><td align="left" valign="bottom">Total CPU time required<hr/></td><td align="left" valign="bottom">03:02:15.25<hr/></td></tr><tr><td colspan="2" align="center" valign="bottom"><bold>Statistics for a single node </bold>(<monospace>distMatGfx</monospace>)<hr/></td></tr><tr><td align="left" valign="bottom">Description<hr/></td><td align="left" valign="bottom">Produces an MDS visualization of the output of samplesDistMats<hr/></td></tr><tr><td align="left" valign="bottom">Output files<hr/></td><td align="left" valign="bottom">t_tani_distrib.pdf, t_tani_mds.pdf<hr/></td></tr><tr><td align="left" valign="bottom">Last build time<hr/></td><td align="left" valign="bottom">Sun Jan 8 03:51:56 2013<hr/></td></tr><tr><td align="left">Required CPU time</td><td align="left">00:01:25.08</td></tr></tbody></table><table-wrap-foot><p>The statistics are updated at each run or modification of any part of the pipeline. They are included in the final HTML protocol generated by Pyleaf. <italic>F</italic>-nodes are nodes whose output is written in one or more files on the disk. The total required time is estimated by summing up all the time required by single nodes, since they are usually ran across different sessions. Documentation for each node includes also source code, which is not reported in the Table. In the original document the file names are hyperlinked with actual files on the disk.</p></table-wrap-foot></table-wrap></sec><sec><title>Leaf and Python frameworks coexistence</title><p>The Leaf system is completely transparent to the user&#x02019;s development environment. The LGL graph is defined as a multi-line Python string in the same source code implementing the Python functions that carry out each step of the analysis (see Figure <xref ref-type="fig" rid="F7">7</xref>). The processors in the pipeline are not implemented as structured objects, but rather as regular Python functions and the programmer does not need to use any special convention while writing his Python code. This framework allows the user to write plain and loosely structured Python code while still defining a high level scheme of the analysis. Both high and low levels of the analysis are managed together in the same source code. In fact, a project using Leaf typically includes a number of Python functions highlighted as nodes in the pipeline and others that are only implemented in the code, thus introducing a further mechanism of hierarchical structuring.</p><p>A common practice when extending an existing analysis within the Leaf environment is to exploit the protocol in order to easily set up the starting point for a new branch in the pipeline. Then the user requests to Pyleaf the resources that are necessary to the new branch. Pyleaf loads them from the disk or builds them on the fly running the necessary nodes from the pipeline and returns them to the user as regular Python objects. The user is able to define and test a new Python function and finally add it as a new node to the LGL graph in order to make it part of the pipeline. Conversely, existing pipeline nodes can be tested with new inputs by calling them as regular Python functions in a shell environment. In Leaf the usual direct call of Python functions seamlessly coexists with their indirect use as pipeline nodes.</p></sec></sec><sec><title>Application example</title><p>The Leaf system was developed to overcome practical problems that arose during a bioinformatic research project, the results of which are to be published soon. This application example included three main collaborating research units: application domain experts, data producers and data analysts (see Figure <xref ref-type="fig" rid="F1">1</xref>). As the research unit responsible for the data analysis, we were primarily concerned with: safely keeping primary resources provided by data producers as our ground-truth; easily identifying, storing and retrieving primary and derived resources in order to promptly respond to new requests from the other research groups; ensuring that all derived resources could be automatically reproduced starting from the primary ones; providing a clear report of all the steps of our analysis to be shared with other research groups; maintaining a documentation of our analysis making it easy to replicate, reuse in the future and back-trace in case of problems (this includes providing the execution provenance trace [<xref ref-type="bibr" rid="B8">8</xref>-<xref ref-type="bibr" rid="B10">10</xref>]). While our main goal was related to the development of computational methods, in this paper we describe practical issues concerning the development process of the analysis pipeline and how the Leaf system helped us overcome them efficiently.</p><p>The project involved a copy number variation (CNV [<xref ref-type="bibr" rid="B29">29</xref>]) analysis of a number of tissue samples. We used an existing software (PennCNV [<xref ref-type="bibr" rid="B30">30</xref>]) implemented as a Perl script for CNV detection. As an example of traceability enforcement, the primary resources were made compatible with the Perl script by an ad hoc converter routine written in Python. This conversion could have been more easily performed manually, but at the cost of breaking the <italic>automaticity</italic> rule (see &#x0201c;Concepts&#x0201d; section). The output of PennCNV suggested a number of hypotheses that were investigated through dedicated methods, which were heavily driven by partial results in a continuous feedback loop. The final computational pipeline for the analysis is shown in Figure <xref ref-type="fig" rid="F8">8</xref> in the LGL language and in Figure <xref ref-type="fig" rid="F9">9</xref> as the corresponding graphical visualization. Note that in the final pipeline the <monospace>prepareInput</monospace> processor calls a Unix Bash script, the <monospace>PennCNV</monospace> processor calls a Perl script, the <monospace>clustergram</monospace> processor calls an R script and all other processors call Python procedures. This is possible because of the high interoperability supported by the Python language, but is transparently included in the pipeline that provides a general overview of the analysis, evincing only the aspects that have been considered worth showing. The programmer used his preferred Python development framework to produce all the code for this study as well as the associated pipeline. In our case, even the Bash and R code were embedded in the Python source code, allowing Leaf to access and control all of the code implementing the pipeline nodes. R language is exploited through the dedicated RPy [<xref ref-type="bibr" rid="B31">31</xref>] Python library, while Bash scripts are encoded as Python multi-line strings and passed to system calls for execution.</p><fig id="F8" position="float"><label>Figure 8</label><caption><p><bold>LGL code for the CNV project.</bold> The computational protocol in LGL for a real Copy Number Variation study. Compare with Figure <xref ref-type="fig" rid="F9">9</xref>. Refer to Figure <xref ref-type="fig" rid="F4">4</xref> for basic syntax considering that the pipe (<monospace>|</monospace>) and newline characters are ignored by the compiler.</p></caption><graphic xlink:href="1471-2105-14-201-8"/></fig><fig id="F9" position="float"><label>Figure 9</label><caption><p><bold>Protocol&#x02019;s graph for the CNV project.</bold> Graphical representation of the LGL code of Figure <xref ref-type="fig" rid="F8">8</xref>. Leaf can internally use Graphviz [<xref ref-type="bibr" rid="B28">28</xref>] tools in order to automatically produce such representation starting from the output of the LGL compiler. Nodes with straight corners represent processors producing files.</p></caption><graphic xlink:href="1471-2105-14-201-9"/></fig><p>The LGL code in the example (Figure <xref ref-type="fig" rid="F8">8</xref>) is quite involved and may seem difficult to work with. In our practice, complex LGL structures are created as the result of a code polishing phase, as soon as a portion of the pipeline has been assessed. Before this phase, a very simple syntax is adopted, with elementary structures incrementally appended to the graph. In fact, the entire LGL code in Figure <xref ref-type="fig" rid="F8">8</xref> could be rewritten in LGL as a simple list of edges, as shown below:<disp-formula><graphic xlink:href="1471-2105-14-201-i12.gif"/></disp-formula></p><p>A slightly more complex LGL statement defining the same structure could be:<disp-formula><graphic xlink:href="1471-2105-14-201-i13.gif"/></disp-formula></p><p>where line breaks and indentation are discretionary. Since complex structures can be difficult to code, LGL provides simpler alternatives. The choice of syntax complexity level is left up to the programmer based on his skill level and preference.</p><p>The generated protocol for the latest version of the CNV project pipeline is available at the Leaf home page [<xref ref-type="bibr" rid="B12">12</xref>]. It is automatically generated by Pyleaf in HTML format. A sample of the statistics included in the protocol document is reported in Table <xref ref-type="table" rid="T2">2</xref>.</p></sec><sec sec-type="conclusions"><title>Conclusions</title><p>A balance between agility of code development and overall consistency and communicability in rapidly changing environments such as interdisciplinary research collaborations, is of fundamental importance, in regard to both methodology and efficiency. High-level tools are the most efficient when working on the general structure of the analysis, but make low-level interventions difficult. On the other hand, the use of formal design approaches can improve the robustness of a bioinformatic analysis, but at the cost of reducing responsiveness to change.</p><p>The Leaf system, like other tools in the same category, allows for low-level access to implementation details, but still provides tools for the management of a light-weight, loosely structured data flow layer. In particular Leaf supports a dedicated pipeline definition language, LGL, whose flexible coding style allows the programmer to choose his preferred balance between easy to read and easy to write code.</p><p>To our knowledge, Leaf is the only pipeline manager that allows the definition of both the pipeline and its nodes in the same source file, while at the same time keeping them separated. Besides the general properties connected with the design of the Leaf system, we also highlighted some features supported by the Python implementation of Leaf that are not present in similar tools, such as the monitoring of source code, which allows for consistency checks between code and resources. Additional features already present in other tools have been further developed in Leaf, such as the generation of pipeline documentation in the form of a hypertext, including links to the files produced during pipeline execution and statistics about time and space requirements detailed for each node, to name a few.</p><p>In our opinion, both the design philosophy and the implemented features of Leaf make it a valuable alternative to other pipeline management systems.</p></sec><sec><title>Availability and requirements</title><p><bold>Project name:</bold> Leaf</p><p><bold>Project home page:</bold><ext-link ext-link-type="uri" xlink:href="http://www.neuronelab.dmi.unisa.it/leaf">http://www.neuronelab.dmi.unisa.it/leaf</ext-link></p><p><bold>Operating system(s):</bold> Linux, Windows. Mac OS under development.</p><p><bold>Programming language(s):</bold> C++, Python.</p><p><bold>Other requirements:</bold> Python &#x02265; 2.6.</p><p><bold>License:</bold> MIT.</p><p><bold>Any restrictions to use by non-academics:</bold> None.</p></sec><sec><title>Abbreviations</title><p>LGL: Leaf graph language; DAG: Directed acyclic graph.</p></sec><sec><title>Competing interests</title><p>The authors declare that they have no competing interests.</p></sec><sec><title>Authors&#x02019; contributions</title><p>FN designed and implemented the Leaf system. RT provided design and implementation feedback. RMC provided application domain feedback. RT and RMC supervised the project. All authors contributed in writing the manuscript and read and approved the final version.</p></sec></body><back><sec><title>Acknowledgements</title><p>The work was funded by the Italian Association for Cancer Research (AIRC, Milan, Italy, IG 9168 to R. Mariani-Costantini). The authors would like to thank Donatella Granata and Ellen Abrams for their useful comments on the manuscript.</p></sec><ref-list><ref id="B1"><mixed-citation publication-type="journal"><name><surname>Johnston</surname><given-names>WM</given-names></name><name><surname>Hanna</surname><given-names>JRP</given-names></name><name><surname>Miller</surname><given-names>RJ</given-names></name><article-title>Advances in dataflow programming languages</article-title><source>ACM Comput Surv</source><year>2004</year><volume>36</volume><fpage>1</fpage><lpage>34</lpage><pub-id pub-id-type="doi">10.1145/1013208.1013209</pub-id></mixed-citation></ref><ref id="B2"><mixed-citation publication-type="journal"><name><surname>Sanner</surname><given-names>MF</given-names></name><article-title>Python: a programming language for software integration and development</article-title><source>J Mol Graph Model</source><year>1999</year><volume>17</volume><fpage>57</fpage><lpage>61</lpage><comment>[PMID:10660911]</comment><pub-id pub-id-type="pmid">10660911</pub-id></mixed-citation></ref><ref id="B3"><mixed-citation publication-type="journal"><name><surname>Fourment</surname><given-names>M</given-names></name><name><surname>Gillings</surname><given-names>MR</given-names></name><article-title>A comparison of common programming languages used in bioinformatics</article-title><source>BMC Bioinformatics</source><year>2008</year><volume>9</volume><fpage>82</fpage><comment>[<ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/9/82/abstract">http://www.biomedcentral.com/1471-2105/9/82/abstract</ext-link>]</comment><pub-id pub-id-type="doi">10.1186/1471-2105-9-82</pub-id><pub-id pub-id-type="pmid">18251993</pub-id></mixed-citation></ref><ref id="B4"><mixed-citation publication-type="journal"><collab>Tratt L</collab><article-title>Dynamically typed languages</article-title><source>Adv Comput</source><year>2009</year><volume>77</volume><fpage>149</fpage><lpage>184</lpage></mixed-citation></ref><ref id="B5"><mixed-citation publication-type="book"><name><surname>Bruegge</surname><given-names>B</given-names></name><name><surname>Dutoit</surname><given-names>AH</given-names></name><source>Object-Oriented Software Engineering: Using UML, Patterns and Java,Second Edition</source><year>2003</year><publisher-name>Upper Saddle River: Prentice-Hall, Inc.</publisher-name></mixed-citation></ref><ref id="B6"><mixed-citation publication-type="journal"><name><surname>Cockburn</surname><given-names>A</given-names></name><name><surname>Highsmith</surname><given-names>J</given-names></name><article-title>Agile software development, the people factor</article-title><source>Computer</source><year>2001</year><volume>34</volume><issue>11</issue><fpage>131</fpage><lpage>133</lpage><pub-id pub-id-type="doi">10.1109/2.963450</pub-id></mixed-citation></ref><ref id="B7"><mixed-citation publication-type="book"><name><surname>Sommerville</surname><given-names>I</given-names></name><source>Software Engineering, 9th ed edition</source><year>2011</year><publisher-name>Boston: Pearson Education Inc.</publisher-name></mixed-citation></ref><ref id="B8"><mixed-citation publication-type="book"><name><surname>Davidson</surname><given-names>SB</given-names></name><name><surname>Freire</surname><given-names>J</given-names></name><article-title>Provenance and scientific workflows: challenges and opportunities</article-title><source>Proceedings of the 2008 ACM SIGMOD international conference on Management of data, SIGMOD &#x02019;08</source><year>2008</year><publisher-name>New York: ACM</publisher-name><fpage>1345</fpage><lpage>1350</lpage><comment>[<ext-link ext-link-type="uri" xlink:href="http://doi.acm.org/10.1145/1376616.1376772">http://doi.acm.org/10.1145/1376616.1376772</ext-link>]</comment></mixed-citation></ref><ref id="B9"><mixed-citation publication-type="book"><name><surname>Cheney</surname><given-names>J</given-names></name><name><surname>Ahmed</surname><given-names>A</given-names></name><name><surname>Acar</surname><given-names>UA</given-names></name><article-title>Provenance as dependency analysis</article-title><source>Proceedings of the 11th international conference on Database programming languages, DBPL&#x02019;07</source><year>2007</year><publisher-name>Berlin, Heidelberg: Springer-Verlag</publisher-name><fpage>138</fpage><lpage>152</lpage></mixed-citation></ref><ref id="B10"><mixed-citation publication-type="book"><name><surname>Buneman</surname><given-names>P</given-names></name><name><surname>Khanna</surname><given-names>S</given-names></name><name><surname>Wang-Chiew</surname><given-names>T</given-names></name><person-group person-group-type="editor">Bussche J, Vianu V</person-group><article-title>Why and Where: A Characterization of Data Provenance</article-title><source>Database Theory &#x02013; ICDT 2001, Volume 1973</source><publisher-name>Berlin, Heidelberg: Springer Berlin Heidelberg</publisher-name><fpage>316</fpage><lpage>330</lpage><comment>[<ext-link ext-link-type="uri" xlink:href="http://www.springerlink.com/index/10.1007/3-540-44503-X_20">http://www.springerlink.com/index/10.1007/3-540-44503-X_20</ext-link>]</comment></mixed-citation></ref><ref id="B11"><mixed-citation publication-type="journal"><name><surname>Ince</surname><given-names>DC</given-names></name><name><surname>Hatton</surname><given-names>L</given-names></name><name><surname>Graham-Cumming</surname><given-names>J</given-names></name><article-title>The case for open computer programs</article-title><source>Nature</source><year>2012</year><volume>482</volume><issue>7386</issue><fpage>485</fpage><lpage>488</lpage><comment>[<ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nature10836">http://dx.doi.org/10.1038/nature10836</ext-link>]</comment><pub-id pub-id-type="doi">10.1038/nature10836</pub-id><pub-id pub-id-type="pmid">22358837</pub-id></mixed-citation></ref><ref id="B12"><mixed-citation publication-type="other"><article-title>Leaf Home Page</article-title><ext-link ext-link-type="uri" xlink:href="http://www.neuronelab.dmi.unisa.it/leaf">http://www.neuronelab.dmi.unisa.it/leaf</ext-link></mixed-citation></ref><ref id="B13"><mixed-citation publication-type="other"><article-title>Leaf source code repository</article-title><ext-link ext-link-type="uri" xlink:href="https://github.com/franapoli/pyleaf">https://github.com/franapoli/pyleaf</ext-link></mixed-citation></ref><ref id="B14"><mixed-citation publication-type="journal"><name><surname>Cock</surname><given-names>PJA</given-names></name><name><surname>Antao</surname><given-names>T</given-names></name><name><surname>Chang</surname><given-names>JT</given-names></name><name><surname>Chapman</surname><given-names>BA</given-names></name><name><surname>Cox</surname><given-names>CJ</given-names></name><name><surname>Dalke</surname><given-names>A</given-names></name><name><surname>Friedberg</surname><given-names>I</given-names></name><name><surname>Hamelryck</surname><given-names>T</given-names></name><name><surname>Kauff</surname><given-names>F</given-names></name><name><surname>Wilczynski</surname><given-names>B</given-names></name><name><surname>de Hoon</surname><given-names>MJL</given-names></name><article-title>Biopython: freely available Python tools for computational molecular biology and bioinformatics</article-title><source>Bioinformatics (Oxford, England)</source><year>2009</year><volume>25</volume><issue>11</issue><fpage>1422</fpage><lpage>1423</lpage><comment>[PMID:19304878]</comment><pub-id pub-id-type="doi">10.1093/bioinformatics/btp163</pub-id></mixed-citation></ref><ref id="B15"><mixed-citation publication-type="journal"><name><surname>Romano</surname><given-names>P</given-names></name><article-title>Automation of in-silico data analysis processes through workflow management systems</article-title><source>Brief Bioinformatics</source><year>2008</year><volume>9</volume><fpage>57</fpage><lpage>68</lpage><comment>[<ext-link ext-link-type="uri" xlink:href="http://bib.oxfordjournals.org/content/9/1/57">http://bib.oxfordjournals.org/content/9/1/57</ext-link>]</comment><pub-id pub-id-type="pmid">18056132</pub-id></mixed-citation></ref><ref id="B16"><mixed-citation publication-type="journal"><name><surname>Goecks</surname><given-names>J</given-names></name><name><surname>Nekrutenko</surname><given-names>A</given-names></name><name><surname>Taylor</surname><given-names>J</given-names></name><article-title>Galaxy: a comprehensive approach for supporting accessible, reproducible, and transparent computational research in the life sciences</article-title><source>Genome Biol</source><year>2010</year><volume>11</volume><issue>8</issue><fpage>R86</fpage><comment>[<ext-link ext-link-type="uri" xlink:href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2945788/">http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2945788/</ext-link>] [PMID:20738864 PMCID: PMC2945788]</comment><pub-id pub-id-type="doi">10.1186/gb-2010-11-8-r86</pub-id><pub-id pub-id-type="pmid">20738864</pub-id></mixed-citation></ref><ref id="B17"><mixed-citation publication-type="journal"><name><surname>Hull</surname><given-names>D</given-names></name><name><surname>Wolstencroft</surname><given-names>K</given-names></name><name><surname>Stevens</surname><given-names>R</given-names></name><name><surname>Goble</surname><given-names>C</given-names></name><name><surname>Pocock</surname><given-names>MR</given-names></name><name><surname>Li</surname><given-names>P</given-names></name><name><surname>Oinn</surname><given-names>T</given-names></name><article-title>Taverna: a tool for building and running workflows of services</article-title><source>Nucleic Acids Res</source><year>2006</year><volume>34</volume><issue>Web Server</issue><fpage>W729</fpage><lpage>W732</lpage><comment>[<ext-link ext-link-type="uri" xlink:href="http://nar.oxfordjournals.org/content/34/suppl_2/W729.full">http://nar.oxfordjournals.org/content/34/suppl_2/W729.full</ext-link>]</comment><pub-id pub-id-type="doi">10.1093/nar/gkl320</pub-id><pub-id pub-id-type="pmid">16845108</pub-id></mixed-citation></ref><ref id="B18"><mixed-citation publication-type="journal"><name><surname>Shah</surname><given-names>SP</given-names></name><name><surname>He</surname><given-names>DY</given-names></name><name><surname>Sawkins</surname><given-names>JN</given-names></name><name><surname>Druce</surname><given-names>JC</given-names></name><name><surname>Quon</surname><given-names>G</given-names></name><name><surname>Lett</surname><given-names>D</given-names></name><name><surname>Zheng</surname><given-names>GX</given-names></name><name><surname>Xu</surname><given-names>T</given-names></name><name><surname>Ouellette</surname><given-names>BF</given-names></name><article-title>Pegasys: software for executing and integrating analyses of biological sequences</article-title><source>BMC Bioinformatics</source><year>2004</year><volume>5</volume><fpage>40</fpage><comment>[<ext-link ext-link-type="uri" xlink:href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC406494/">http://www.ncbi.nlm.nih.gov/pmc/articles/PMC406494/</ext-link>] [PMID:15096276 PMCID:PMC406494]</comment><pub-id pub-id-type="doi">10.1186/1471-2105-5-40</pub-id><pub-id pub-id-type="pmid">15096276</pub-id></mixed-citation></ref><ref id="B19"><mixed-citation publication-type="journal"><name><surname>Linke</surname><given-names>B</given-names></name><name><surname>Giegerich</surname><given-names>R</given-names></name><name><surname>Goesmann</surname><given-names>A</given-names></name><article-title>Conveyor: a workflow engine for bioinformatic analyses</article-title><source>Bioinformatics</source><year>2011</year><volume>27</volume><issue>7</issue><fpage>903</fpage><lpage>911</lpage><comment>[<ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/content/27/7/903">http://bioinformatics.oxfordjournals.org/content/27/7/903</ext-link>]</comment><pub-id pub-id-type="doi">10.1093/bioinformatics/btr040</pub-id><pub-id pub-id-type="pmid">21278189</pub-id></mixed-citation></ref><ref id="B20"><mixed-citation publication-type="book"><name><surname>Altintas</surname><given-names>I</given-names></name><name><surname>Berkley</surname><given-names>C</given-names></name><name><surname>Jaeger</surname><given-names>E</given-names></name><name><surname>Jones</surname><given-names>M</given-names></name><name><surname>Ludascher</surname><given-names>B</given-names></name><name><surname>Mock</surname><given-names>S</given-names></name><article-title>Kepler: an extensible system for design and execution of scientific workflows</article-title><source>Scientific and Statistical Database Management,2004. Proceedings. 16th International Conference on</source><year>2004</year><publisher-name>IEEE Computer Society</publisher-name><fpage>423</fpage><lpage>424</lpage></mixed-citation></ref><ref id="B21"><mixed-citation publication-type="journal"><name><surname>Ovaska</surname><given-names>K</given-names></name><name><surname>Laakso</surname><given-names>M</given-names></name><name><surname>Haapa-Paananen</surname><given-names>S</given-names></name><name><surname>Louhimo</surname><given-names>R</given-names></name><name><surname>Chen</surname><given-names>P</given-names></name><name><surname>Aittomaki</surname><given-names>V</given-names></name><name><surname>Valo</surname><given-names>E</given-names></name><name><surname>Nunez-Fontarnau</surname><given-names>J</given-names></name><name><surname>Rantanen</surname><given-names>V</given-names></name><name><surname>Karinen</surname><given-names>S</given-names></name><name><surname>Nousiainen</surname><given-names>K</given-names></name><name><surname>Lahesmaa-Korpinen</surname><given-names>AM</given-names></name><name><surname>Miettinen</surname><given-names>M</given-names></name><name><surname>Saarinen</surname><given-names>L</given-names></name><name><surname>Kohonen</surname><given-names>P</given-names></name><name><surname>Wu</surname><given-names>J</given-names></name><name><surname>Westermarck</surname><given-names>J</given-names></name><name><surname>Hautaniemi</surname><given-names>S</given-names></name><article-title>Large-scale data integration framework provides a comprehensive view on glioblastoma multiforme</article-title><source>Genome Med</source><year>2010</year><volume>2</volume><issue>9</issue><fpage>65</fpage><comment>[<ext-link ext-link-type="uri" xlink:href="http://genomemedicine.com/content/2/9/65">http://genomemedicine.com/content/2/9/65</ext-link>]</comment><pub-id pub-id-type="doi">10.1186/gm186</pub-id><pub-id pub-id-type="pmid">20822536</pub-id></mixed-citation></ref><ref id="B22"><mixed-citation publication-type="journal"><name><surname>Hoon</surname><given-names>S</given-names></name><name><surname>Ratnapu</surname><given-names>KK</given-names></name><name><surname>Kumarasamy</surname><given-names>B</given-names></name><name><surname>Juguang</surname><given-names>X</given-names></name><name><surname>Clamp</surname><given-names>M</given-names></name><name><surname>Stabenau</surname><given-names>A</given-names></name><name><surname>Potter</surname><given-names>S</given-names></name><name><surname>Clarke</surname><given-names>L</given-names></name><name><surname>Stupka</surname><given-names>E</given-names></name><collab>Chia Jm</collab><article-title>Biopipe: a flexible framework for protocol-based Bioinformatics analysis</article-title><source>Genome Res</source><year>2003</year><volume>13</volume><issue>8</issue><fpage>1904</fpage><lpage>1915</lpage><comment>[<ext-link ext-link-type="uri" xlink:href="http://genome.cshlp.org/content/13/8/1904">http://genome.cshlp.org/content/13/8/1904</ext-link>]</comment><pub-id pub-id-type="pmid">12869579</pub-id></mixed-citation></ref><ref id="B23"><mixed-citation publication-type="journal"><name><surname>Goodstadt</surname><given-names>L</given-names></name><article-title>Ruffus: a lightweight Python library for computational pipelines</article-title><source>Bioinformatics</source><year>2010</year><volume>26</volume><issue>21</issue><fpage>2778</fpage><lpage>2779</lpage><comment>[<ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/content/26/21/2778">http://bioinformatics.oxfordjournals.org/content/26/21/2778</ext-link>]</comment><pub-id pub-id-type="doi">10.1093/bioinformatics/btq524</pub-id><pub-id pub-id-type="pmid">20847218</pub-id></mixed-citation></ref><ref id="B24"><mixed-citation publication-type="other"><name><surname>Sadedin</surname><given-names>SP</given-names></name><name><surname>Pope</surname><given-names>B</given-names></name><name><surname>Oshlack</surname><given-names>A</given-names></name><article-title>Bpipe : a tool for running and managing Bioinformatics pipelines</article-title><source>Bioinformatics</source><year>2012</year><comment>[<ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/content/early/2012/04/11/bioinformatics.bts167.abstract">http://bioinformatics.oxfordjournals.org/content/early/2012/04/11/bioinformatics.bts167.abstract</ext-link>]</comment></mixed-citation></ref><ref id="B25"><mixed-citation publication-type="book"><name><surname>Cormen</surname><given-names>TH</given-names></name><source>Introduction to Algorithms, 3rd ed edition</source><year>2009</year><publisher-name>Cambridge: MIT Press</publisher-name></mixed-citation></ref><ref id="B26"><mixed-citation publication-type="other"><article-title>flex: The Fast Lexical Analyzer</article-title><ext-link ext-link-type="uri" xlink:href="http://www.gnu.org/software/flex">http://www.gnu.org/software/flex</ext-link></mixed-citation></ref><ref id="B27"><mixed-citation publication-type="other"><article-title>Bison - GNU parser generator</article-title><ext-link ext-link-type="uri" xlink:href="http://www.gnu.org/software/bison/">http://www.gnu.org/software/bison/</ext-link></mixed-citation></ref><ref id="B28"><mixed-citation publication-type="other"><article-title>Graphviz - Graph Visualization Software</article-title><ext-link ext-link-type="uri" xlink:href="http://www.graphviz.org">http://www.graphviz.org</ext-link></mixed-citation></ref><ref id="B29"><mixed-citation publication-type="journal"><name><surname>Hastings</surname><given-names>PJ</given-names></name><name><surname>Lupski</surname><given-names>JR</given-names></name><name><surname>Rosenberg</surname><given-names>SM</given-names></name><name><surname>Ira</surname><given-names>G</given-names></name><article-title>Mechanisms of change in gene copy number</article-title><source>Nature Rev. Genet</source><year>2009</year><volume>10</volume><issue>8</issue><fpage>551</fpage><lpage>564</lpage><comment>[<ext-link ext-link-type="uri" xlink:href="http://www.ncbi.nlm.nih.gov/pubmed/19597530">http://www.ncbi.nlm.nih.gov/pubmed/19597530</ext-link>] [PMID:19597530]</comment><pub-id pub-id-type="doi">10.1038/nrg2593</pub-id><pub-id pub-id-type="pmid">19597530</pub-id></mixed-citation></ref><ref id="B30"><mixed-citation publication-type="journal"><name><surname>Wang</surname><given-names>K</given-names></name><name><surname>Li</surname><given-names>M</given-names></name><name><surname>Hadley</surname><given-names>D</given-names></name><name><surname>Liu</surname><given-names>R</given-names></name><name><surname>Glessner</surname><given-names>J</given-names></name><name><surname>Grant</surname><given-names>SF</given-names></name><name><surname>Hakonarson</surname><given-names>H</given-names></name><name><surname>Bucan</surname><given-names>M</given-names></name><article-title>PennCNV: An integrated hidden Markov model designed for high-resolution copy number variation detection in whole-genome SNP genotyping data</article-title><source>Genome Res</source><year>2007</year><volume>17</volume><issue>11</issue><fpage>1665</fpage><lpage>1674</lpage><comment>[<ext-link ext-link-type="uri" xlink:href="http://genome.cshlp.org/content/17/11/1665.abstract">http://genome.cshlp.org/content/17/11/1665.abstract</ext-link>]</comment><pub-id pub-id-type="doi">10.1101/gr.6861907</pub-id><pub-id pub-id-type="pmid">17921354</pub-id></mixed-citation></ref><ref id="B31"><mixed-citation publication-type="other"><article-title>A simple and efficient access to R from Python</article-title><ext-link ext-link-type="uri" xlink:href="http://rpy.sourceforge.net">http://rpy.sourceforge.net</ext-link></mixed-citation></ref></ref-list></back></article>