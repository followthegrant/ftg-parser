<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.0 20120330//EN" "JATS-archivearticle1.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">Sensors (Basel)</journal-id><journal-id journal-id-type="iso-abbrev">Sensors (Basel)</journal-id><journal-id journal-id-type="publisher-id">sensors</journal-id><journal-title-group><journal-title>Sensors (Basel, Switzerland)</journal-title></journal-title-group><issn pub-type="epub">1424-8220</issn><publisher><publisher-name>MDPI</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">29882849</article-id><article-id pub-id-type="pmc">6022087</article-id><article-id pub-id-type="doi">10.3390/s18061672</article-id><article-id pub-id-type="publisher-id">sensors-18-01672</article-id><article-categories><subj-group subj-group-type="heading"><subject>Article</subject></subj-group></article-categories><title-group><article-title>Time and Memory Efficient Online Piecewise Linear Approximation of Sensor Signals</article-title></title-group><contrib-group><contrib contrib-type="author"><contrib-id contrib-id-type="orcid" authenticated="true">https://orcid.org/0000-0003-0370-222X</contrib-id><name><surname>Gr&#x000fc;tzmacher</surname><given-names>Florian</given-names></name><xref ref-type="aff" rid="af1-sensors-18-01672">1</xref><xref rid="c1-sensors-18-01672" ref-type="corresp">*</xref></contrib><contrib contrib-type="author"><contrib-id contrib-id-type="orcid" authenticated="true">https://orcid.org/0000-0001-9604-5382</contrib-id><name><surname>Beichler</surname><given-names>Benjamin</given-names></name><xref ref-type="aff" rid="af1-sensors-18-01672">1</xref></contrib><contrib contrib-type="author"><contrib-id contrib-id-type="orcid" authenticated="true">https://orcid.org/0000-0001-6254-4271</contrib-id><name><surname>Hein</surname><given-names>Albert</given-names></name><xref ref-type="aff" rid="af2-sensors-18-01672">2</xref></contrib><contrib contrib-type="author"><name><surname>Kirste</surname><given-names>Thomas</given-names></name><xref ref-type="aff" rid="af2-sensors-18-01672">2</xref></contrib><contrib contrib-type="author"><name><surname>Haubelt</surname><given-names>Christian</given-names></name><xref ref-type="aff" rid="af1-sensors-18-01672">1</xref></contrib></contrib-group><aff id="af1-sensors-18-01672"><label>1</label>Institute of Applied Microelectronics and Computer Engineering, University of Rostock, 18051 Rostock, Germany; <email>benjamin.beichler@uni-rostock.de</email> (B.B.); <email>christian.haubelt@uni-rostock.de</email> (C.H.)</aff><aff id="af2-sensors-18-01672"><label>2</label>Institute of Computer Science, University of Rostock, 18051 Rostock, Germany; <email>albert.hein@uni-rostock.de</email> (A.H.); <email>thomas.kirste@uni-rostock.de</email> (T.K.)</aff><author-notes><corresp id="c1-sensors-18-01672"><label>*</label>Correspondence: <email>florian.gruetzmacher@uni-rostock.de</email>; Tel.: +49-381-498-7289</corresp></author-notes><pub-date pub-type="epub"><day>23</day><month>5</month><year>2018</year></pub-date><pub-date pub-type="collection"><month>6</month><year>2018</year></pub-date><volume>18</volume><issue>6</issue><elocation-id>1672</elocation-id><history><date date-type="received"><day>21</day><month>3</month><year>2018</year></date><date date-type="accepted"><day>18</day><month>5</month><year>2018</year></date></history><permissions><copyright-statement>&#x000a9; 2018 by the authors.</copyright-statement><copyright-year>2018</copyright-year><license license-type="open-access"><license-p>Licensee MDPI, Basel, Switzerland. This article is an open access article distributed under the terms and conditions of the Creative Commons Attribution (CC BY) license (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>).</license-p></license></permissions><abstract><p>Piecewise linear approximation of sensor signals is a well-known technique in the fields of Data Mining and Activity Recognition. In this context, several algorithms have been developed, some of them with the purpose to be performed on resource constrained microcontroller architectures of wireless sensor nodes. While microcontrollers are usually constrained in computational power and memory resources, all state-of-the-art piecewise linear approximation techniques either need to buffer sensor data or have an execution time depending on the segment&#x02019;s length. In the paper at hand, we propose a novel piecewise linear approximation algorithm, with a constant computational complexity as well as a constant memory complexity. Our proposed algorithm&#x02019;s worst-case execution time is one to three orders of magnitude smaller and its average execution time is three to seventy times smaller compared to the state-of-the-art Piecewise Linear Approximation (PLA) algorithms in our experiments. In our evaluations, we show that our algorithm is time and memory efficient without sacrificing the approximation quality compared to other state-of-the-art piecewise linear approximation techniques, while providing a maximum error guarantee per segment, a small parameter space of only one parameter, and a maximum latency of one sample period plus its worst-case execution time.</p></abstract><kwd-group><kwd>piecewise linear approximation</kwd><kwd>segmentation</kwd><kwd>sensor data abstraction</kwd><kwd>sensor signal compression</kwd><kwd>CPLR</kwd><kwd>wireless sensor networks</kwd><kwd>embedded sensor processing</kwd></kwd-group></article-meta></front><body><sec id="sec1-sensors-18-01672"><title>1. Introduction</title><p>Within the last two decades, different Piecewise Linear Approximation (PLA) techniques, sometimes also called Segmentation Algorithms, have been developed and studied by different researchers. The&#x000a0;applications include data mining [<xref rid="B1-sensors-18-01672" ref-type="bibr">1</xref>], data collection in wireless sensor networks [<xref rid="B2-sensors-18-01672" ref-type="bibr">2</xref>,<xref rid="B3-sensors-18-01672" ref-type="bibr">3</xref>], and&#x000a0;several activity recognition applications with wearable sensor nodes [<xref rid="B4-sensors-18-01672" ref-type="bibr">4</xref>,<xref rid="B5-sensors-18-01672" ref-type="bibr">5</xref>,<xref rid="B6-sensors-18-01672" ref-type="bibr">6</xref>].&#x000a0;The&#x000a0;reasons are two-fold: Firstly, approximating sensor signals with linear segments creates an alternative representation of the characteristic shape of that signal. This&#x000a0;is exploited by classification approaches like motif discovery [<xref rid="B6-sensors-18-01672" ref-type="bibr">6</xref>] or trajectory-based distance metrics [<xref rid="B4-sensors-18-01672" ref-type="bibr">4</xref>,<xref rid="B7-sensors-18-01672" ref-type="bibr">7</xref>]. Secondly, a reduced amount of data is required to represent a signal and to process it further. This&#x000a0;is important for data mining when huge amounts of data have to be processed. Furthermore, in activity recognition settings with wearable sensor nodes, data collected at sampling frequencies of e.g., 100 Hz has either to be stored for longer periods of time or transmitted via wireless interfaces. The&#x000a0;motivation to reduce sensor data already on the wearable sensor node results from the significant energy consumption introduced by either transmitting raw sensor data wirelessly [<xref rid="B5-sensors-18-01672" ref-type="bibr">5</xref>,<xref rid="B8-sensors-18-01672" ref-type="bibr">8</xref>] or by storing it to flash memory for later offline processing [<xref rid="B9-sensors-18-01672" ref-type="bibr">9</xref>]. Both consumes a significant amount of energy on wearable sensor nodes. Since PLA techniques allow a reduction of sensor data while providing a signal representation that has shown to be well suited for activity recognition and data mining purposes, our focus within this paper is on PLA algorithms.</p><p>While the most optimized state-of-the-art PLA algorithm [<xref rid="B5-sensors-18-01672" ref-type="bibr">5</xref>] has been designed for embedded wearable devices with limited processing power, it still needs a buffer for sensor data in order to achieve a good compression. Such buffer-based PLA techniques can only produce segments with a maximum length of the buffer size. In situations where the sensor signal has no fluctuations (e.g.,&#x000a0;an&#x000a0;accelerometer which is not moved over a longer period), many segments as small as the buffer size would be created instead of a single long segment. Therefore, the&#x000a0;segment&#x02019;s length is constrained by the memory budget of the architecture. Furthermore, the&#x000a0;execution time of most state-of-the-art PLAs depends on the segments&#x02019; lengths. This&#x000a0;in turn requires a small buffer or a limit on the segments&#x02019; length to fulfill possibly existing real-time requirements. Limiting the buffer size in turn decreases the possible compression and thus the reduction of energy consumption due to wireless transmissions.</p><p>In the context of activity recognition, a PLA algorithm has the following constraints when performed on a wireless sensor node:<list list-type="bullet"><list-item><p>a maximum segment error guaranty must be ensured,</p></list-item><list-item><p>an execution time that is guaranteed to be smaller than the sampling period in order to fulfill real-time requirements,</p></list-item></list>
while targeting the objectives:<list list-type="bullet"><list-item><p>minimal memory consumption,</p></list-item><list-item><p>low latency of segment creation,</p></list-item><list-item><p>high compression ratio, and</p></list-item><list-item><p>small average computation time, preventing high energy consumption of the processing unit.</p></list-item></list></p><p>Although many online PLA approaches have been reported in literature for compressing sensor data or time series data in general [<xref rid="B1-sensors-18-01672" ref-type="bibr">1</xref>,<xref rid="B4-sensors-18-01672" ref-type="bibr">4</xref>,<xref rid="B10-sensors-18-01672" ref-type="bibr">10</xref>,<xref rid="B11-sensors-18-01672" ref-type="bibr">11</xref>] and even some of them already introduced PLA approaches to reduce energy consumption in WSNs (Wireless Sensor Networks) [<xref rid="B2-sensors-18-01672" ref-type="bibr">2</xref>,<xref rid="B3-sensors-18-01672" ref-type="bibr">3</xref>,<xref rid="B5-sensors-18-01672" ref-type="bibr">5</xref>], none of them can fulfill the all constraints without compromising the objectives.</p><p>To the best of our knowledge, our proposed algorithm introduced by the paper at hand is the only existing PLA algorithm that offers both a computational complexity of <inline-formula><mml:math id="mm1"><mml:mrow><mml:mrow><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and a memory complexity of <inline-formula><mml:math id="mm2"><mml:mrow><mml:mrow><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. Moreover, our evaluations for an ARM Cortex-M4 microcontroller showed a maximum execution time of at most 203 instructions per invocation, while having a memory requirement of only 23 variables. This&#x000a0;is a considerable reduction when compared to state-of-the-art PLA algorithms. Furthermore, our algorithm provides comparable approximation quality to existing solutions, a maximum least-squares error guarantee per segment, as&#x000a0;well as a low latency and a small parameter&#x000a0;space.</p><p>Our paper is structured as follows. In <xref ref-type="sec" rid="sec2-sensors-18-01672">Section 2</xref>, related work is discussed and differences to our approach are elaborated. This&#x000a0;is followed by a thorough description of the mathematical basics to reproduce our algorithm in <xref ref-type="sec" rid="sec3-sensors-18-01672">Section 3</xref>. In <xref ref-type="sec" rid="sec4-sensors-18-01672">Section 4</xref>, our algorithm is explained in detail, including a version for multi-dimensional signals. An implementation of our algorithm is compared to two other existing state-of-the-art PLA techniques in <xref ref-type="sec" rid="sec5-sensors-18-01672">Section 5</xref>, which&#x000a0;is followed by a discussion of basic properties of our algorithm in <xref ref-type="sec" rid="sec6-sensors-18-01672">Section 6</xref>. Conclusions are drawn in <xref ref-type="sec" rid="sec7-sensors-18-01672">Section 7</xref>.</p></sec><sec id="sec2-sensors-18-01672"><title>2. Related Work</title><p>There are several online PLA algorithms available in literature, also referred to as segmentation algorithms. In [<xref rid="B1-sensors-18-01672" ref-type="bibr">1</xref>], the SWAB (Sliding Window and Bottom Up) algorithm has been introduced, which is a combination of the offline Bottom-Up segmentation and the Sliding Window (SW) approach, to&#x000a0;create an online algorithm. A conceptual optimization of this algorithm has been introduced in [<xref rid="B4-sensors-18-01672" ref-type="bibr">4</xref>] called mSWAB, which&#x000a0;was further improved for resource constrained wearable sensor nodes in [<xref rid="B5-sensors-18-01672" ref-type="bibr">5</xref>], called&#x000a0;emSWAB. All the aforementioned approaches require to buffer data, which&#x000a0;in turn constrains the segment length with the maximum buffer size. Furthermore, even including the most optimized version emSWAB, the&#x000a0;aforementioned approaches have worst-case execution times depending on the length of the current segment within the buffer. This&#x000a0;results from the iterative computation of the residual error of that segment, which&#x000a0;has to be completely recalculated when a new sample is added. In contrast, our proposed approach has a small and data independent worst-case execution time, especially regarding the current segment&#x02019;s length, as,&#x000a0;for a new sensor sample, the segment and its error can be iteratively updated without the need of iterating over all samples covered by that segment&#x000a0;again.</p><p>Furthermore, all the aforementioned approaches are based on <italic>linear interpolation</italic>, while our approach is based on <italic>linear regression</italic>. In [<xref rid="B1-sensors-18-01672" ref-type="bibr">1</xref>], it was reported that linear regression based segmentations of time series lead to a disjoint look of the approximated signal since the segments are not connected. In the paper at hand, we show that this can be avoided by calculating a linear regression without an intercept term, allowing a segment originating in the previous segment&#x02019;s endpoint.</p><p>In [<xref rid="B2-sensors-18-01672" ref-type="bibr">2</xref>,<xref rid="B3-sensors-18-01672" ref-type="bibr">3</xref>], PLA algorithms have been introduced to reduce the amount of data collected in WSNs by approximating the signals. Both algorithms are buffer-based with a worst-case computation time depending on the buffer length as well. In [<xref rid="B10-sensors-18-01672" ref-type="bibr">10</xref>], a fast alternative for time series segmentation is reported, which&#x000a0;trades computation time with a drastic increasing memory consumption. The&#x000a0;authors argue &#x0201c;that we will soon have infinite storage so that trading storage for speed is a good choice&#x0201d; [<xref rid="B10-sensors-18-01672" ref-type="bibr">10</xref>]. This&#x000a0;obviously does not apply for resource constrained architectures like wearable sensor nodes. In&#x000a0;contrast, our proposed approach has a constant computation and memory complexity at the same&#x000a0;time.</p><p>In [<xref rid="B11-sensors-18-01672" ref-type="bibr">11</xref>], another segmentation approach based on Polynomial Least-Squares Approximation with polynomials of arbitrary order is introduced. Since these also include first order polynomials that leads to linear segments, they need to be considered here as well. While their approach leads to a fast computation time for each new data point independent of the segment&#x02019;s length, they still need to buffer data, if a piecewise linear approximation is targeted, which&#x000a0;requires both segmentation points and slopes. In their experiments, it can be seen that their approach using first order polynomials basically leads to similar results with respect to approximation error and compression rate when compared to&#x000a0;SW.</p><p>Another PLA algorithm with a constant update time has been introduced in [<xref rid="B12-sensors-18-01672" ref-type="bibr">12</xref>]. However, again&#x000a0;their approach is buffer-based as well with a worst-case space complexity of <inline-formula><mml:math id="mm3"><mml:mrow><mml:mrow><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and uses in their experiments around 1 KB memory. Furthermore, their approach is a mixture between connected and non-connected piecewise segments. With our algorithm, we address the problem of approximating sensors signals with connected piecewise segments, which&#x000a0;is fast and small enough to be performed on processing and memory constrained architectures.</p></sec><sec id="sec3-sensors-18-01672"><title>3. Simple Linear Regression</title><p>Before describing our approach, we want to recap some basics on <italic>simple linear regression</italic> first. Simple linear regression is a linear regression model that explains the relation of a dependent variable as a function of an independent variable as best in terms of the minimum sum of squared residuals (<italic>SSR</italic>) error. Usually, the&#x000a0;residuals are minimized by using the ordinary least squares method. The&#x000a0;linear model, in the following referred to as <italic>regression line</italic>, is usually described as <inline-formula><mml:math id="mm4"><mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mo>=</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo>+</mml:mo><mml:mi>&#x003b2;</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>, with <inline-formula><mml:math id="mm5"><mml:mrow><mml:mi>&#x003b1;</mml:mi></mml:mrow></mml:math></inline-formula> being the intercept term with the <italic>y</italic>-axis and <inline-formula><mml:math id="mm6"><mml:mrow><mml:mi>&#x003b2;</mml:mi></mml:mrow></mml:math></inline-formula> being the slope of the regression line. As we focus on a signal approximation by connected linear segments, we force the regression line to pass through the origin. This&#x000a0;results in a regression line without intercept term <inline-formula><mml:math id="mm7"><mml:mrow><mml:mi>&#x003b1;</mml:mi></mml:mrow></mml:math></inline-formula>: <disp-formula id="FD1-sensors-18-01672"><label>(1)</label><mml:math id="mm8"><mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mo>=</mml:mo><mml:mi>&#x003b2;</mml:mi><mml:mi>x</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>In general, it is not possible to model a set of <italic>n</italic> observed data pairs <inline-formula><mml:math id="mm9"><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> with a single value <inline-formula><mml:math id="mm10"><mml:mrow><mml:msub><mml:mi>&#x003b2;</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Instead of deviations from this model, called errors, can be observed. The&#x000a0;underlying relationship between <inline-formula><mml:math id="mm11"><mml:mrow><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="mm12"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> including the corresponding errors <inline-formula><mml:math id="mm13"><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is described&#x000a0;by:<disp-formula id="FD2-sensors-18-01672"><label>(2)</label><mml:math id="mm14"><mml:mrow><mml:mrow><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003b2;</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>.</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>For a given estimator <inline-formula><mml:math id="mm15"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, the&#x000a0;SSR error is thus computed by:<disp-formula id="FD3-sensors-18-01672"><label>(3)</label><mml:math id="mm16"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>=</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:msubsup><mml:mi>e</mml:mi><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo>.</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>For the general case of linear regression with multiple independent variables, where <italic>Y</italic> is the vector of responses <inline-formula><mml:math id="mm17"><mml:mrow><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> for all <inline-formula><mml:math id="mm18"><mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>&#x022ef;</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>, <italic>X</italic> is a so called design matrix with each row being the observation vector <inline-formula><mml:math id="mm19"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> with <inline-formula><mml:math id="mm20"><mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>&#x022ef;</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> and columns <italic>j</italic> for each independent variable (regressors). For&#x000a0;this case, <inline-formula><mml:math id="mm21"><mml:mrow><mml:msub><mml:mi>&#x003b2;</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is a vector comprising the parameters of each regressor. Note that here the constant term is not modeled explicitly, but included in the design matrix as one column <inline-formula><mml:math id="mm22"><mml:mrow><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula> for all <inline-formula><mml:math id="mm23"><mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>&#x022ef;</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>. Thus, the&#x000a0;parameter <inline-formula><mml:math id="mm24"><mml:mrow><mml:msub><mml:mi>&#x003b2;</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:msub></mml:msub></mml:mrow></mml:math></inline-formula> is the resulting intercept term. The&#x000a0;well-known ordinary least squares (OLS) estimator <inline-formula><mml:math id="mm25"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is:<disp-formula id="FD4-sensors-18-01672"><label>(4)</label><mml:math id="mm26"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:msub><mml:mi>&#x003b2;</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msup><mml:mi>X</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>X</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:msup><mml:mi>X</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>y</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mfrac><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msubsup><mml:mi>x</mml:mi><mml:mi>i</mml:mi><mml:mi>T</mml:mi></mml:msubsup><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>&#x000b7;</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mfrac><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mspace width="4pt"/><mml:mo>,</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula>
with <inline-formula><mml:math id="mm27"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msup><mml:mi>X</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>X</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:msup><mml:mi>X</mml:mi><mml:mi>T</mml:mi></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> being the <italic>Moore-Penrose pseudoinverse</italic> of <italic>X</italic>. From Equation (<xref ref-type="disp-formula" rid="FD4-sensors-18-01672">4</xref>), it can be seen that, in simple linear regression with only one independent variable and without the intercept term, <inline-formula><mml:math id="mm28"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is a scalar and the scalar estimator <inline-formula><mml:math id="mm29"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is calculated by:<disp-formula id="FD5-sensors-18-01672"><label>(5)</label><mml:math id="mm30"><mml:mrow><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:msubsup><mml:mi>x</mml:mi><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:msub><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:msub><mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mfrac><mml:mo>,</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula>
with <inline-formula><mml:math id="mm31"><mml:mrow><mml:mrow><mml:msub><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mi>n</mml:mi></mml:mfrac></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="mm32"><mml:mrow><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:msubsup><mml:mi>x</mml:mi><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mi>n</mml:mi></mml:mfrac></mml:mrow></mml:mrow></mml:math></inline-formula> denoting the mean of all <inline-formula><mml:math id="mm33"><mml:mrow><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> products and the mean of all <inline-formula><mml:math id="mm34"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> squares up to the <italic>n</italic>-th observation, respectively.</p><p>In <xref ref-type="sec" rid="sec4-sensors-18-01672">Section 4</xref>, we show that this allows us to quickly determine <inline-formula><mml:math id="mm35"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> for a new data point by updating <inline-formula><mml:math id="mm36"><mml:mrow><mml:msub><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="mm37"><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. In order to calculate the <inline-formula><mml:math id="mm38"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> from the updated variables and the OLS estimator <inline-formula><mml:math id="mm39"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> for each new data point, we need to resolve Equation (<xref ref-type="disp-formula" rid="FD3-sensors-18-01672">3</xref>) with the binomial formula to:<disp-formula id="FD6-sensors-18-01672"><label>(6)</label><mml:math id="mm40"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:msubsup><mml:mi>y</mml:mi><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msubsup><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:msubsup><mml:mi>x</mml:mi><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo>.</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>Each sum can then be rewritten using the corresponding mean values multiplied by <italic>n</italic>:<disp-formula id="FD7-sensors-18-01672"><label>(7)</label><mml:math id="mm41"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover><mml:msup><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:msub><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:msubsup><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:msub><mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:mi>n</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>Resolving <inline-formula><mml:math id="mm42"><mml:mrow><mml:mrow><mml:msubsup><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:msub><mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="mm43"><mml:mrow><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:msub><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> from Equation (<xref ref-type="disp-formula" rid="FD5-sensors-18-01672">5</xref>) gives:<disp-formula id="FD8-sensors-18-01672"><label>(8)</label><mml:math id="mm44"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mover><mml:msup><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:msub><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><sec id="sec3dot1-sensors-18-01672"><title>Incremental Updating</title><p>By using Equation (<xref ref-type="disp-formula" rid="FD5-sensors-18-01672">5</xref>) for calculating the slope and Equation (<xref ref-type="disp-formula" rid="FD8-sensors-18-01672">8</xref>) for calculating the error, all the necessary means <inline-formula><mml:math id="mm45"><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="mm46"><mml:mrow><mml:msub><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, and&#x000a0;<inline-formula><mml:math id="mm47"><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> up to the <italic>n</italic>-th sample can be updated and the corresponding <inline-formula><mml:math id="mm48"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="mm49"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> can be recalculated with a constant computational complexity independent of <italic>n</italic> for each new data point. This&#x000a0;is based on updating a mean <inline-formula><mml:math id="mm50"><mml:mrow><mml:msub><mml:mover><mml:mi>z</mml:mi><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> with each new sample <inline-formula><mml:math id="mm51"><mml:mrow><mml:msub><mml:mi>z</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> by:<disp-formula id="FD9-sensors-18-01672"><label>(9)</label><mml:math id="mm52"><mml:mrow><mml:mrow><mml:msub><mml:mover><mml:mi>z</mml:mi><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:msub><mml:mi>z</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mi>n</mml:mi></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:msub><mml:mi>z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mi>n</mml:mi></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>Substituting <inline-formula><mml:math id="mm53"><mml:mrow><mml:mrow><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:msub><mml:mi>z</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> with <inline-formula><mml:math id="mm54"><mml:mrow><mml:mrow><mml:msub><mml:mover><mml:mi>z</mml:mi><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>&#x000b7;</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> gives the equation updating the mean <inline-formula><mml:math id="mm55"><mml:mrow><mml:msub><mml:mover><mml:mi>z</mml:mi><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> with the new sample <inline-formula><mml:math id="mm56"><mml:mrow><mml:msub><mml:mi>z</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> from [<xref rid="B13-sensors-18-01672" ref-type="bibr">13</xref>]:<disp-formula id="FD10-sensors-18-01672"><label>(10)</label><mml:math id="mm57"><mml:mrow><mml:mrow><mml:msub><mml:mover><mml:mi>z</mml:mi><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mover><mml:mi>z</mml:mi><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mi>n</mml:mi></mml:mfrac><mml:mo>+</mml:mo><mml:mfrac><mml:msub><mml:mi>z</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mi>n</mml:mi></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>We rearranged the equation to:<disp-formula id="FD11-sensors-18-01672"><label>(11)</label><mml:math id="mm58"><mml:mrow><mml:mrow><mml:msub><mml:mover><mml:mi>z</mml:mi><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover><mml:mi>z</mml:mi><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>z</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mover><mml:mi>z</mml:mi><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mi>n</mml:mi></mml:mfrac><mml:mo>,</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula>
which sacrifices slightly in numerical precision, which&#x000a0;will be discussed in <xref ref-type="sec" rid="sec6dot1-sensors-18-01672">Section 6.1</xref>, but saves a multiplication and a division, in order to reduce the processing time.</p><p>This equation can be used for updating all means <inline-formula><mml:math id="mm59"><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="mm60"><mml:mrow><mml:msub><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, and&#x000a0;<inline-formula><mml:math id="mm61"><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> for each new sample to recalculate <inline-formula><mml:math id="mm62"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="mm63"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> with Equations (<xref ref-type="disp-formula" rid="FD5-sensors-18-01672">5</xref>) and (<xref ref-type="disp-formula" rid="FD8-sensors-18-01672">8</xref>) in constant time, respectively.</p></sec></sec><sec id="sec4-sensors-18-01672"><title>4. Online Piecewise Linear Approximation</title><p>We now introduce a problem definition of online piecewise linear approximation of sensor signals. Assume a sensor signal sampled at different timestamps, which&#x000a0;leads to a series <italic>S</italic> of sensor samples <inline-formula><mml:math id="mm64"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mi>s</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mi>s</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mn>2</mml:mn><mml:mo>]</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mn>2</mml:mn><mml:mo>]</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo>&#x022ef;</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mi>s</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>n</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mi>n</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> where each sample <inline-formula><mml:math id="mm65"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> consists of the signal value <italic>s</italic> and the corresponding timestamp <inline-formula><mml:math id="mm66"><mml:mrow><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. A piecewise linear approximation of that signal is a series <inline-formula><mml:math id="mm67"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> of segment points <inline-formula><mml:math id="mm68"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mn>2</mml:mn><mml:mo>]</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mn>2</mml:mn><mml:mo>]</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo>&#x022ef;</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mi>n</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mi>n</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> where each segment point <inline-formula><mml:math id="mm69"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> consists of a signal value <inline-formula><mml:math id="mm70"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> and its corresponding timestamp <inline-formula><mml:math id="mm71"><mml:mrow><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover></mml:msub></mml:mrow></mml:math></inline-formula> and represents the end point of the previous segment and the start point of the next segment. A segment is thus represented by a pair of consecutive segment points <inline-formula><mml:math id="mm72"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. Furthermore, <inline-formula><mml:math id="mm73"><mml:mrow><mml:mrow><mml:mo>&#x02200;</mml:mo><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover></mml:msub><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mi>&#x003f5;</mml:mi><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mo>:</mml:mo><mml:mo>&#x02203;</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mi>&#x003f5;</mml:mi><mml:mi>S</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> holds, as&#x000a0;the segmentation points are created at timestamps of the original sensor samples. Additionally, a&#x000a0;user-defined threshold <inline-formula><mml:math id="mm74"><mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>H</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> on the SSR of a segment is given, which&#x000a0;needs to be guaranteed for all segments within the approximation process.</p><p>An example of a piecewise linear approximated Electrocardiography (ECG) signal can be seen in <xref ref-type="fig" rid="sensors-18-01672-f001">Figure 1</xref>.</p><p>Some PLA techniques use, for the approximation of a segment, the original sample values at the beginning and ending of the segment. Similar to [<xref rid="B12-sensors-18-01672" ref-type="bibr">12</xref>], our approach does also use approximations of those values. We&#x000a0;can not draw any advantage or disadvantage from this characteristic as can be seen in <xref ref-type="sec" rid="sec5-sensors-18-01672">Section 5</xref>. With growing segment sizes, the ratio of original values to approximated values would become fairly small, whereby the influence additionally decreases. Since the approximation of the segment points&#x02019; values are included in the <inline-formula><mml:math id="mm75"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>S</mml:mi><mml:mi>R</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> calculation, the&#x000a0;<inline-formula><mml:math id="mm76"><mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>H</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> is guaranteed to be an upper bound on the approximation error of a segment.</p><p>In order to achieve a piecewise linear approximation <inline-formula><mml:math id="mm77"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> of a sensors signal <italic>S</italic> online, the&#x000a0;sensor signal needs to be continuously represented, i.e.,&#x000a0;the segment corresponding to the last sensor sample needs to be outputted as soon as its end point is determined due to an exceeded threshold. Therefore, online PLA algorithms perform a sample-based processing, which&#x000a0;means that the algorithm is invoked with each new sensor sample. The&#x000a0;processing time for each invocation of the algorithm is referred to as its execution time.</p><p>In the process of online approximation, the&#x000a0;average execution time needs to be smaller than the sampling period, in order to not lose any samples. In order to avoid additional latencies and additional memory consumption due to input buffering, even the worst-case execution should be smaller than the sampling period. Moreover, a data independent execution time is preferable, as&#x000a0;this guarantees a predictable maximum sampling period at which the algorithm is able to approximate the signal in real time without compromising the compression abilities.</p><p>The SW algorithm for example adds a new sample to the current segment in its buffer, each&#x000a0;time the algorithm is invoked. It creates a segment from the previous segment&#x02019;s end point to the newly added sample and calculates the residual error of this segment. This&#x000a0;error calculation involves <italic>n</italic> steps for a segment length of <italic>n</italic> and has to be recalculated each time the algorithm is invoked, as&#x000a0;the segment changes with each newly added sample. If the calculated segment error is below <inline-formula><mml:math id="mm78"><mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>H</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>, the&#x000a0;routine returns without outputting that segment and will be invoked with the next incoming sensor sample. If the segment error is above <inline-formula><mml:math id="mm79"><mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>H</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>, the&#x000a0;segment from the previous invocation is recreated, which&#x000a0;still satisfied the maximum error guarantee and is outputted. A new segment is started from this point. Due to the error calculation, the&#x000a0;execution time of the SW algorithm depends on the current segment&#x02019;s length and increases with each invocation in which the segment error has not reached <inline-formula><mml:math id="mm80"><mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>H</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>. Furthermore, the&#x000a0;memory consumption for buffering the last <italic>n</italic> sensor samples increases likewise. Thus, with longer segments, both the&#x000a0;execution time and the memory consumption of each invocation increases. In order to guarantee a maximum execution time and memory consumption, the&#x000a0;maximum buffer size needs to be constrained to a possibly small size, which&#x000a0;in turn limits the compression ability of the algorithm.</p><sec id="sec4dot1-sensors-18-01672"><title>4.1. CPLR Approximation</title><p>In order to overcome this drawback, our algorithm makes use of the updating abilities of simple linear regression as discussed in <xref ref-type="sec" rid="sec3-sensors-18-01672">Section 3</xref>. Instead of recalculating the slope and the error between the previous segment&#x02019;s endpoint and the current sensor sample, our approach updates the slope <inline-formula><mml:math id="mm81"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and the corresponding segment error (<inline-formula><mml:math id="mm82"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>) of the regression line with each new sensor sample. Since the regression line has its origin in the previous segment point, our algorithm is performing a Connected Piecewise Linear Regression (CPLR) of the sensor signal.</p><p>This regression line and its error can be updated by a small number of calculations shown in the previous section, independent of the segment&#x02019;s length, while obtaining the minimal <inline-formula><mml:math id="mm83"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>S</mml:mi><mml:mi>R</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> to the original data. The idea is as follows: the <inline-formula><mml:math id="mm84"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-th segment , which&#x000a0;is the regression line of a simple linear regression, starts at the end point of the previous segment <inline-formula><mml:math id="mm85"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. Thus, <inline-formula><mml:math id="mm86"><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="mm87"><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, and&#x000a0;<inline-formula><mml:math id="mm88"><mml:mrow><mml:msub><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are updated by Equation (<xref ref-type="disp-formula" rid="FD11-sensors-18-01672">11</xref>) with <inline-formula><mml:math id="mm89"><mml:mrow><mml:msub><mml:mi>y</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> being the difference between a new sample&#x02019;s value <inline-formula><mml:math id="mm90"><mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>[</mml:mo><mml:mi>n</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and the value of the previous segment point <inline-formula><mml:math id="mm91"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="mm92"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> being the difference between the new sample&#x02019;s timestamp <inline-formula><mml:math id="mm93"><mml:mrow><mml:mrow><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mi>n</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> and the previous segment point&#x02019;s timestamp <inline-formula><mml:math id="mm94"><mml:mrow><mml:mrow><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p>Note that we do not require the sensor signal to be sampled at equidistant intervals for our approach. However, without loss of generality, we will presume a constant sampling period in the following for the sake of simplicity. Thus, the&#x000a0;sample number <italic>n</italic> within the current segment can be used for the <inline-formula><mml:math id="mm95"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> values instead. The pseudo code for our CPLR routine is given in Algorithm&#x000a0;1.</p><array orientation="portrait"><tbody><tr><td style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1"><bold>Algorithm 1</bold> Connected Piecewise Linear Regression.</td></tr><tr><td style="border-bottom:solid thin" rowspan="1" colspan="1">
<list list-type="simple"><list-item><label>1:</label><p><bold>procedure</bold><sc>process_sample</sc>(sample value <italic>s</italic>, segment array <inline-formula><mml:math id="mm96"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula>, index <italic>k</italic>)</p></list-item><list-item><label>2:</label><p>&#x02003;&#x000a0;&#x000a0;<inline-formula><mml:math id="mm97"><mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item><label>3:</label><p>&#x02003;&#x000a0;&#x000a0;<inline-formula><mml:math id="mm98"><mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mo>=</mml:mo><mml:mi>s</mml:mi><mml:mo>-</mml:mo><mml:mi>v</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi><mml:mi>u</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item><label>4:</label><p>&#x02003;&#x000a0;&#x000a0;<inline-formula><mml:math id="mm99"><mml:mrow><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>&#x000b7;</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>-</mml:mo><mml:msub><mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>/</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item><label>5:</label><p>&#x02003;&#x000a0;&#x000a0;<inline-formula><mml:math id="mm100"><mml:mrow><mml:mrow><mml:msub><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>&#x000b7;</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>-</mml:mo><mml:msub><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>/</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item><label>6:</label><p>&#x02003;&#x000a0;&#x000a0;<inline-formula><mml:math id="mm101"><mml:mrow><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover><mml:msup><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo>&#x000b7;</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>-</mml:mo><mml:msub><mml:mover><mml:msup><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>/</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item><label>7:</label><p>&#x02003;&#x000a0;&#x000a0;<inline-formula><mml:math id="mm102"><mml:mrow><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:mo>/</mml:mo><mml:msub><mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item><label>8:</label><p>&#x02003;&#x000a0;&#x000a0;<inline-formula><mml:math id="mm103"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mover><mml:msup><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:msub><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>&#x000b7;</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item><label>9:</label><p>&#x02003;&#x000a0;&#x000a0;<bold>if</bold>
<inline-formula><mml:math id="mm104"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>&#x0003c;</mml:mo><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mi>H</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>
<bold>then</bold></p></list-item><list-item><label>10:</label><p>&#x02003;&#x000a0;&#x000a0;&#x02003;&#x000a0;&#x000a0;<inline-formula><mml:math id="mm105"><mml:mrow><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item><label>11:</label><p>&#x02003;&#x000a0;&#x000a0;&#x02003;&#x000a0;&#x000a0;<inline-formula><mml:math id="mm106"><mml:mrow><mml:mrow><mml:msub><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item><label>12:</label><p>&#x02003;&#x000a0;&#x000a0;&#x02003;&#x000a0;&#x000a0;<inline-formula><mml:math id="mm107"><mml:mrow><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover><mml:msup><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item><label>13:</label><p>&#x02003;&#x000a0;&#x000a0;&#x02003;&#x000a0;&#x000a0;<inline-formula><mml:math id="mm108"><mml:mrow><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item><label>14:</label><p>&#x02003;&#x000a0;&#x000a0;&#x02003;&#x000a0;&#x000a0;return</p></list-item><list-item><label>15:</label><p>&#x02003;&#x000a0;&#x000a0;</p></list-item><list-item><label>16:</label><p>&#x02003;&#x000a0;&#x000a0;<inline-formula><mml:math id="mm109"><mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>m</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>m</mml:mi><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item><label>17:</label><p>&#x02003;&#x000a0;&#x000a0;<inline-formula><mml:math id="mm110"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mi>v</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi><mml:mi>u</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>&#x000b7;</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item><label>18:</label><p>&#x02003;&#x000a0;&#x000a0;<inline-formula><mml:math id="mm111"><mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item><label>19:</label><p>&#x02003;&#x000a0;&#x000a0;<inline-formula><mml:math id="mm112"><mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mo>=</mml:mo><mml:mi>s</mml:mi><mml:mo>-</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item><label>20:</label><p>&#x02003;&#x000a0;&#x000a0;<inline-formula><mml:math id="mm113"><mml:mrow><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item><label>21:</label><p>&#x02003;&#x000a0;&#x000a0;<inline-formula><mml:math id="mm114"><mml:mrow><mml:mrow><mml:msub><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item><label>22:</label><p>&#x02003;&#x000a0;&#x000a0;<inline-formula><mml:math id="mm115"><mml:mrow><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>y</mml:mi><mml:mo>&#x000b7;</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item><label>23:</label><p>&#x02003;&#x000a0;&#x000a0;<inline-formula><mml:math id="mm116"><mml:mrow><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:mo>/</mml:mo><mml:msub><mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item><label>24:</label><p>&#x02003;&#x000a0;&#x000a0;<inline-formula><mml:math id="mm117"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item><label>25:</label><p>&#x02003;&#x000a0;&#x000a0;<inline-formula><mml:math id="mm118"><mml:mrow><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item><label>26:</label><p>&#x02003;&#x000a0;&#x000a0;<inline-formula><mml:math id="mm119"><mml:mrow><mml:mrow><mml:msub><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item><label>27:</label><p>&#x02003;&#x000a0;&#x000a0;<inline-formula><mml:math id="mm120"><mml:mrow><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover><mml:msup><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item><label>28:</label><p>&#x02003;&#x000a0;&#x000a0;<inline-formula><mml:math id="mm121"><mml:mrow><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item><label>29:</label><p>&#x02003;&#x000a0;&#x000a0;<inline-formula><mml:math id="mm122"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item><label>30:</label><p>&#x02003;&#x000a0;&#x000a0;return</p></list-item></list>
</td></tr></tbody></array><p>The threshold value <inline-formula><mml:math id="mm123"><mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>H</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> is set upon initialization and needs to be stored globally. When starting the online approximation of a sensor signal, the signal&#x02019;s very first sample <inline-formula><mml:math id="mm124"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>s</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> will be used as the initial segment point <inline-formula><mml:math id="mm125"><mml:mrow><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mi>s</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula>. The routine <italic>PROCESS_SAMPLE</italic> is called for each new sampled sensor value <italic>s</italic>, which is the first parameter given to the function along with the array <inline-formula><mml:math id="mm126"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> for storing segments and the index <italic>k</italic> for specifying at which position in <inline-formula><mml:math id="mm127"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> the new segment will be stored. Note that the array of segments <inline-formula><mml:math id="mm128"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> does not necessarily need to store all the created segments, e.g., when always transmitting each new segment point to another device. However, <inline-formula><mml:math id="mm129"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> needs a size of at least two: for the previous segment&#x02019;s end point and the current segment&#x02019;s endpoint, which will be written to it when created. The variables <italic>n</italic>, <inline-formula><mml:math id="mm130"><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="mm131"><mml:mrow><mml:msub><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="mm132"><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math id="mm133"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> need to be stored globally and must be initialized with zero before starting the online approximation of a sensor signal.</p><p>At the beginning, the size <italic>n</italic> of the current segment is incremented by the new sample in line 2. In line 3, the actual <italic>y</italic> value is calculated from the new sensor value <italic>s</italic> and the previous segment points value <inline-formula><mml:math id="mm134"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula>. The function <italic>value()</italic> returns the value part and <italic>timestamp()</italic> returns the timestamp part of the segment point <inline-formula><mml:math id="mm135"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow><mml:mo>)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> respectively. From lines 4 to 8, the means <inline-formula><mml:math id="mm136"><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="mm137"><mml:mrow><mml:msub><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math id="mm138"><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are updated from their previous values <inline-formula><mml:math id="mm139"><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="mm140"><mml:mrow><mml:msub><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math id="mm141"><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> with the new <italic>y</italic> value, respectively, and the estimated slope <inline-formula><mml:math id="mm142"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and the new segment error <inline-formula><mml:math id="mm143"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> is calculated. If the new <inline-formula><mml:math id="mm144"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> is below <inline-formula><mml:math id="mm145"><mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>H</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> (line 9), the updated means <inline-formula><mml:math id="mm146"><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="mm147"><mml:mrow><mml:msub><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math id="mm148"><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and the slope <inline-formula><mml:math id="mm149"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are stored for the next invocation (line 10 to 13) and the routine returns without creating a new segment point. If <inline-formula><mml:math id="mm150"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> exceeds <inline-formula><mml:math id="mm151"><mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>H</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> instead, a new segment point is created at the previous sample&#x02019;s timestamp (line 16) by extrapolating the value of the segment&#x02019;s endpoint from the previous invocation&#x02019;s slope estimate <inline-formula><mml:math id="mm152"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> (line 17) with the following equation: <disp-formula id="FD12-sensors-18-01672"><label>(12)</label><mml:math id="mm153"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>The newly started segment&#x02019;s (<inline-formula><mml:math id="mm154"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula>) size is updated in line 18, and the <italic>y</italic> value from the sample <italic>s</italic> to the newly created segment&#x02019;s value <inline-formula><mml:math id="mm155"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> is calculated in line 19. From lines 20 to 23, the means are initialized with the new <italic>y</italic> as the first sample of the newly started segment and the slope <inline-formula><mml:math id="mm156"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is recalculated from them. The <inline-formula><mml:math id="mm157"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> of the new segment is set to zero, as the new segment only consists of two values, which introduces no deviations. From lines 25 to 28, the means <inline-formula><mml:math id="mm158"><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="mm159"><mml:mrow><mml:msub><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math id="mm160"><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="mm161"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are stored and finally the new segment point <inline-formula><mml:math id="mm162"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is written to the segments array in line 29. For the sake of clarity, the principle including the <inline-formula><mml:math id="mm163"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> exceeding <inline-formula><mml:math id="mm164"><mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>H</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> is illustrated in <xref ref-type="fig" rid="sensors-18-01672-f002">Figure 2</xref>.</p><p>Note that the error metric per segment can easily be changed to an average per sample approximation error metric by dividing the current segment&#x02019;s <inline-formula><mml:math id="mm165"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> error by the number of samples <italic>n</italic> covered by that segment. This can be useful in applications that require a guaranteed relative least-squares approximation error bound. Furthermore, an average per sample approximation error allows for specifying a maximum error guarantee for a finite set of samples, if <inline-formula><mml:math id="mm166"><mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>H</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> is chosen to be the maximum error divided by the number of samples.</p></sec><sec id="sec4dot2-sensors-18-01672"><title>4.2. Multi-Dimensional CPLR Implementation</title><p>The algorithm can be implemented to approximate multi-dimensional signals with <italic>D</italic> dimensions, by holding and updating the variables <inline-formula><mml:math id="mm167"><mml:mrow><mml:msubsup><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi><mml:mi>d</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="mm168"><mml:mrow><mml:msubsup><mml:mover><mml:msup><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi><mml:mi>d</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="mm169"><mml:mrow><mml:msubsup><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi><mml:mi>d</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math id="mm170"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>S</mml:mi><mml:msubsup><mml:mi>R</mml:mi><mml:mi>n</mml:mi><mml:mi>d</mml:mi></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> respectively for each dimension <italic>d</italic> and the mean of the timestamps <inline-formula><mml:math id="mm171"><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> for all dimensions together, as the value of each dimension is supposed to be sampled at the same time. As we use the sum of squared residuals error, the error of the resulting <italic>D</italic>-dimensional segment can be calculated by summing up the <inline-formula><mml:math id="mm172"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>S</mml:mi><mml:msubsup><mml:mi>R</mml:mi><mml:mi>n</mml:mi><mml:mi>d</mml:mi></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> of all dimensions. This is possible due to the commutative property of summing up the squared residuals: <disp-formula id="FD13-sensors-18-01672"><label>(13)</label><mml:math id="mm173"><mml:mrow><mml:mrow><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>D</mml:mi></mml:munderover><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msubsup><mml:mi>y</mml:mi><mml:mi>i</mml:mi><mml:mi>d</mml:mi></mml:msubsup><mml:mo>-</mml:mo><mml:msubsup><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi><mml:mi>d</mml:mi></mml:msubsup><mml:msubsup><mml:mi>x</mml:mi><mml:mi>i</mml:mi><mml:mi>d</mml:mi></mml:msubsup><mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>=</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>D</mml:mi></mml:munderover><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msubsup><mml:mi>y</mml:mi><mml:mi>i</mml:mi><mml:mi>d</mml:mi></mml:msubsup><mml:mo>-</mml:mo><mml:msubsup><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi><mml:mi>d</mml:mi></mml:msubsup><mml:msubsup><mml:mi>x</mml:mi><mml:mi>i</mml:mi><mml:mi>d</mml:mi></mml:msubsup><mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>.</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>Thus, the residual error to the <italic>D</italic>-dimensional segment is calculated by:<disp-formula id="FD14-sensors-18-01672"><label>(14)</label><mml:math id="mm174"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>D</mml:mi></mml:munderover><mml:mi>S</mml:mi><mml:mi>S</mml:mi><mml:msubsup><mml:mi>R</mml:mi><mml:mi>n</mml:mi><mml:mi>d</mml:mi></mml:msubsup><mml:mo>.</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>Note, that using the sum of squared residuals error metric leads to a faster calculation on resource constraint architectures, as no square root has to be calculated. However, other solutions to calculate a multidimensional error are possible as well, e.g., sum of Euclidean distances.</p></sec></sec><sec id="sec5-sensors-18-01672"><title>5. Evaluation</title><p>In order to show the approximation quality of CPLR, we compared it to two other piecewise linear approximation techniques from the literature. We decided to use the emSWAB implementation from [<xref rid="B5-sensors-18-01672" ref-type="bibr">5</xref>], as it was specifically designed for resource constrained architectures and we implemented the SW algorithm as well. Since the emSWAB implementation is made for 8 bit data, we implemented our CPLR algorithm and the SW approximation for 8 bit data as well to stay comparable, while internally using single precision floating point data types for the variables like slope, error, and means. This is a fair comparison as all implementations were tested on an x86-64 system, from which the emSWAB implementation benefits in the same way as our implementations, as emSWAB does not save intermediate results for slope and error calculation in 8-bit variables. The algorithms for our experiments are implemented in C. Our implementations can be obtained by mailing the paper&#x02019;s first or last author. For the following experiments, we used emSWAB with a buffer size of 50 and SW with a buffer size of 100. This is a fair comparison, as the emSWAB algorithm actually scales the buffer size between half and double of the specified value. This means, in the following experiments, the emSWAB&#x02019;s maximum buffer size is 100 as well.</p><sec id="sec5dot1-sensors-18-01672"><title>5.1. Data Sets</title><p>As the approximation quality of the algorithms depends on the actual data, we used different data sets for the evaluation. In our first test, we recorded accelerometer and gyroscope data with a wireless sensor node in two scenarios. In the <italic>Kitchen</italic> scenario, the sensor was attached to the wrist of a user, while the user performed kitchen tasks like cutting carrots with a knife, stirring a bowl of ingredients with a wooden spoon, blending ingredients in a bowl with a hand-held blender and using a hand mixer. For both data (accelerometer and gyroscope), we used the vector lengths of the three-dimensional signals, in order to derive one-dimensional signals. An example of the accelerometer signal is partially shown in <xref ref-type="fig" rid="sensors-18-01672-f003">Figure 3</xref>.</p><p>In a second scenario, we recorded accelerometer and gyroscope signals of a <italic>Walking</italic> person. The sensor was attached to the shoe of the user and sampled the data at 100 Hz. The walking dataset includes straight paths, turns, walking upstairs and downstairs and also different walking speeds. An example of the accelerometer signal is partially shown in <xref ref-type="fig" rid="sensors-18-01672-f003">Figure 3</xref> as well.</p><p>As in the literature PLA algorithms are not only used for activity recognition scenarios, we also included experiments on available data sets from literature, which were used for the evaluation of PLA algorithms in other application domains. We used the timeseries data set (<italic>Timeseries</italic>) that came with the implementation of mSWAB from [<xref rid="B4-sensors-18-01672" ref-type="bibr">4</xref>] as well as the data sets from [<xref rid="B14-sensors-18-01672" ref-type="bibr">14</xref>] including ECG signals (<italic>ECG</italic>), valve time series of a Marotta Space Shuttle (<italic>Shuttle</italic>), and the time series of a patient&#x02019;s respiration measured by the thorax extension (<italic>Respiration</italic>), which are freely available at [<xref rid="B15-sensors-18-01672" ref-type="bibr">15</xref>]. These datasets are shown in <xref ref-type="fig" rid="sensors-18-01672-f003">Figure 3</xref> as well.</p></sec><sec id="sec5dot2-sensors-18-01672"><title>5.2. Approximation Quallity</title><p>We found two criteria that are the most important to describe the approximation quality of a PLA algorithm: the compression ratio and the resulting approximation error per sample, which is referred to as <italic>average residual error</italic> in the following. Note that the average residual error needs to be distinguished from the segment error. The latter is part of the PLA algorithms for calculating the absolute residual error of a segment (<inline-formula><mml:math id="mm175"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>S</mml:mi><mml:mi>R</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> for CPLR), in order to guarantee a maximum error per segment, while the average residual error is used for evaluation purposes: when a data set is approximated with one of the PLA algorithms, the average sum of squares error per sample of the approximated signal to its original signal is calculated, in order to evaluate the overall approximation error of that approximation. The average residual error of an approximated signal is its <inline-formula><mml:math id="mm176"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>S</mml:mi><mml:mi>R</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> to the original signal, divided by the number of samples of that data set.</p><p>At different compression ratios, the average residual error differs accordingly. Although we cannot assume monotonicity, as a general trend, the more the average residual error increases, the more the data is compressed. In general, we want a small average residual error, while simultaneously achieving a high compression ratio or a low <italic>inverse compression ratio</italic> (ICR), respectively. Thus, these two criteria are conflicting.</p><p>At a certain threshold, a PLA algorithm produces an approximation with an average residual error and an ICR. We refer to this pair of error and ICR as an <italic>operating point</italic>. While CPLR uses the same segment error metric like SW (i.e., <inline-formula><mml:math id="mm177"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>S</mml:mi><mml:mi>R</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>), the authors of emSWAB decided to implement their segment error metric as the sum of absolute distances, in order to avoid computationally costly square and square-root functions. However, this causes a different behavior on the threshold. While CPLR and SW reach an operating point at a certain threshold, emSWAB leads to a higher approximation error, but also higher compression ratio at the same threshold, thus another operating point. The interesting question is whether this operating point is also met by SW and CPLR at a higher threshold, or whether their approximation error is smaller or higher at the same compression ratio. Thus, it is not sufficient to compare two algorithms with the same threshold in order to compare the approximation quality. Both algorithms might lead to the same operating point at different thresholds. Furthermore, as the approximation of a time series for different thresholds is a discrete problem, it is not always possible to find a threshold, which leads to the exact same ICR or average residual error, respectively, of two PLA algorithms. In order to compare different PLA algorithms, we approximated the same time series multiple times with different thresholds and plotted the the resulting average residual error over the corresponding ICR (amount of compressed data to the amount of uncompressed data) for each operating point controlled by the threshold. This leads to curves sketching the dependency between both quality indicators of the PLA algorithms. Note that we used the ICR instead of the compression ratio, as it gives an intuition about the resulting relative data size after approximating a sensor signal. The nearer the curve is to the origin of the plot, the better is the approximation quality of the algorithm.</p><p>In our experiments, we evaluated 29 data sets with in total 536,175 samples, all of them approximated 10,000 times with emSWAB from threshold 1 to 10,000 and 100,000 times with both SW and CPLR from threshold 1 to 100,000. The range of thresholds at which emSWAB was performed in our experiments is smaller than for CPLR and SW, as the error metric of emSWAB is a sum of absolute distances. This is explained in the following. At a certain threshold, the emSWAB algorithm might lead to an operating point that can be achieved with CPLR and SW at a much higher threshold, since the sum of squares error in CPLR and SW reaches the threshold faster than the sum of absolute distances used in emSWAB. Thus, the range of thresholds at which CPLR and SW were evaluated in our experiments needed to be larger as for emSWAB in order to reach the same range of operating points for comparisons. Note, that the segment error is an absolute error for a whole segment while the average residual error is a per-sample error. Thus, the segment errors and correspondingly the thresholds are higher then the resulting average residual error in the plots.</p><p>As can be seen in <xref ref-type="fig" rid="sensors-18-01672-f004">Figure 4</xref>, the general trend is a higher average residual error for lower ICRs. Comparing the quality plots <italic>Kitchen</italic>, <italic>Walking</italic>, and <italic>Timeseries</italic> with <italic>ECG</italic>, the ICR of the latter is smaller at similar average residual errors. This means for the <italic>ECG</italic> data set a higher compression rate for comparable approximation errors can be achieved. This mainly results from the signal structure of the <italic>ECG</italic> signal, which contains a higher amount of non-fluctuating signal parts compared to the other data sets.</p><p>For the respiration data set, the compression ability appears to be even higher. Note that, due to the high compression of this data set, we plotted the quality curve of the Respiration data at a smaller ICR range, in order to distinguish the curves. However, by having a closer look at the signal, the high compression results out of an over quantization of the signal when converting it to 8 bit because of the signal peak, which can be seen in <xref ref-type="fig" rid="sensors-18-01672-f003">Figure 3</xref>, representing the respiration of the person while waking up. The over quantization leads to a signal mostly consisting of perfect straight parts, which can be seen in <xref ref-type="fig" rid="sensors-18-01672-f005">Figure 5</xref>. Thus, the possible compression rate for this data set is much higher. Since for the Respiration data set a significant compression is possible, the bound on the possible achievable compression of SW due to its maximum buffer size can be observed in <xref ref-type="fig" rid="sensors-18-01672-f004">Figure 4</xref>. For SW, the ICR is bounded to 0.01 as a minimum, as the maximum buffer size is set to 100, while CPLR allows for unbounded segment sizes and thus a higher compression or a lower ICR, respectively.</p><p>Note that the curves in <xref ref-type="fig" rid="sensors-18-01672-f004">Figure 4</xref> represent operating points of different integer threshold values starting from 1. Due to the nature of the error metrics implemented in the algorithms, the curves start at different operating points for a threshold of 1. By using floating point thresholds, the operating points below 1 could be reached as well, which are expected to follow the trend towards a lower error and a higher ICR as well. However, this is not further investigated in our experiments, as the operating points of interest with lower ICRs can already be seen in the conducted experiments. Furthermore, we did not include <inline-formula><mml:math id="mm178"><mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>H</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula> in <xref ref-type="fig" rid="sensors-18-01672-f004">Figure 4</xref>, as it might cause misleading assumptions. In fact, CPLR as well as SW will recreate the original signal at <inline-formula><mml:math id="mm179"><mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>H</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula>, while compressing perfect straight parts of the signal that can be approximated by a segment without any approximation error. However, the emSWAB implementation from [<xref rid="B5-sensors-18-01672" ref-type="bibr">5</xref>] does not behave in the same way and does not compress the signal at <inline-formula><mml:math id="mm180"><mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>H</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula>. This is basically caused by the implementation of emSWAB, which merges segments when the residual error is below <inline-formula><mml:math id="mm181"><mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>H</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> instead below or equal <inline-formula><mml:math id="mm182"><mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>H</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>, which is too conservative. However, an emSWAB implementation with the same behavior as our CPLR and SW implementations is possible, but was not available for our studies. Furthermore, the ICR at <inline-formula><mml:math id="mm183"><mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>H</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula> is approx. 32% with CPLR and SW for the <italic>Respiration</italic> data set shown in <xref ref-type="fig" rid="sensors-18-01672-f003">Figure 3</xref>. This is caused by the coarse quantization of the signal. In activity recognition scenarios with MEMS (Micro-Electro-Mechanical Systems) accelerometers and gyroscopes, the signals typically use 16 bit fixed-point data or floating point data and include significant noise on the least significant bits. In such cases, we do not expect a significant compression at <inline-formula><mml:math id="mm184"><mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>H</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula>, and thus excluded <inline-formula><mml:math id="mm185"><mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>H</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula> from our evaluation in <xref ref-type="fig" rid="sensors-18-01672-f004">Figure 4</xref>.</p><p>In this experiment, we compared the approximation quality of our CPLR algorithm with SW and emSWAB. In general, our evaluation shows no significant differences in the approximation quality of the chosen algorithms, except the ability of CPLR to create much longer segments and the approximation of the shuttle dataset, for which emSWAB slightly sacrifices in its approximation quality. Thus, we can show, that although CPLR is calculated in a time and memory efficient manner, its approximation quality is not compromised by this.</p></sec><sec id="sec5dot3-sensors-18-01672"><title>5.3. Execution Time</title><p>As a first evaluation of the execution time behavior on the introduced data sets in <xref ref-type="sec" rid="sec5dot1-sensors-18-01672">Section 5.1</xref>, we used the x86-64 platform, as it allows a feasible evaluation of this amount of data. We decided to use an emulative approach based on the Valgrind framework [<xref rid="B16-sensors-18-01672" ref-type="bibr">16</xref>]. We did not include the simulation of caching effects, although our algorithm would draw profit from it, as all calculation data will fit in first level caches. We evaluated the binaries compiled with GNU C (GCC) compiler version of 7.3.0 [<xref rid="B17-sensors-18-01672" ref-type="bibr">17</xref>] with default configuration on an x86-64 system. As an evaluation metric, we use the measured instruction count spent in the function, which is called for every new sample of an input data series. By using the instruction count, architectural effects on the timing behavior like pipelining, branch prediction, caching, out of order execution, and the processor frequency are avoided.</p><p>For these experiments, we created Callgraphs with the tool Callgrind [<xref rid="B18-sensors-18-01672" ref-type="bibr">18</xref>] to evaluate CPLR, SW, and emSWAB over all 29 data sets using the same buffer sizes as in <xref ref-type="sec" rid="sec5dot2-sensors-18-01672">Section 5.2</xref>, i.e., 100 for SW and 50 for emSWAB and a threshold of 100. The minimum, maximum, and average instruction count per algorithm invocation as well as the standard deviation and the number of invocations can be seen in <xref rid="sensors-18-01672-t001" ref-type="table">Table 1</xref>. The latter column only differs in the row emSWAB, as emSWAB handles the initialization of the PLA within the same function used for approximation while CPLR and SW are implemented with a separate initialization for the very first sample, for which they are not called in each data set.</p><p>By this experiment, we can show that our CPLR algorithm has a maximum instruction count of 150. The best case is 94 instructions, which need to be executed when no segment is outputted. Note that the average instruction counts for our algorithm depends on the actual signals, as the number or length of segments respectively is decisive for the fraction and is bounded on 150 instructions in case no compression is achieved and a segment is created for each sensor sample. The execution time behavior of CPLR can be seen in <xref ref-type="fig" rid="sensors-18-01672-f006">Figure 6</xref>. This shows the worst-case execution time characteristic of the CPLR algorithm.</p><p>For SW, we observe that the instruction count of each invocation grows by approximately 51 instructions for each new sample that is added to a segment. Thus, the execution time of SW linearly increases with the current segment&#x02019;s length. In the case, that a segment is created due to an exceeding threshold, 26 instructions are needed additionally to the error calculation. If a segment is created due to a maximum segment size, only 46 instructions have to be performed, because the error calculation can be skipped. Therefore, the maximum and average instruction count depends on the maximum segment&#x02019;s length and can be bounded by bounding the buffer size. In <xref ref-type="fig" rid="sensors-18-01672-f007">Figure 7</xref> the execution time dependency of SW on the segment&#x02019;s length is shown.</p><p>For emSWAB, the error calculation does not happen in each invocation and mostly the new sample is simply added to the buffer. This is the best case for emSWAB with 53 instructions. The segmentation within the buffer starts when the slope sign of the signal changes, and is not necessarily correlated to segment points. In this case, the execution time drastically increases, as multiple segments within the buffer are created and merged until none of them can be merged any further due to an exceeding error threshold. Within this process, the segment error calculation similar as in SW (iterating over all samples covered by that segment) is performed but repeatedly for multiple created and merged segments. Thus, the execution time is highly data and buffer size dependent and is two orders of magnitude higher than CPLR in this experiment. The execution time behavior of emSWAB is shown in <xref ref-type="fig" rid="sensors-18-01672-f008">Figure 8</xref>.</p><p>From this experiment, it can be seen that our CPLR algorithm not only has the minimum average computation time, but also a minimal guaranteed maximum execution time of 150 instructions on the x86-64 architecture without compromising its compression abilities.</p><p>In order to be able to perform this experiment on a large amount and variety of signals, we used the same threshold for all algorithms on all data sets. However, this is not a fair comparison, as the algorithms might lead to different segment lengths for the same thresholds, which influences the timing behavior of SW and emSWAB. Furthermore, among different data sets, the resulting compression ratios can differ as well as the same threshold. Therefore, we performed a second experiment on one of the data sets (i.e., the <inline-formula><mml:math id="mm186"><mml:mrow><mml:mrow><mml:mi>E</mml:mi><mml:mi>C</mml:mi><mml:mi>G</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> signal from <xref ref-type="fig" rid="sensors-18-01672-f003">Figure 3</xref>) and chose the thresholds for CPLR, SW, and emSWAB leading to approximately the same compression ratio. This was done by examining the results of the in total 210,000 invocations at different thresholds on the corresponding <inline-formula><mml:math id="mm187"><mml:mrow><mml:mrow><mml:mi>E</mml:mi><mml:mi>C</mml:mi><mml:mi>G</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> data set from the quality evaluation in <xref ref-type="sec" rid="sec5dot2-sensors-18-01672">Section 5.2</xref> and picking those thresholds for CPLR, SW, and emSWAB, which just achieved an inverse compression ratio of at least 0.2. The chosen thresholds, the corresponding compression ratios and the instruction counts observed in this experiment are shown in <xref rid="sensors-18-01672-t002" ref-type="table">Table 2</xref>.</p><p>It can be seen that the maximum instruction count for emSWAB and SW decreased w.r.t the results in <xref rid="sensors-18-01672-t001" ref-type="table">Table 1</xref>, as the lower thresholds lead to shorter segments and thus lower execution times. The average instruction count for CPLR has slightly increased, as at a lower threshold smaller and thus more segments are created. As the segment creation needs additional instructions, the average instruction count slightly increased. The maximum instruction count of 150 for CPLR does not appear in this data set. This only happens due to the truncation to 8 bit, if the approximated segment point is above 255 or below 0, which needs two instructions. Thus, the maximum instruction count of 148 in this second experiment is less than in <xref rid="sensors-18-01672-t001" ref-type="table">Table 1</xref>. Furthermore, it can be seen that the average instruction count for emSWAB increased, although the maximum instruction count decreased. This is explained by the fact of a smaller threshold leading to smaller segments, and thus the computationally costly segmentation process within the buffer is faster but performed more frequently. For SW, the minimum instruction count is 57 in this experiment. This is caused by the fact that the lower threshold leads to shorter segments and no segment is created due to an exceeding maximum segment size, which needs 46 instructions. Despite the latter, an instruction count of 57 is the shortest execution time of SW, which happens when only the first sample is added to a newly created segment. This small execution time is only achieved at the very first invocation of the SW algorithm after initialization. In all other invocations, the first sample is already added to the buffer upon segment creation, since a new segment&#x02019;s end point is always created for the previous sample.</p><sec id="sec5dot3dot1-sensors-18-01672"><title>ARM Cortex-M4 Microcontroller Architecture</title><p>On the x86-64, we were able to show the execution times of CPLR, SW, and emSWAB on a large amount and variety of data. However, as the target architectures of our algorithm are embedded microcontrollers, we additionally analyzed the instruction count on an ARM Cortex-M4 microcontroller. Due to the lack of an appropriate hardware setup on which high amounts of data can be approximated while acquiring the execution time of each invocation in an automated manner, we performed a static code analysis on the assembler code. We compiled emSWAB, SW and our CPLR algorithm for the ARM Cortex-M4 microcontroller architecture using the Arm Embedded GCC version 7.3.0 of the GNU Arm Embedded Toolchain. As compiler settings, we used Cortex-M4 as the target platform with its included hardware floating point unit. From the produced assembler code, we extracted the control flow graphs with corresponding instruction counts of each basis block. For SW and our CPLR algorithm, the simplistic control flow allows for easily analyzing the worst-case instruction count and its data dependency.</p><p>The best- and worst-case instruction counts per invocation for CPLR are 131 and 203 instructions, respectively. For SW, the best case is 59 instructions when a segment is created due to an maximum segment length. The data dependent worst case is <inline-formula><mml:math id="mm188"><mml:mrow><mml:mrow><mml:mn>106</mml:mn><mml:mo>+</mml:mo><mml:mi>n</mml:mi><mml:mo>&#x000b7;</mml:mo><mml:mn>56</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula> instructions with <italic>n</italic> being the segment size. For a maximum buffer size of 100 samples as used in the experiments on the x86-64 architecture (see <xref rid="sensors-18-01672-t001" ref-type="table">Table 1</xref>), the maximum <italic>n</italic> is 100 and the worst-case instruction count of SW would be 5706 instructions on the ARM Cortex-M4 microcontroller. For emSWAB, we were able to analyze the shortest path consisting of 64 instructions, in which only a new sample is added to the buffer. However, when the segmentation process within the buffer is performed, the control flow consists of several nested function calls and nested loops, which makes a manual analysis infeasible. This data dependent behavior aligns with the timing behavior observed on the x86-64 architecture in our experiments (see <xref ref-type="fig" rid="sensors-18-01672-f008">Figure 8</xref>) and is not further investigated in this paper. The minimal and maximal instruction counts of CPLR, SW, and emSWAB on the ARM Cortex-M4 architecture are summarized in <xref rid="sensors-18-01672-t003" ref-type="table">Table 3</xref>.</p></sec></sec></sec><sec id="sec6-sensors-18-01672"><title>6. Discussion</title><p>Our evaluation in <xref ref-type="sec" rid="sec5-sensors-18-01672">Section 5</xref> shows that our CPLR algorithm achieves comparable approximation quality while having a low computational overhead compared to the state-of-the-art solutions. In the following, we want to discuss some basic properties of CPLR.</p><sec id="sec6dot1-sensors-18-01672"><title>6.1. Numerical Precision</title><p>In general, the computations to update the mean <inline-formula><mml:math id="mm189"><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="mm190"><mml:mrow><mml:msub><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math id="mm191"><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> with the equations of [<xref rid="B13-sensors-18-01672" ref-type="bibr">13</xref>] are regarded as numerically stable. However, without a buffer, our CPLR algorithm does not constrain the length of a segment by a maximum buffer size like all other existing solutions. As this is a desired property for compressing long parts of a signal with no significant signal change, numerical precision has to be considered for such cases. In <xref ref-type="sec" rid="sec3-sensors-18-01672">Section 3</xref>, we mentioned the rearrangement of Equation (<xref ref-type="disp-formula" rid="FD10-sensors-18-01672">10</xref>) for updating the means from [<xref rid="B13-sensors-18-01672" ref-type="bibr">13</xref>] to Equation (<xref ref-type="disp-formula" rid="FD11-sensors-18-01672">11</xref>), in order to save a multiplication and a division, by slightly sacrificing numerical precision. As we can see, both equations&#x02019; right sides can get very small with long segments. Given the sensor values themselves are not next to zero, the right side of Equation (<xref ref-type="disp-formula" rid="FD11-sensors-18-01672">11</xref>) possibly gets smaller than the right part of Equation (<xref ref-type="disp-formula" rid="FD10-sensors-18-01672">10</xref>) for signals without significant changes, as the new sample and the previous mean are typically very similar values. This results in a small difference divided by a possibly large segment size compared to a sample itself divided by the large segment size. However, for both versions, the numerical precision of the used data types have to be considered for the targeted application and the expected segment length. If longer segments are required, Equation (<xref ref-type="disp-formula" rid="FD10-sensors-18-01672">10</xref>) could allow for longer segments depending on the sensors range and expected values, regarding the numerical precision, by trading a bit of processing time. However, in any way, the precision of the data types and threshold value should be chosen according to the desired application.</p><p>Another way of avoiding this problem can be achieved by implementing a maximum segment size, which can be chosen according to the available precision of data types. By doing so, a new segment could be produced when either the error value exceeds the threshold or the segment length exceeds the maximum segment size. Note that this variation of the algorithm still does not require a buffer for all sensor samples within a segment.</p></sec><sec id="sec6dot2-sensors-18-01672"><title>6.2. Computational and Memory Complexities</title><p>The computation time of our CPLR algorithm for updating the slope and the error of the current segment for each new data point is independent of the length of the current segment and its computational complexity for each new data point is <inline-formula><mml:math id="mm192"><mml:mrow><mml:mrow><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> with respect to the segment length. As shown in <xref ref-type="sec" rid="sec5dot3-sensors-18-01672">Section 5.3</xref>, the processing for each new sample is limited to 203 instructions on an ARM Cortex-M4 microcontroller.</p><p>Furthermore, our algorithm has a memory complexity of <inline-formula><mml:math id="mm193"><mml:mrow><mml:mrow><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, since it comes without a buffer. The variables <italic>n</italic>, <inline-formula><mml:math id="mm194"><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="mm195"><mml:mrow><mml:msub><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="mm196"><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math id="mm197"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> need to be stored globally. Together with <inline-formula><mml:math id="mm198"><mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>H</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> and the array of segments <inline-formula><mml:math id="mm199"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula>, which need to store two segmentation points, each consisting of a value and a timestamp (four variables in total), 10 variables have to be stored globally. The algorithm additionally needs 10 local variables for the means <inline-formula><mml:math id="mm200"><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="mm201"><mml:mrow><mml:msub><mml:mover><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math id="mm202"><mml:mrow><mml:msub><mml:mover><mml:msup><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, the current slope <inline-formula><mml:math id="mm203"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, the current segment error <inline-formula><mml:math id="mm204"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, the new sample&#x02019;s value <italic>y</italic> originating in the previous segment point, the new segments point&#x02019;s value <inline-formula><mml:math id="mm205"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, and its corresponding timestamp <italic>t</italic>. Note that <inline-formula><mml:math id="mm206"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> and <italic>t</italic> do not necessarily need to be stored in extra variables, but can directly be written to the segments array (line 29). We left them in Algorithm 1 for the sake of readability. Additionally, the new sample value <italic>s</italic>, a pointer to the globally stored segments array <inline-formula><mml:math id="mm207"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula>, and the index <italic>k</italic> for indicating the position in <inline-formula><mml:math id="mm208"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo stretchy="false">&#x002dc;</mml:mo></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> for the next segment point are passed as arguments, which makes three additional variables be used. In total, CPLR needs 23 variables. If all integer values are assumed to be 32 bit integers and all floating point numbers are assumed to be single precision floating point types, the data memory consumption is 92 bytes in total, independent of the parameters.</p><p>Both aforementioned properties make it possible to implement CPLR on architectures with harsh resource constraints regarding memory and computation time. Moreover, it does not need a maximum buffer size to be specified compared to all other state-of-the-art segmentation algorithms. This reduces the parameter space to be explored for an application specific configuration, i.e., finding an optimal threshold value.</p></sec><sec id="sec6dot3-sensors-18-01672"><title>6.3. Latency</title><p>In real-time applications collecting sensors data online, latency is a crucial property as it directly influences the responsiveness of the system. For online PLA algorithms, this means that a segment approximating a set of sensor samples needs to be output as soon as possible after the corresponding last sensor sample of that segment was sampled. As in emSWAB, only the leftmost segment within the buffer is output, the latency of emSWAB is depending on the buffer size and can result in several sampling periods plus the processing time, which depends on the buffer size as well. For SW, the latency is a single sampling period, as the new sensor sample is decisive for creating a segment up to the previous sample or whether the new sample will be included, plus the processing time of the last sample, which depends on the segment&#x02019;s length. Our algorithm basically has the same latency behavior as for SW, which is one sample period, but with a constant processing time of the last sample, which involves 203 instructions on an ARM Cortex-M4 microcontroller. Thus, CPLR not only provides a data independent worst-case execution time, but also a small worst-case latency.</p></sec></sec><sec id="sec7-sensors-18-01672"><title>7. Conclusions</title><p>In the paper at hand, we introduced our new CPLR algorithm that supports efficient online piecewise linear approximations of sensor signals with connected segments. In our experiments, we could show that our algorithm can compete with existing state-of-the-art PLA techniques regarding approximation quality. Furthermore, to the best of our knowledge, our CPLR algorithm is the only existing algorithm that provides both a small worst-case execution time with a computational complexity of <inline-formula><mml:math id="mm209"><mml:mrow><mml:mrow><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and a memory complexity of <inline-formula><mml:math id="mm210"><mml:mrow><mml:mrow><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> leading to the need of only a few variables. These advantages mainly result from the absence of a buffer to store sensor samples.</p><p>Finally, due to a short and predictable latency, as well as the deterministic per sample processing times and memory usage, our algorithm satisfies all necessary requirements for performing online piecewise linear approximation on embedded processing units with harsh processing and memory constraints.</p></sec></body><back><ack><title>Acknowledgments</title><p>We would like to thank Eugen Berlin and Kristof Van Laerhoven for providing the source code and supplementary material of their algorithms emSWAB and mSWAB from [<xref rid="B4-sensors-18-01672" ref-type="bibr">4</xref>,<xref rid="B5-sensors-18-01672" ref-type="bibr">5</xref>], respectively, and the authors of [<xref rid="B11-sensors-18-01672" ref-type="bibr">11</xref>] for providing help in clarifying the memory complexity of their algorithm. Lastly, we want to thank Bosch Sensortec GmbH Reutlingen, Germany for providing the sensor hardware and its support for collecting sensor data.</p></ack><notes><title>Author Contributions</title><p>F.G. conceived and designed the CPLR algorithm; F.G., B.B., A.H., T.K. and C.H. conceived and designed the experiments and F.G. and A.H. performed the experiments for collecting the data sets; F.G. and B.B. conceived and designed the experiments for evaluating the algorithms; F.G. performed the experiments for evaluating the algorithms; F.G. and B.B. analyzed the data and discussed the algorithm properties; F.G., B.B., and C.H. wrote the paper. All authors critically reviewed the manuscript and approved the final version.</p></notes><notes><title>Funding</title><p>This work is partially supported by the German Federal Ministry of Education and Research (BMBF), Grant No. 03ZZ0519D. We acknowledge financial support by Deutsche Forschungsgemeinschaft and Universit&#x000e4;t Rostock/Universit&#x000e4;tsmedizin Rostock within the funding program Open Access Publishing.</p></notes><notes notes-type="COI-statement"><title>Conflicts of Interest</title><p>The authors declare no conflict of interest. The founding sponsors had no role in the design of the study; in the collection, analyses, or interpretation of data; in the writing of the manuscript, and in the decision to publish the results.</p></notes><glossary><title>Abbreviations</title><p>The following abbreviations are used in this manuscript:
<array orientation="portrait"><tbody><tr><td align="left" valign="middle" rowspan="1" colspan="1">WSN</td><td align="left" valign="middle" rowspan="1" colspan="1">Wireless Sensor Networks</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">PLA</td><td align="left" valign="middle" rowspan="1" colspan="1">Piecewise Linear Approximation</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">SWAB</td><td align="left" valign="middle" rowspan="1" colspan="1">Sliding Window and Bottom Up</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">SW</td><td align="left" valign="middle" rowspan="1" colspan="1">Sliding Window</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">SSR</td><td align="left" valign="middle" rowspan="1" colspan="1">Sum of Squared Residuals</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">OLS</td><td align="left" valign="middle" rowspan="1" colspan="1">Ordinary Least Squares</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">ICR</td><td align="left" valign="middle" rowspan="1" colspan="1">Inverse Compression Ratio</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">CPLR</td><td align="left" valign="middle" rowspan="1" colspan="1">Connected Piecewise Linear Regression</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">ECG</td><td align="left" valign="middle" rowspan="1" colspan="1">Electrocardiography</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">MEMS</td><td align="left" valign="middle" rowspan="1" colspan="1">Micro-Electro-Mechanical Systems</td></tr></tbody></array></p></glossary><ref-list><title>References</title><ref id="B1-sensors-18-01672"><label>1.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Keogh</surname><given-names>E.</given-names></name><name><surname>Chu</surname><given-names>S.</given-names></name><name><surname>Hart</surname><given-names>D.</given-names></name><name><surname>Pazzani</surname><given-names>M.</given-names></name></person-group><article-title>An online algorithm for segmenting time series</article-title><source>Proceedings of the IEEE International Conference on Data Mining, ICDM 2001</source><conf-loc>San Jose, CA, USA</conf-loc><conf-date>29 November&#x02013;2 December 2001</conf-date><publisher-name>IEEE</publisher-name><publisher-loc>Piscataway, NJ, USA</publisher-loc><year>2001</year><fpage>289</fpage><lpage>296</lpage></element-citation></ref><ref id="B2-sensors-18-01672"><label>2.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Liu</surname><given-names>C.</given-names></name><name><surname>Wu</surname><given-names>K.</given-names></name><name><surname>Pei</surname><given-names>J.</given-names></name></person-group><article-title>An energy-efficient data collection framework for wireless sensor networks by exploiting spatiotemporal correlation</article-title><source>IEEE Trans. Parallel Distrib. Syst.</source><year>2007</year><volume>18</volume><fpage>1010</fpage><lpage>1023</lpage><pub-id pub-id-type="doi">10.1109/TPDS.2007.1046</pub-id></element-citation></ref><ref id="B3-sensors-18-01672"><label>3.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Pham</surname><given-names>N.D.</given-names></name><name><surname>Le</surname><given-names>T.D.</given-names></name><name><surname>Choo</surname><given-names>H.</given-names></name></person-group><article-title>Enhance exploring temporal correlation for data collection in WSNs</article-title><source>Proceedings of the IEEE International Conference on Research, Innovation and Vision for the Future, RIVF 2008</source><conf-loc>Ho Chi Minh City, Vietnam</conf-loc><conf-date>13&#x02013;17 July 2008</conf-date><publisher-name>IEEE</publisher-name><publisher-loc>Piscataway, NJ, USA</publisher-loc><year>2008</year><fpage>204</fpage><lpage>208</lpage></element-citation></ref><ref id="B4-sensors-18-01672"><label>4.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Van Laerhoven</surname><given-names>K.</given-names></name><name><surname>Berlin</surname><given-names>E.</given-names></name><name><surname>Schiele</surname><given-names>B.</given-names></name></person-group><article-title>Enabling efficient time series analysis for wearable activity data</article-title><source>Proceedings of the International Conference on Machine Learning and Applications, ICMLA&#x02019;09</source><conf-loc>Miami Beach, FL, USA</conf-loc><conf-date>13&#x02013;15 December 2009</conf-date><publisher-name>IEEE</publisher-name><publisher-loc>Piscataway, NJ, USA</publisher-loc><year>2009</year><fpage>392</fpage><lpage>397</lpage></element-citation></ref><ref id="B5-sensors-18-01672"><label>5.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Berlin</surname><given-names>E.</given-names></name><name><surname>Van Laerhoven</surname><given-names>K.</given-names></name></person-group><article-title>An on-line piecewise linear approximation technique for wireless sensor networks</article-title><source>Proceedings of the 2010 IEEE 35th Conference on Local Computer Networks (LCN)</source><conf-loc>Denver, CO, USA</conf-loc><conf-date>10&#x02013;14 October 2010</conf-date><publisher-name>IEEE</publisher-name><publisher-loc>Piscataway, NJ, USA</publisher-loc><year>2010</year><fpage>905</fpage><lpage>912</lpage></element-citation></ref><ref id="B6-sensors-18-01672"><label>6.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Berlin</surname><given-names>E.</given-names></name><name><surname>Van Laerhoven</surname><given-names>K.</given-names></name></person-group><article-title>Detecting leisure activities with dense motif discovery</article-title><source>Proceedings of the 2012 ACM Conference on Ubiquitous Computing</source><conf-loc>Pittsburgh, PA, USA</conf-loc><conf-date>5&#x02013;8 September 2012</conf-date><publisher-name>ACM</publisher-name><publisher-loc>New York, NY, USA</publisher-loc><year>2012</year><fpage>250</fpage><lpage>259</lpage></element-citation></ref><ref id="B7-sensors-18-01672"><label>7.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Junker</surname><given-names>H.</given-names></name><name><surname>Amft</surname><given-names>O.</given-names></name><name><surname>Lukowicz</surname><given-names>P.</given-names></name><name><surname>Tr&#x000f6;ster</surname><given-names>G.</given-names></name></person-group><article-title>Gesture spotting with body-worn inertial sensors to detect user activities</article-title><source>Pattern Recognit.</source><year>2008</year><volume>41</volume><fpage>2010</fpage><lpage>2024</lpage><pub-id pub-id-type="doi">10.1016/j.patcog.2007.11.016</pub-id></element-citation></ref><ref id="B8-sensors-18-01672"><label>8.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Gr&#x000fc;tzmacher</surname><given-names>F.</given-names></name><name><surname>Wolff</surname><given-names>J.P.</given-names></name><name><surname>Hein</surname><given-names>A.</given-names></name><name><surname>Lepidis</surname><given-names>P.</given-names></name><name><surname>Dorsch</surname><given-names>R.</given-names></name><name><surname>Kirste</surname><given-names>T.</given-names></name><name><surname>Haubelt</surname><given-names>C.</given-names></name></person-group><article-title>Towards energy efficient sensor nodes for online activity recognition</article-title><source>Proceedings of the IECON 2017-43rd Annual Conference of the IEEE Industrial Electronics Society</source><conf-loc>Beijing, China</conf-loc><conf-date>29 October&#x02013;1 November 2017</conf-date><publisher-name>IEEE</publisher-name><publisher-loc>Piscataway, NJ, USA</publisher-loc><year>2017</year><fpage>8291</fpage><lpage>8296</lpage></element-citation></ref><ref id="B9-sensors-18-01672"><label>9.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Van Laerhoven</surname><given-names>K.</given-names></name><name><surname>Aronsen</surname><given-names>A.K.</given-names></name></person-group><article-title>Memorizing what you did last week: Towards detailed actigraphy with a wearable sensor</article-title><source>Proceedings of the 27th International Conference on Distributed Computing Systems Workshops, ICDCSW&#x02019;07</source><conf-loc>Toronto, ON, Canada</conf-loc><conf-date>22&#x02013;29 June 2007</conf-date><publisher-name>IEEE</publisher-name><publisher-loc>Piscataway, NJ, USA</publisher-loc><year>2007</year><fpage>47</fpage></element-citation></ref><ref id="B10-sensors-18-01672"><label>10.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Lemire</surname><given-names>D.</given-names></name></person-group><article-title>A better alternative to piecewise linear time series segmentation</article-title><source>Proceedings of the 2007 SIAM International Conference on Data Mining</source><conf-loc>Minneapolis, MN, USA</conf-loc><conf-date>26&#x02013;28 April 2007</conf-date><fpage>545</fpage><lpage>550</lpage></element-citation></ref><ref id="B11-sensors-18-01672"><label>11.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Fuchs</surname><given-names>E.</given-names></name><name><surname>Gruber</surname><given-names>T.</given-names></name><name><surname>Nitschke</surname><given-names>J.</given-names></name><name><surname>Sick</surname><given-names>B.</given-names></name></person-group><article-title>Online segmentation of time series based on polynomial least-squares approximations</article-title><source>IEEE Trans. Pattern Anal. Mach. Intell.</source><year>2010</year><volume>32</volume><fpage>2232</fpage><lpage>2245</lpage><pub-id pub-id-type="doi">10.1109/TPAMI.2010.44</pub-id><pub-id pub-id-type="pmid">20975120</pub-id></element-citation></ref><ref id="B12-sensors-18-01672"><label>12.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Luo</surname><given-names>G.</given-names></name><name><surname>Yi</surname><given-names>K.</given-names></name><name><surname>Cheng</surname><given-names>S.W.</given-names></name><name><surname>Li</surname><given-names>Z.</given-names></name><name><surname>Fan</surname><given-names>W.</given-names></name><name><surname>He</surname><given-names>C.</given-names></name><name><surname>Mu</surname><given-names>Y.</given-names></name></person-group><article-title>Piecewise linear approximation of streaming time series data with max-error guarantees</article-title><source>Proceedings of the 2015 IEEE 31st International Conference on Data Engineering (ICDE)</source><conf-loc>Seoul, Korea</conf-loc><conf-date>13&#x02013;17 April 2015</conf-date><publisher-name>IEEE</publisher-name><publisher-loc>Piscataway, NJ, USA</publisher-loc><year>2015</year><fpage>173</fpage><lpage>184</lpage></element-citation></ref><ref id="B13-sensors-18-01672"><label>13.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Welford</surname><given-names>B.</given-names></name></person-group><article-title>Note on a method for calculating corrected sums of squares and products</article-title><source>Technometrics</source><year>1962</year><volume>4</volume><fpage>419</fpage><lpage>420</lpage><pub-id pub-id-type="doi">10.1080/00401706.1962.10490022</pub-id></element-citation></ref><ref id="B14-sensors-18-01672"><label>14.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Keogh</surname><given-names>E.</given-names></name><name><surname>Lin</surname><given-names>J.</given-names></name><name><surname>Fu</surname><given-names>A.</given-names></name></person-group><article-title>HOT SAX: Finding the most unusual time series subsequence: Algorithms and applications</article-title><source>Proceedings of the ICDM</source><conf-loc>Brighton, UK</conf-loc><conf-date>1&#x02013;4 November 2004</conf-date><fpage>440</fpage><lpage>449</lpage></element-citation></ref><ref id="B15-sensors-18-01672"><label>15.</label><element-citation publication-type="web"><person-group person-group-type="author"><name><surname>Keogh</surname><given-names>E.</given-names></name><name><surname>Lin</surname><given-names>J.</given-names></name><name><surname>Fu</surname><given-names>A.</given-names></name></person-group><article-title>HOT SAX: Efficiently Finding the Most Unusual Time Series Subsequence</article-title><comment>Available online: <ext-link ext-link-type="uri" xlink:href="http://www.cs.ucr.edu/~eamonn/discords/">http://www.cs.ucr.edu/~eamonn/discords/</ext-link></comment><date-in-citation content-type="access-date" iso-8601-date="2018-05-23">(accessed on 23 May 2018)</date-in-citation></element-citation></ref><ref id="B16-sensors-18-01672"><label>16.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Nethercote</surname><given-names>N.</given-names></name><name><surname>Seward</surname><given-names>J.</given-names></name></person-group><article-title>Valgrind: A framework for heavyweight dynamic binary instrumentation</article-title><source>Proceedings of the ACM Sigplan Notices</source><conf-loc>San Diego, CA, USA</conf-loc><conf-date>10&#x02013;13 June 2007</conf-date><publisher-name>ACM</publisher-name><publisher-loc>New York, NY, USA</publisher-loc><year>2007</year><volume>Volume 42</volume><fpage>89</fpage><lpage>100</lpage></element-citation></ref><ref id="B17-sensors-18-01672"><label>17.</label><element-citation publication-type="web"><article-title>The Free Software Foundation, the GNU Compiler Collection</article-title><comment>Available online: <ext-link ext-link-type="uri" xlink:href="http://gcc.gnu.org">http://gcc.gnu.org</ext-link></comment><date-in-citation content-type="access-date" iso-8601-date="2018-05-23">(accessed on 23 May 2018)</date-in-citation></element-citation></ref><ref id="B18-sensors-18-01672"><label>18.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Weidendorfer</surname><given-names>J.</given-names></name><name><surname>Kowarschik</surname><given-names>M.</given-names></name><name><surname>Trinitis</surname><given-names>C.</given-names></name></person-group><article-title>A tool suite for simulation based analysis of memory access behavior</article-title><source>Proceedings of the International Conference on Computational Science</source><conf-loc>Krak&#x000f3;w, Poland</conf-loc><conf-date>6&#x02013;9 June 2004</conf-date><fpage>440</fpage><lpage>447</lpage></element-citation></ref></ref-list></back><floats-group><fig id="sensors-18-01672-f001" orientation="portrait" position="float"><label>Figure 1</label><caption><p>Part of ECG signal from <xref ref-type="sec" rid="sec5dot1-sensors-18-01672">Section 5.1</xref> approximated with our Connected Piecewise Linear Regression (CPLR) algorithm.</p></caption><graphic xlink:href="sensors-18-01672-g001"/></fig><fig id="sensors-18-01672-f002" orientation="portrait" position="float"><label>Figure 2</label><caption><p>Growing sum of squared residuals error per sample.</p></caption><graphic xlink:href="sensors-18-01672-g002"/></fig><fig id="sensors-18-01672-f003" orientation="portrait" position="float"><label>Figure 3</label><caption><p>Partially plotted data sets for evaluation.</p></caption><graphic xlink:href="sensors-18-01672-g003"/></fig><fig id="sensors-18-01672-f004" orientation="portrait" position="float"><label>Figure 4</label><caption><p>Evaluation of different data sets.</p></caption><graphic xlink:href="sensors-18-01672-g004"/></fig><fig id="sensors-18-01672-f005" orientation="portrait" position="float"><label>Figure 5</label><caption><p>Over quantization of partially plotted Respiration signal.</p></caption><graphic xlink:href="sensors-18-01672-g005"/></fig><fig id="sensors-18-01672-f006" orientation="portrait" position="float"><label>Figure 6</label><caption><p>Execution time of CPLR with <inline-formula><mml:math id="mm211"><mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>H</mml:mi><mml:mo>=</mml:mo><mml:mn>100</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula>.</p></caption><graphic xlink:href="sensors-18-01672-g006"/></fig><fig id="sensors-18-01672-f007" orientation="portrait" position="float"><label>Figure 7</label><caption><p>Execution time of SW with <inline-formula><mml:math id="mm212"><mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>H</mml:mi><mml:mo>=</mml:mo><mml:mn>100</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula>.</p></caption><graphic xlink:href="sensors-18-01672-g007"/></fig><fig id="sensors-18-01672-f008" orientation="portrait" position="float"><label>Figure 8</label><caption><p>Execution time of emSWAB with <inline-formula><mml:math id="mm213"><mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>H</mml:mi><mml:mo>=</mml:mo><mml:mn>100</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula>.</p></caption><graphic xlink:href="sensors-18-01672-g008"/></fig><table-wrap id="sensors-18-01672-t001" orientation="portrait" position="float"><object-id pub-id-type="pii">sensors-18-01672-t001_Table 1</object-id><label>Table 1</label><caption><p>Instruction counts of CPLR, SW, and emSWAB at <inline-formula><mml:math id="mm214"><mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>H</mml:mi><mml:mo>=</mml:mo><mml:mn>100</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula> and a buffer size of 100 on an x86-64 architecture.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">Algorithm</th><th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">Min. Instr. Count</th><th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">Max. Instr. Count</th><th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">Avg. Instr. Count</th><th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">Std. Dev.</th><th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">#Invocations</th></tr></thead><tbody><tr><td align="center" valign="middle" rowspan="1" colspan="1">CPLR</td><td align="center" valign="middle" rowspan="1" colspan="1">94</td><td align="center" valign="middle" rowspan="1" colspan="1">150</td><td align="center" valign="middle" rowspan="1" colspan="1">99.18</td><td align="center" valign="middle" rowspan="1" colspan="1">15.90</td><td align="center" valign="middle" rowspan="1" colspan="1">536,146</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">SW</td><td align="center" valign="middle" rowspan="1" colspan="1">46</td><td align="center" valign="middle" rowspan="1" colspan="1">5106</td><td align="center" valign="middle" rowspan="1" colspan="1">935.20</td><td align="center" valign="middle" rowspan="1" colspan="1">1115.92</td><td align="center" valign="middle" rowspan="1" colspan="1">536,146</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">emSWAB</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">53</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">
<inline-formula><mml:math id="mm215"><mml:mrow><mml:mrow><mml:mn>812,807</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula>
</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">3423.60</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">26,628.49</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">536,175</td></tr></tbody></table></table-wrap><table-wrap id="sensors-18-01672-t002" orientation="portrait" position="float"><object-id pub-id-type="pii">sensors-18-01672-t002_Table 2</object-id><label>Table 2</label><caption><p>Instruction counts of CPLR, SW, and emSWAB on an x86-64 architecture at similar ICRs with a maximum buffer size of 100, evaluated on the <inline-formula><mml:math id="mm216"><mml:mrow><mml:mrow><mml:mi>E</mml:mi><mml:mi>C</mml:mi><mml:mi>G</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> data set from <xref ref-type="fig" rid="sensors-18-01672-f003">Figure 3</xref>.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">Algorithm</th><th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">TH</th><th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">ICR</th><th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">Min. Instr. Count</th><th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">Max. Instr. Count</th><th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">Avg. Instr. Count</th><th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">Std. Dev.</th><th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">#Invocations</th></tr></thead><tbody><tr><td align="center" valign="middle" rowspan="1" colspan="1">CPLR</td><td align="center" valign="middle" rowspan="1" colspan="1">8</td><td align="center" valign="middle" rowspan="1" colspan="1">0.1943</td><td align="center" valign="middle" rowspan="1" colspan="1">94</td><td align="center" valign="middle" rowspan="1" colspan="1">148</td><td align="center" valign="middle" rowspan="1" colspan="1">104.49</td><td align="center" valign="middle" rowspan="1" colspan="1">21.36</td><td align="center" valign="middle" rowspan="1" colspan="1">14,999</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">SW</td><td align="center" valign="middle" rowspan="1" colspan="1">10</td><td align="center" valign="middle" rowspan="1" colspan="1">0.1970</td><td align="center" valign="middle" rowspan="1" colspan="1">57</td><td align="center" valign="middle" rowspan="1" colspan="1">1154</td><td align="center" valign="middle" rowspan="1" colspan="1">306.74</td><td align="center" valign="middle" rowspan="1" colspan="1">180.26</td><td align="center" valign="middle" rowspan="1" colspan="1">14,999</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">emSWAB</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">8</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">0.1907</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">53</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">
<inline-formula><mml:math id="mm217"><mml:mrow><mml:mrow><mml:mn>181,506</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula>
</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">7092.56</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">17,055.25</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">15,000</td></tr></tbody></table></table-wrap><table-wrap id="sensors-18-01672-t003" orientation="portrait" position="float"><object-id pub-id-type="pii">sensors-18-01672-t003_Table 3</object-id><label>Table 3</label><caption><p>Instruction counts of CPLR, SW, and emSWAB on an ARM Cortex-M4 microcontroller with a maximum buffer size of 100 for SW and emSWAB.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">Algorithm</th><th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">Minimal Instruction Count</th><th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">Maximal Instruction Count</th></tr></thead><tbody><tr><td align="center" valign="middle" rowspan="1" colspan="1">CPLR</td><td align="center" valign="middle" rowspan="1" colspan="1">131</td><td align="center" valign="middle" rowspan="1" colspan="1">203</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">SW</td><td align="center" valign="middle" rowspan="1" colspan="1">59</td><td align="center" valign="middle" rowspan="1" colspan="1">
<inline-formula><mml:math id="mm218"><mml:mrow><mml:mrow><mml:mn>106</mml:mn><mml:mo>+</mml:mo><mml:mi>n</mml:mi><mml:mo>&#x000b7;</mml:mo><mml:mn>56</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula>
</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">emSWAB</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">64</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">manual analysis infeasible</td></tr></tbody></table></table-wrap></floats-group></article>