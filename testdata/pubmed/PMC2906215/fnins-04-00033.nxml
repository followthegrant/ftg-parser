<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.0 20120330//EN" "JATS-archivearticle1.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">Front Neurosci</journal-id><journal-id journal-id-type="publisher-id">Front. Neurosci.</journal-id><journal-title-group><journal-title>Frontiers in Neuroscience</journal-title></journal-title-group><issn pub-type="ppub">1662-4548</issn><issn pub-type="epub">1662-453X</issn><publisher><publisher-name>Frontiers Research Foundation</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">20661297</article-id><article-id pub-id-type="pmc">2906215</article-id><article-id pub-id-type="doi">10.3389/fnins.2010.00033</article-id><article-categories><subj-group subj-group-type="heading"><subject>Neuroscience</subject><subj-group><subject>Original Research</subject></subj-group></subj-group></article-categories><title-group><article-title>Natural Selection at Work: An Accelerated Evolutionary Computing Approach to Predictive Model Selection</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Akman</surname><given-names>Olcay</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref><xref ref-type="author-notes" rid="fn001">*</xref></contrib><contrib contrib-type="author"><name><surname>Hallam</surname><given-names>Joshua W.</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref></contrib></contrib-group><aff id="aff1"><sup>1</sup><institution>Department of Mathematics, Illinois State University</institution><country>Normal, IL, USA</country></aff><aff id="aff2"><sup>2</sup><institution>Department of Mathematics, Michigan State University</institution><country>Michigan, MI, USA</country></aff><author-notes><fn fn-type="edited-by"><p>Edited by: Leon Farhy, University of Virginia, USA</p></fn><fn fn-type="edited-by"><p>Reviewed by: Jason Jannot, Winthrop University, USA; Robert Bies, Indiana University&#x02013;Purdue University Indianapolis, USA</p></fn><corresp id="fn001">*Correspondence: Olcay Akman, Department of Mathematics, Illinois State University, Normal, IL 61790-4520, USA. e-mail: <email>oakman@ilstu.edu</email></corresp><fn fn-type="other" id="fn002"><p>This article was submitted to Frontiers in Systems Biology, a specialty of Frontiers in Neuroscience.</p></fn></author-notes><pub-date pub-type="epreprint"><day>05</day><month>5</month><year>2010</year></pub-date><pub-date pub-type="epub"><day>08</day><month>7</month><year>2010</year></pub-date><pub-date pub-type="collection"><year>2010</year></pub-date><volume>4</volume><elocation-id>33</elocation-id><history><date date-type="received"><day>03</day><month>4</month><year>2010</year></date><date date-type="accepted"><day>18</day><month>5</month><year>2010</year></date></history><permissions><copyright-statement>Copyright &#x000a9; 2010 Akman and Hallam.</copyright-statement><copyright-year>2010</copyright-year><license license-type="open-access" xlink:href="http://www.frontiersin.org/licenseagreement"><license-p>This is an open-access article subject to an exclusive license agreement between the authors and the Frontiers Research Foundation, which permits unrestricted use, distribution, and reproduction in any medium, provided the original authors and source are credited.</license-p></license></permissions><abstract><p>We implement genetic algorithm based predictive model building as an alternative to the traditional stepwise regression. We then employ the Information Complexity Measure (ICOMP) as a measure of model fitness instead of the commonly used measure of <italic>R</italic>-square. Furthermore, we propose some modifications to the genetic algorithm to increase the overall efficiency.</p></abstract><kwd-group><kwd>genetic algorithms</kwd><kwd>information complexity measure</kwd><kwd>stepwise regression</kwd><kwd>diversification</kwd><kwd>population reduction</kwd></kwd-group><counts><fig-count count="1"/><table-count count="3"/><equation-count count="9"/><ref-count count="12"/><page-count count="5"/><word-count count="4070"/></counts></article-meta></front><body><sec sec-type=""><title>Introduction</title><p>Variable selection in predictive model building is known to be a difficult procedure. The main difficulty lies in determining what variables best explain the system. For instance, exhaustive search becomes unreasonable as the number of variables increases; employing a multiple regression search produces over one billion possible models for data with 30 explanatory variables.</p><p>In ecological studies, one of the commonly used methods for selection is stepwise regression, with forward or backward variable selection algorithms. These methods have been criticized for lacking the ability to truly pick the best model for several reasons (Boyce et al., <xref ref-type="bibr" rid="B2">1974</xref>; Wilkinson, <xref ref-type="bibr" rid="B12">1989</xref>). One problem is that the choice by which the variables enter the selection algorithm is not justified theoretically. In addition, the probabilities for the selection procedure are chosen arbitrarily, which may lead to a poorly selected model. Since these methods employ local search, it is unlikely that the global maximum set of variables will be found (Mantel, <xref ref-type="bibr" rid="B10">1970</xref>; Hocking, <xref ref-type="bibr" rid="B7">1976</xref>, <xref ref-type="bibr" rid="B8">1983</xref>; Moses, <xref ref-type="bibr" rid="B11">1986</xref>).</p><p>We propose the use of genetic algorithms (GAs) to determine the subset of variables with the highest goodness of fit for a multiple regression model. Due to their global search capabilities, the GA based model building is not prone to the problems associated with local search method, hence is a wise choice for this procedure.</p><p>We now explain the basics of GAs briefly; a thorough one can be found in Goldberg (<xref ref-type="bibr" rid="B6">1989</xref>).</p></sec><sec><title>Genetic Algorithms</title><p>Genetic algorithms are a set of optimization techniques inspired by biological evolution, operating under natural selection. First developed by Holland (<xref ref-type="bibr" rid="B9">1975</xref>), they have grown in popularity because of the ability of the algorithm to perform well on many different types of problems. In a GA, possible solutions are coded using binary strings, which are called chromosomes. Each chromosome has a fitness value associated with it based on how well the string model parameters predicts the dependent variables. During each generation, which is the time step of the algorithm, a population of chromosomes compete to have their &#x0201c;genes&#x0201d; passed on to the next generation. The selection step is used to pick the chromosomes for the next generation based on their fitness. Those selected enter the mating pool, where two chromosomes mate using crossover. During this phase, parts of each parent string are swapped to form two new chromosomes that have certain aspects of their parents. After crossover, mutation is implemented. Mutation occurs with a small probability and is defined by a change from 0 to 1 or 1 to 0 in the binary string. Mutation allows the introduction of new &#x0201c;genes&#x0201d; that were either lost from the population or were not there to start with. Through successive generations, increasingly better chromosomes come to dominate the population, and the optimal solution (or something very close) is realized.</p></sec><sec><title>Complexity of a Model</title><p>A key component of a GA is the method to evaluate the fitness of a chromosome. Thus, in order to use a GA for model selection in multiple regression, a way to evaluate the chromosomes is needed. More specifically the fittest chromosome is the set of parameters that maximizes the explanatory power of the model with minimum number of parameters. Bozdogan (<xref ref-type="bibr" rid="B3">1988</xref>, <xref ref-type="bibr" rid="B4">2004</xref>) considered &#x0201c;complexity&#x0201d; as a measure of fitness, which can be described as follows:</p><disp-quote><p>The complexity of a system (of any type) is a measure of the degree of interdependency between the whole system and a simple enumerative composition of its subsystems or parts.</p></disp-quote><p>The concept of &#x0201c;information complexity&#x0201d; was first introduced by Akaike (<xref ref-type="bibr" rid="B1">1973</xref>) as a measure of the complexity of a model: it is a relative measure of the information lost when a given model is used, and can be described as a function of the precision and accuracy of the model. The expression for AIC is given as</p><disp-formula id="E1"><label>(1)</label><mml:math id="m1"><mml:mrow><mml:mtext>AIC</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn><mml:mi>log</mml:mi><mml:mo>&#x02061;</mml:mo><mml:mi>L</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mover><mml:mo>&#x003b8;</mml:mo><mml:mo>&#x02227;</mml:mo></mml:mover></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula><p>where <inline-formula><mml:math id="m2"><mml:mrow><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mo>&#x003b8;</mml:mo><mml:mo>&#x02227;</mml:mo></mml:mover></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> denotes the maximum likelihood function, <inline-formula><mml:math id="m3"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mo>&#x003b8;</mml:mo><mml:mo>^</mml:mo></mml:mover><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is the maximum likelihood estimate of parameter vector &#x003b8;<italic><sub>k</sub></italic>, and <italic>m</italic>(<italic>k</italic>) is the number of parameters in the model. The first term of AIC gives the lack of fit of the model, and the second term is a penalty for the number of parameters in the model. The model with the lowest AIC value is considered the best, because the model successfully determines the underlying stochastic process with the least number of parameters. Although AIC does take into account the problem of over-fitting, where other measures such as <italic>R</italic>-square do not, AIC is not sensitive to parameter dependency, which is an important component for model selection. If a model with both low variance and low covariance can be produced, then the parameters can be better estimated, as they will not be correlated. As an alternative to AIC, we consider ICOMP as a complexity measure which considers variance and covariance, and accounts for the problem of over-fitting the model. It is calculated by</p><disp-formula id="E2"><label>(2)</label><mml:math id="m4"><mml:mrow><mml:mtext>ICOMP</mml:mtext><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mi>log</mml:mi><mml:mo>&#x02061;</mml:mo><mml:mi>L</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mover><mml:mo>&#x003b8;</mml:mo><mml:mo>&#x02227;</mml:mo></mml:mover></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mo>&#x003a3;</mml:mo><mml:mo>&#x02227;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mtext>Model</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula><p>where <inline-formula><mml:math id="m5"><mml:mrow><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mo>&#x003b8;</mml:mo><mml:mo>&#x02227;</mml:mo></mml:mover></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> again denotes the maximum likelihood function, <inline-formula><mml:math id="m6"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mo>&#x003b8;</mml:mo><mml:mo>^</mml:mo></mml:mover><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is the maximum likelihood estimate of parameter vector &#x003b8;<italic><sub>k</sub></italic> under the model <italic>m<sub>k</sub></italic>, <italic>C</italic> is a real-valued complexity measure, and <inline-formula><mml:math id="m7"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mo>&#x003a3;</mml:mo><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mtext>Model</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is the estimated covariance matrix of the parameters of the model. Note that the first term in AIC is double the first term in ICOMP. The main difference between the two measures of complexity is that AIC only considers the number of parameters as a penalty, whereas ICOMP considers the covariance between parameters. In predictive model building, we use ICOMP (IFIM) as our multiple regression model selection criterion. This value for ICOMP is based on the inverse-Fisher information matrix (IFIM). For multiple regression, the value of ICOMP can be directly calculated after regression is implemented, and is given by</p><disp-formula id="E3"><label>(3)</label><mml:math id="m8"><mml:mrow><mml:mtext>ICOMP</mml:mtext><mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mtext>IFIM</mml:mtext><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mtext>Regression</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mi>log</mml:mi><mml:mo>&#x02061;</mml:mo><mml:mtext>&#x02009;</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo>&#x003c0;</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>n</mml:mi><mml:mi>log</mml:mi><mml:mo>&#x02061;</mml:mo><mml:mtext>&#x02009;</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mover><mml:mo>&#x003c3;</mml:mo><mml:mo>&#x02227;</mml:mo></mml:mover></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mover><mml:mi>F</mml:mi><mml:mo>&#x02227;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mo>&#x003b8;</mml:mo><mml:mi>M</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula><p>where</p><disp-formula id="E4"><label>(4)</label><mml:math id="m9"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mover accent="true"><mml:mi>F</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mo>&#x003b8;</mml:mo><mml:mi>M</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>q</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mi>log</mml:mi><mml:mo>&#x02061;</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mtext>tr</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mover><mml:mo>&#x003c3;</mml:mo><mml:mo>&#x02227;</mml:mo></mml:mover></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:msup><mml:mi>X</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:msup><mml:mrow><mml:mover><mml:mo>&#x003c3;</mml:mo><mml:mo>&#x02227;</mml:mo></mml:mover></mml:mrow><mml:mn>4</mml:mn></mml:msup></mml:mrow><mml:mi>n</mml:mi></mml:mfrac></mml:mrow><mml:mrow><mml:mi>q</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfrac></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mi>log</mml:mi><mml:mo>&#x02061;</mml:mo><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mover><mml:mo>&#x003c3;</mml:mo><mml:mo>&#x02227;</mml:mo></mml:mover></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:msup><mml:mi>X</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>|</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mi>log</mml:mi><mml:mo>&#x02061;</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:msup><mml:mrow><mml:mover><mml:mo>&#x003c3;</mml:mo><mml:mo>&#x02227;</mml:mo></mml:mover></mml:mrow><mml:mn>4</mml:mn></mml:msup></mml:mrow><mml:mi>n</mml:mi></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula><p><italic>n</italic> is the number of parameters in the model, <italic>q</italic> is the number of observations, <inline-formula><mml:math id="m10"><mml:mrow><mml:msup><mml:mover accent="true"><mml:mo>&#x003c3;</mml:mo><mml:mo>^</mml:mo></mml:mover><mml:mn>2</mml:mn></mml:msup><mml:mo>=</mml:mo><mml:mtext>SSE</mml:mtext><mml:mo>/</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mtext>tr</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mover accent="true"><mml:mo>&#x003c3;</mml:mo><mml:mo>^</mml:mo></mml:mover><mml:mn>2</mml:mn></mml:msup><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:msup><mml:mi>X</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is the trace of the observation matrix multiplied by its inverse and then scaled by <inline-formula><mml:math id="m11"><mml:mrow><mml:msup><mml:mover accent="true"><mml:mo>&#x003c3;</mml:mo><mml:mo>^</mml:mo></mml:mover><mml:mn>2</mml:mn></mml:msup><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="m12"><mml:mrow><mml:mo>|</mml:mo><mml:msup><mml:mover accent="true"><mml:mo>&#x003c3;</mml:mo><mml:mo>^</mml:mo></mml:mover><mml:mn>2</mml:mn></mml:msup><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:msup><mml:mi>X</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> is the determinant of the previous matrix.</p><p>Since the model with the lowest ICOMP value is considered the best, the GA chooses strings biased toward those with the lowest value. A commonly used method to form the mating pool is &#x0201c;proportional selection,&#x0201d; which depends on selecting strings for the mating pool with a probability proportional to their fitnesses. In proportional selection, the first step of the calculation of the fitness values is subtracting the ICOMP value of each string in that generation from the maximum value of ICOMP in the population. That is,</p><disp-formula id="E5"><label>(5)</label><mml:math id="m13"><mml:mrow><mml:mo>&#x00394;</mml:mo><mml:mtext>ICOMP</mml:mtext><mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mtext>IFIM</mml:mtext><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mtext>ICOMP</mml:mtext><mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mtext>IFIM</mml:mtext><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mtext>Max</mml:mtext><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>&#x02212;</mml:mo><mml:mtext>ICOMP</mml:mtext><mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mtext>IFIM</mml:mtext><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></disp-formula><p>for each <italic>i</italic>&#x02009;=&#x02009;1,2,&#x02026;,<italic>N</italic>, where <italic>N</italic> is the size of the population. Then the average ICOMP difference (the &#x0201c;average fitness&#x0201d;) for the total population is calculated as</p><disp-formula id="E6"><label>(6)</label><mml:math id="m14"><mml:mrow><mml:mo>&#x00394;</mml:mo><mml:mtext>ICOMP</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mtext>IFIM</mml:mtext><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:mstyle displaystyle="true"><mml:mrow><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover><mml:mrow><mml:mo>&#x00394;</mml:mo><mml:mtext>ICOMP</mml:mtext><mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mtext>IFIM</mml:mtext><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mstyle><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula><p>Finally, each string is given a fitness value that is the ratio of its ICOMP difference and the average fitness of the population:</p><disp-formula id="E7"><label>(7)</label><mml:math id="m15"><mml:mrow><mml:msub><mml:mrow><mml:mtext>Fitness</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mo>&#x00394;</mml:mo><mml:mtext>ICOMP</mml:mtext><mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mtext>IFIM</mml:mtext><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mo>&#x00394;</mml:mo><mml:mtext>ICOMP</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mtext>IFIM</mml:mtext><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="true">&#x000af;</mml:mo></mml:mover></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></sec><sec><title>A Genetic Algorithm for Multiple Linear Regression Model Selection</title><p>Here we consider the implementation of GA's for predictive model selection and discuss possible improvements.</p><sec><title>Background</title><p>The first step to implementing a GA for any optimization problem is to encode the input variable into binary strings. In the case of multiple linear regression, we have <italic>q</italic> data points with <italic>n</italic> explanatory variables and one response variable. We wish to fit the data to</p><disp-formula id="E8"><label>(8)</label><mml:math id="m16"><mml:mrow><mml:mi>y</mml:mi><mml:mo>=</mml:mo><mml:mi>X</mml:mi><mml:mo>&#x003b2;</mml:mo><mml:mo>+</mml:mo><mml:mo>&#x003b5;</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula><p>where <italic>y</italic> is an <italic>n</italic>&#x02009;&#x000d7;&#x02009;1 response vector, <italic>X</italic> is an <italic>n</italic>&#x02009;&#x000d7;&#x02009;<italic>q</italic> matrix of the data points, &#x003b2; is a <italic>q</italic>&#x02009;&#x000d7;&#x02009;1 coefficient matrix, and &#x003b5; is an <italic>n</italic>&#x02009;&#x000d7;&#x02009;1 error vector with entries from independent normal distributions [<italic>N</italic>(0, &#x003c3;<sup>2</sup>) for all components]. The encoding is done by creating a binary string which has <italic>n</italic>&#x02009;+&#x02009;1 bits, where each bit represents a different parameter of the model and an intercept. The last <italic>n</italic> bits correspond to the <italic>n</italic> explanatory variables contained in the dataset, whereas the first bit is the intercept for the linear model. A parameter is included in the model if the value of the bit for that parameter is a 1 and is excluded if it is a 0. For example, suppose we have a dataset where we are interested in predicting the reproductive fitness of a species of trees. The possible explanatory variables may include:</p><list list-type="order"><list-item><p>Age of tree,</p></list-item><list-item><p>Height of tree,</p></list-item><list-item><p>Soil pH,</p></list-item><list-item><p>Density of trees in the surrounding area,</p></list-item><list-item><p>Average temperature of environment,</p></list-item><list-item><p>Average rainfall of environment,</p></list-item><list-item><p>Circumference of trunk,</p></list-item><list-item><p>Longitude of environment,</p></list-item><list-item><p>Latitude of environment,</p></list-item><list-item><p>Prevalence of disease in environment.</p></list-item></list><p>In this case, each binary string will have 11 bits. For example, the string 10010111101 would represent a model which includes the intercept, soil pH, average temperature of environment, average rainfall of environment, circumference of trunk, longitude of environment, and prevalence of disease in environment. Similarly, the string 00001000110 is a model that has no intercept, and includes density of trees in the surrounding area, longitude of environment, and latitude of environment (see Table <xref ref-type="table" rid="T1">1</xref>).</p><table-wrap id="T1" position="float"><label>Table 1</label><caption><p><bold>Chromosomes and variables included by the model it represents</bold>.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left" rowspan="1" colspan="1">Chromosome</th><th align="left" rowspan="1" colspan="1">Variables included</th></tr></thead><tbody><tr><td align="left" rowspan="1" colspan="1">10010111101</td><td align="left" rowspan="1" colspan="1">Intercept, 3, 5, 6, 7, 8, 10</td></tr><tr><td align="left" rowspan="1" colspan="1">00001000110</td><td align="left" rowspan="1" colspan="1">4, 8, 9</td></tr></tbody></table></table-wrap><p>The probability that a string will be chosen for the mating pool is proportional to its fitness value. Note that the string with the worst ICOMP value will never be picked for the mating pool, as its fitness will be 0.</p><p>Now that we have a method of encoding information and a method to evaluate the fitness values, we have to determine the remaining parameters of the GA. The first one we consider is the method of creating the initial population and determining its size. Unless previous knowledge about the problem is given, it is commonplace in GAs to randomly generate binary strings (Goldberg, <xref ref-type="bibr" rid="B6">1989</xref>). However, in the case of model selection, a user may want to force a parameter(s) to be included, even if it is not part of the model with the lowest complexity. In this case, the initial population can be generated in such a way that certain parameters are always in the model. In addition to determining the method to generate the population, the user must choose the size of the initial population. This decision can be difficult. Generally the size should not be too large, as this will slow the algorithm, and should not be so small that genetic drift takes over the course of evolution of the population. In typical GAs, the size of the population stays the same; however, this may not be an effective use of computation. We will see in the next section that starting with a larger size then reducing it may be more effective.</p><p>Finally, we discuss the genetic operators which allow the algorithm to find the optimal model. There are two operators that are generally implemented in GAs: crossover and mutation. Crossover mimics biological crossover in a simplified manner. First, the probability of crossover, <italic>p<sub>c</sub></italic>, is chosen. In the mating pool, a pair of strings are chosen along with a random number from [0, 1]. If that number is less than the probability of crossover, crossover occurs. Thus, if <italic>p<sub>c</sub></italic>&#x02009;=&#x02009;1, then every pair will cross, and if <italic>p<sub>c</sub></italic>&#x02009;=&#x02009;0, then no strings will be altered by crossover. After the choice of <italic>p<sub>c</sub></italic>, the number of crossover points must be chosen. The location of the crossover points is chosen at random. Then the bits from the parent strings are swapped to create two new offspring strings (see Figure <xref ref-type="fig" rid="F1">1</xref>). The purpose of crossover is to bring together models which have components that reduce complexity. Recall the previous example about trees, where we specified two strings, which we will call Parent 1 and Parent 2. Applying crossover to the two parents creates two offspring (see Figure <xref ref-type="fig" rid="F1">1</xref>), where Offspring 1 represents a model with an intercept, soil pH, average temperature of environment, longitude of environment, latitude of environment, and prevalence of disease in environment, and Offspring 2 represents a model that includes density of trees in the surrounding area, average rainfall of environment, circumference of trunk, and longitude of environment. Through successive generations and application of crossover of low complexity models, the algorithm is able to find the least complex model (or something close to it) to explain the data.</p><fig id="F1" position="float"><label>Figure 1</label><caption><p><bold>Diagram of crossover with two points</bold>.</p></caption><graphic xlink:href="fnins-04-00033-g001"/></fig><p>Crossover can only generate models that include parameters which already exist in the population. But, what happens if the actual least complex model includes a parameter that is not present in the population, that is, the position in the string that represents the parameter is fixed at 0? Mutation alleviates this problem. Mutation in GAs is similar to the mutation that occurs naturally in DNA. First, the probability of mutation, <italic>p<sub>m</sub></italic>, has to be determined. This value gives the probability that at each location in the string the bit will be flipped. Flipping is defined as a change of a 0 to 1 or a 1 to a 0. Typically, mutation rates are low, on the order of 10<sup>&#x02212;3</sup> to 10<sup>&#x02212;5</sup>. However, strings used for other applications of GA's are usually longer than the ones used for determining least complex models. Although there are ongoing studies on determining optimal crossover and mutation rates (such as Nested GAs, Self-adjusting parameterless GAs), these rates can be determined by trial and error or by pilot runs before the actual data set has been used to build a model.</p><p>We conclude this section with a pseudo code for a GA used to find the least complex model that sufficiently describes the data.</p><list list-type="order"><list-item><p>Generate Initial Population</p></list-item><list-item><p>While (<italic>t</italic>&#x02009;&#x0003c;&#x02009;Max Generations OR the maximum number of computations have not been executed)</p><p>(a)Calculate ICOMP for the model each string encodes</p><p>(b)Select strings for the mating pool</p><p>(c)Create a new population using crossover</p><p>(d)Mutate new population</p><p>(e)<italic>t</italic>&#x02009;=&#x02009;<italic>t</italic>&#x02009;+&#x02009;1</p></list-item><list-item><p>End</p></list-item></list></sec><sec><title>Model building via accelerated genetic algorithms</title><p>While the use of a typical GA for model selection already proves to be more efficient than stepwise regression, with a few modifications, the process can show a 10-fold increase in accuracy given the same amount of computation. First, we discuss the modifications, and then we explain the study done to determine the effectiveness of these modifications.</p><p>The first modification is changing how the initial population was created. According to Fisher's Fundamental Theorem of Natural Selection (Fisher, <xref ref-type="bibr" rid="B5">1930</xref>), the increase in mean fitness is equal to the variance in fitness. For model selection using GAs, the easiest way to increase variance in fitness would be to allow every model to be represented in the population. Of course, this is impossible for a model with a large number of possible explanatory variables, and would amount to doing an exhaustive search. We believe that the next best procedure is to force the population to start with the highest variance in each position of the chromosome. Since each position is either a 0 or 1, this would imply that at each position there are the same amount of 0&#x02019;s and 1&#x02019;s across the entire population. To implement this procedure, half of the initial population is randomly generated. The other half is generated by taking each of the chromosomes in the first half and changing each bit from 1 to 0 or 0 to 1. We call this process <italic>diversifying</italic>. In addition to increasing variance at each position, this procedure guarantees that within one generation, recombination alone could generate the best model. That is, every possible combination of explanatory variables is attainable within one generation. This does not imply that mutation is not necessary, as selection acts on the entire string, not individual positions. Since selection will reduce variance at each position, mutation is still required to maintain some variance.</p><p>The second modification is starting with a larger initial population and then reducing it in size. We have used a reduction method that adapts to the changes in the algorithm in this study.</p><p>Adaptively reducing the population is done by calculating the change in the best fitness between two consecutive generations and then reducing the population based on this change. More specifically, the population is reduced by the percentage increase in best fitness up to some limit. Clearly, there must be a limit to the percentage of reduction, since the population should not be reduced too much, and also because the percent change can be more than 100. Here the amount of population reduction depends on the complexity of the problem, that is the type of the fitness function (such as MSE, AIC, ICOM, Mallow's Cp and so on) used. This limit on the reduction may be determined by pilot studies. The percent change in fitness at generation <italic>t</italic> is denoted by <inline-formula><mml:math id="m17"><mml:mrow><mml:mo>&#x00394;</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mi>t</mml:mi><mml:mrow><mml:mtext>best</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> and the limit is denoted by <inline-formula><mml:math id="m18"><mml:mrow><mml:mo>&#x00394;</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x02061;</mml:mo></mml:mrow><mml:mrow><mml:mtext>best</mml:mtext></mml:mrow></mml:msubsup><mml:mo>.</mml:mo></mml:mrow></mml:math></inline-formula> The change is calculated by the formula <inline-formula><mml:math id="m19"><mml:mrow><mml:mo>&#x00394;</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mi>t</mml:mi><mml:mrow><mml:mtext>best</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mtext>best</mml:mtext></mml:mrow></mml:msubsup><mml:mo>&#x02212;</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mtext>best</mml:mtext></mml:mrow></mml:msubsup><mml:mo>|</mml:mo><mml:mo>/</mml:mo><mml:mo>|</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mtext>best</mml:mtext></mml:mrow></mml:msubsup><mml:mo>|</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></inline-formula> The population size <italic>N</italic>(<italic>t</italic>) at each generation is given by the recursive relation</p><disp-formula id="E9"><label>(9)</label><mml:math id="m20"><mml:mrow><mml:mi>N</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>&#x02212;</mml:mo><mml:mo>&#x00394;</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mi>t</mml:mi><mml:mrow><mml:mtext>best</mml:mtext></mml:mrow></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02003;</mml:mo><mml:mtext>if</mml:mtext><mml:mo>&#x02009;</mml:mo><mml:mo>&#x00394;</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mi>t</mml:mi><mml:mrow><mml:mtext>best</mml:mtext></mml:mrow></mml:msubsup><mml:mo>&#x02264;</mml:mo><mml:mo>&#x00394;</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x02061;</mml:mo></mml:mrow><mml:mrow><mml:mtext>best</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>&#x02212;</mml:mo><mml:mo>&#x00394;</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x02061;</mml:mo></mml:mrow><mml:mrow><mml:mtext>best</mml:mtext></mml:mrow></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02003;</mml:mo><mml:mtext>if</mml:mtext><mml:mo>&#x02009;</mml:mo><mml:mo>&#x00394;</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mi>t</mml:mi><mml:mrow><mml:mtext>best</mml:mtext></mml:mrow></mml:msubsup><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x00394;</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x02061;</mml:mo></mml:mrow><mml:mrow><mml:mtext>best</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mtext>MIN</mml:mtext><mml:mo>_</mml:mo><mml:mtext>POPSIZE</mml:mtext><mml:mo>,</mml:mo><mml:mo>&#x02003;</mml:mo><mml:mtext>if</mml:mtext><mml:mo>&#x02009;</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext>will</mml:mtext><mml:mo>&#x02009;</mml:mo><mml:mtext>be</mml:mtext><mml:mo>&#x02009;</mml:mo><mml:mtext>less</mml:mtext><mml:mo>&#x02009;</mml:mo><mml:mtext>than</mml:mtext><mml:mo>&#x02009;</mml:mo><mml:mtext>MIN</mml:mtext><mml:mo>_</mml:mo><mml:mtext>POPSIZE</mml:mtext></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula><p>When using the adaptive method, &#x0201c;elitism&#x0201d; was also implemented. Elitism is a procedure commonly used in GAs in order to pass the best chromosome, or a group of the best chromosomes, to the next generation without any modifications. Using elitism guarantees that the change in best fitness is always non-negative. As a result, the population never increases in size. Since we wished to minimize ICOMP, we set the fitness of each chromosome to be the negative of the ICOMP value.</p><p>The user must determine the values for <inline-formula><mml:math id="m21"><mml:mrow><mml:mo>&#x00394;</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x02061;</mml:mo></mml:mrow><mml:mrow><mml:mtext>best</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> and MIN_POPSIZE. The choices of these parameters should be done by considering characteristics of the problem such as the expected increase in fitness over time. This is typically a difficult characteristic to determine. Generally, as the number of variables increase, the value of <inline-formula><mml:math id="m22"><mml:mrow><mml:mo>&#x00394;</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x02061;</mml:mo></mml:mrow><mml:mrow><mml:mtext>best</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> should decrease. As the number of variables increases, so does the number of possible values of ICOMP, and the likelihood that the population will evolve slower. The value of MIN_POPSIZE should be chosen so that it is quite small (&#x02248;5), regardless of the number of variables. As a side note, the GA with no population reduction is a special case of the adaptive method where <inline-formula><mml:math id="m23"><mml:mrow><mml:mo>&#x00394;</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x02061;</mml:mo></mml:mrow><mml:mrow><mml:mtext>best</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>0.</mml:mn></mml:mrow></mml:math></inline-formula></p><p>The final modification to a GA for multiple regressions is the use of &#x0201c;binary tournament&#x0201d; instead of proportional selection. In this selection scheme, two chromosomes are chosen at random, and the one with the lower ICOMP value is selected for the mating pool. Then both chromosomes are put back into the pool of contestants of the tournament. One advantage of this technique is that ICOMP values need only be calculated for the chromosomes that participate in the tournament. For models with few explanatory variables, this gain in computation may be negligible. On the other hand, for those models with many variables, the reduction in computation means that more generations can be used, or the initial population can be larger. When the population is being reduced, genetic drift may be amplified, since the sampling space for the next generation decreases. Proportional selection may increase this effect because a few chromosomes with extremely high fitness are expected to be picked often for the mating pool. However, selection to participate in the tournament is random, avoiding the over-selection of chromosomes with extremely large fitness values.</p><p>To test the benefits of these modifications, we used the data set in Bozdogan (<xref ref-type="bibr" rid="B4">2004</xref>) where the predictive model is constructed for body fat and 13 explanatory variables. In order to determine how well the GA was performing, all subsets of the variables (2<sup>14</sup> &#x02212;&#x02009;1&#x02009;=&#x02009;16,383 subsets) were used to generate a model, and then the ICOMP value was determined. This way, the subset yielding the least complex model was found. Testing was done to ensure the same ICOMP values were being generated for the MATLAB and Java code. We performed comparisons between Bozdogan's original setup and four cases with our modifications. These cases differed in the value of <inline-formula><mml:math id="m24"><mml:mrow><mml:mo>&#x00394;</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x02061;</mml:mo></mml:mrow><mml:mrow><mml:mtext>best</mml:mtext></mml:mrow></mml:msubsup><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula> and as a result in the initial population size. All trials were allowed 600 computations, where a computation is the total number of chromosomes summed over every generation. Table <xref ref-type="table" rid="T2">2</xref> gives the parameters that were the same for all different setups. Each different GA scheme ran through 200 trials and the number of times the correct model was selected was recorded. Table <xref ref-type="table" rid="T3">3</xref> gives the results.</p><table-wrap id="T2" position="float"><label>Table 2</label><caption><p><bold>Parameters that were the same for all genetic algorithm schemes</bold>.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left" rowspan="1" colspan="1">Number of computations allowed</th><th align="left" rowspan="1" colspan="1">600</th></tr></thead><tbody><tr><td align="left" rowspan="1" colspan="1">Population size (without reduction)</td><td align="left" rowspan="1" colspan="1">30</td></tr><tr><td align="left" rowspan="1" colspan="1">Number of generations (without reduction)</td><td align="left" rowspan="1" colspan="1">20</td></tr><tr><td align="left" rowspan="1" colspan="1">Number of crossover points</td><td align="left" rowspan="1" colspan="1">2</td></tr><tr><td align="left" rowspan="1" colspan="1">Mutation rate</td><td align="left" rowspan="1" colspan="1">0.05</td></tr></tbody></table></table-wrap><table-wrap id="T3" position="float"><label>Table 3</label><caption><p><bold>The frequency of the correct model being selected over 200 trials</bold>. The first 4 schemes are with the modifications and the last is without.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left" rowspan="1" colspan="1">GA scheme</th><th align="left" rowspan="1" colspan="1">Frequency of correct solution</th></tr></thead><tbody><tr><td align="left" rowspan="1" colspan="1">Adaptive <inline-formula><mml:math id="m25"><mml:mrow><mml:mo>&#x00394;</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x02061;</mml:mo></mml:mrow><mml:mrow><mml:mtext>best</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula><break/>(no population reduction)</td><td align="left" rowspan="1" colspan="1">0.915</td></tr><tr><td align="left" rowspan="1" colspan="1">Adaptive <inline-formula><mml:math id="m26"><mml:mrow><mml:mo>&#x00394;</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x02061;</mml:mo></mml:mrow><mml:mrow><mml:mtext>best</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>0.1</mml:mn></mml:mrow></mml:math></inline-formula></td><td align="left" rowspan="1" colspan="1">0.935</td></tr><tr><td align="left" rowspan="1" colspan="1">Adaptive <inline-formula><mml:math id="m27"><mml:mrow><mml:mo>&#x00394;</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x02061;</mml:mo></mml:mrow><mml:mrow><mml:mtext>best</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>0.2</mml:mn></mml:mrow></mml:math></inline-formula></td><td align="left" rowspan="1" colspan="1">0.93</td></tr><tr><td align="left" rowspan="1" colspan="1">Adaptive <inline-formula><mml:math id="m28"><mml:mrow><mml:mo>&#x00394;</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x02061;</mml:mo></mml:mrow><mml:mrow><mml:mtext>best</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>0.3</mml:mn></mml:mrow></mml:math></inline-formula></td><td align="left" rowspan="1" colspan="1">0.905</td></tr><tr><td align="left" rowspan="1" colspan="1">Bozdogan's</td><td align="left" rowspan="1" colspan="1">0.09</td></tr></tbody></table></table-wrap></sec></sec><sec><title>Conclusion</title><p>While model selection remains to be a difficult procedure in case of a large number of parameters, using a GA to find the least complex model can be quite helpful. We have shown that our modifications to the original GA for model selection can yield strong results. Additionally, the GA approach (because of the use of ICOMP) is better at handling data in which collinearity exist than the traditional selection methods such as forward, backward, and stepwise selection. In particular it is clear that the modifications had a large effect on the accuracy of the GA. All of the GAs which implemented our modifications significantly outperformed Bozdogan's GA. This seems to indicate that we may reduce computation and still get statistically the same accuracy if we employ diversification. In all trials, diversification never decreased accuracy. Along with the facts presented above and the fact that diversification is easy (and not costly) to implement, it is our recommendation that it be used for model selection using GAs.</p></sec><sec><title>Conflict of Interest Statement</title><p>The authors declare that the research was conducted in the absence of any commercial or financial relationships that could be construed as a potential conflict of interest.</p></sec></body><back><ref-list><title>References</title><ref id="B1"><mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Akaike</surname><given-names>H.</given-names></name></person-group> (<year>1973</year>). <article-title>&#x0201c;Information theory and an extension of the maximum likelihood principle,&#x0201d;</article-title> in <source>Second International Symposium on Information Theory</source>, eds <person-group person-group-type="editor"><name><surname>Petrov</surname><given-names>B. N.</given-names></name><name><surname>Cs&#x000e1;ki</surname><given-names>F.</given-names></name></person-group> (<publisher-loc>Budapest</publisher-loc>: <publisher-name>Acad&#x000e9;miai Kiad&#x000f3;</publisher-name>), <fpage>267</fpage>&#x02013;<lpage>281</lpage></mixed-citation></ref><ref id="B2"><mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Boyce</surname><given-names>D. E.</given-names></name><name><surname>Farhi</surname><given-names>A.</given-names></name><name><surname>Weischedel</surname><given-names>R.</given-names></name></person-group> (<year>1974</year>). <source>Optimal Subset Selection: Multiple Regression, Interdependence, and Optimal Network Algorithms</source>. <publisher-loc>New York</publisher-loc>: <publisher-name>Springer-Verlag</publisher-name></mixed-citation></ref><ref id="B3"><mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Bozdogan</surname><given-names>H.</given-names></name></person-group> (<year>1988</year>). <article-title>&#x0201c;ICOMP: a new model-selection criterion,&#x0201d;</article-title> in <source>Classification and Related Methods of Data Analysis</source>, ed. <person-group person-group-type="editor"><name><surname>Bock</surname><given-names>H. H.</given-names></name></person-group> (<publisher-loc>Amsterdam</publisher-loc>: <publisher-name>Elsevier Science Publishers</publisher-name>), <fpage>599</fpage>&#x02013;<lpage>608</lpage></mixed-citation></ref><ref id="B4"><mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Bozdogan</surname><given-names>H.</given-names></name></person-group> (<year>2004</year>). <source>Statistical Data Mining and Knowledge Discovery</source>. <publisher-loc>Boca Raton, FL</publisher-loc>: <publisher-name>Chapman and Hall/CRC</publisher-name></mixed-citation></ref><ref id="B5"><mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Fisher</surname><given-names>R. A.</given-names></name></person-group> (<year>1930</year>). <source>The Genetical Theory of Natural Selection</source>. <publisher-loc>Oxford</publisher-loc>: <publisher-name>Clarendon Press</publisher-name></mixed-citation></ref><ref id="B6"><mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Goldberg</surname><given-names>D. E.</given-names></name></person-group> (<year>1989</year>). <source>Genetic Algorithms in Search, Optimization, and Machine Learning</source>. <publisher-loc>Reading, MA</publisher-loc>: <publisher-name>Addison-Wesley</publisher-name></mixed-citation></ref><ref id="B7"><mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hocking</surname><given-names>R. R.</given-names></name></person-group> (<year>1976</year>). <article-title>The analysis and selection variables in linear regression</article-title>. <source>Biometrics</source><volume>32</volume>, <fpage>1044</fpage><pub-id pub-id-type="doi">10.2307/2529336</pub-id></mixed-citation></ref><ref id="B8"><mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hocking</surname><given-names>R. R.</given-names></name></person-group> (<year>1983</year>). <article-title>Developments in linear regression methodology: 1959&#x02013;1982</article-title>. <source>Technometrics</source><volume>25</volume>, <fpage>219</fpage>&#x02013;<lpage>230</lpage><pub-id pub-id-type="doi">10.2307/1268603</pub-id></mixed-citation></ref><ref id="B9"><mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Holland</surname><given-names>J. H.</given-names></name></person-group> (<year>1975</year>). <source>Adaptation in Natural and Artificial Systems</source>. <publisher-loc>Ann Arbor, MI</publisher-loc>: <publisher-name>University of Michigan Press</publisher-name></mixed-citation></ref><ref id="B10"><mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mantel</surname><given-names>N.</given-names></name></person-group> (<year>1970</year>). <article-title>Why stepdown procedures in variables selection</article-title>. <source>Technometrics</source><volume>12</volume>, <fpage>591</fpage>&#x02013;<lpage>612</lpage><pub-id pub-id-type="doi">10.2307/1267207</pub-id></mixed-citation></ref><ref id="B11"><mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Moses</surname><given-names>L. E.</given-names></name></person-group> (<year>1986</year>). <source>Think and Explain with Statistics</source>. <publisher-loc>Reading, MA</publisher-loc>: <publisher-name>Addison-Wesley</publisher-name></mixed-citation></ref><ref id="B12"><mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Wilkinson</surname><given-names>L.</given-names></name></person-group> (<year>1989</year>). <source>SYSTAT: The System for Statistics</source>, <publisher-loc>Evanston, IL</publisher-loc>: <publisher-name>SYSTAT</publisher-name></mixed-citation></ref></ref-list></back></article>