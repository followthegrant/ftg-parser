<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.0 20120330//EN" "JATS-archivearticle1.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">Biomed Res Int</journal-id><journal-id journal-id-type="iso-abbrev">Biomed Res Int</journal-id><journal-id journal-id-type="publisher-id">BMRI</journal-id><journal-title-group><journal-title>BioMed Research International</journal-title></journal-title-group><issn pub-type="ppub">2314-6133</issn><issn pub-type="epub">2314-6141</issn><publisher><publisher-name>Hindawi Publishing Corporation</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">24078906</article-id><article-id pub-id-type="pmc">3773971</article-id><article-id pub-id-type="doi">10.1155/2013/170580</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research Article</subject></subj-group></article-categories><title-group><article-title>Secure Encapsulation and Publication of Biological Services in the Cloud Computing Environment</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Zhang</surname><given-names>Weizhe</given-names></name><xref ref-type="aff" rid="I1">
<sup>1</sup>
</xref><xref ref-type="corresp" rid="cor1">*</xref></contrib><contrib contrib-type="author"><name><surname>Wang</surname><given-names>Xuehui</given-names></name><xref ref-type="aff" rid="I1">
<sup>1</sup>
</xref></contrib><contrib contrib-type="author"><name><surname>Lu</surname><given-names>Bo</given-names></name><xref ref-type="aff" rid="I2">
<sup>2</sup>
</xref></contrib><contrib contrib-type="author"><name><surname>Kim</surname><given-names>Tai-hoon</given-names></name><xref ref-type="aff" rid="I3">
<sup>3</sup>
</xref></contrib></contrib-group><aff id="I1"><sup>1</sup>School of Computer Science and Technology, Harbin Institute of Technology, Harbin 150001, China</aff><aff id="I2"><sup>2</sup>Network and Information Center, Harbin Institute of Technology, Harbin 150001, China</aff><aff id="I3"><sup>3</sup>School of Computer and Information Science, University of Tasmania, Virginia Court, Sandy Bay, Hobart, TAS 7001, Australia</aff><author-notes><corresp id="cor1">*Weizhe Zhang: <email>wzzhang@hit.edu.cn</email></corresp><fn fn-type="other"><p>Academic Editor: Sabah Mohammed</p></fn></author-notes><pub-date pub-type="ppub"><year>2013</year></pub-date><pub-date pub-type="epub"><day>1</day><month>9</month><year>2013</year></pub-date><volume>2013</volume><elocation-id>170580</elocation-id><history><date date-type="received"><day>5</day><month>6</month><year>2013</year></date><date date-type="accepted"><day>19</day><month>6</month><year>2013</year></date></history><permissions><copyright-statement>Copyright &#x000a9; 2013 Weizhe Zhang et al.</copyright-statement><copyright-year>2013</copyright-year><license xlink:href="https://creativecommons.org/licenses/by/3.0/"><license-p>This is an open access article distributed under the Creative Commons Attribution License, which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p></license></permissions><abstract><p>Secure encapsulation and publication for bioinformatics software products based on web service are presented, and the basic function of biological information is realized in the cloud computing environment. In the encapsulation phase, the workflow and function of bioinformatics software are conducted, the encapsulation interfaces are designed, and the runtime interaction between users and computers is simulated. In the publication phase, the execution and management mechanisms and principles of the GRAM components are analyzed. The functions such as remote user job submission and job status query are implemented by using the GRAM components. The services of bioinformatics software are published to remote users. Finally the basic prototype system of the biological cloud is achieved.</p></abstract><funding-group><award-group><funding-source>http://dx.doi.org/10.13039/501100001809 National Natural Science Foundation of China</funding-source><award-id>61173145</award-id></award-group></funding-group></article-meta></front><body><sec id="sec1"><title>1. Introduction</title><p>
In recent decade years, bioinformatics is a leading branch of biological science which deals with the study of methods for storing, retrieving, and analyzing biological data [<xref rid="B1" ref-type="bibr">1</xref>]. The rising of bioinformatics software becomes a specialized field. Some bioinformatics software products, such as Blast (database search) [<xref rid="B2" ref-type="bibr">2</xref>], Clustalw (multiple sequence match) [<xref rid="B3" ref-type="bibr">3</xref>], <italic>phylip</italic> (biological phylogenetic analysis software) [<xref rid="B4" ref-type="bibr">4</xref>], and EMBOSS (large sequence analysis) [<xref rid="B5" ref-type="bibr">5</xref>], have become an indispensable tool for molecular biology research. Open, public, and common are the main features of bioinformatics software. These software products are usually used in various forms of open source code copyright statement and take the Linux operating system as the main platform. They are mainly developed by scientific research institutions, colleges, universities, and other academic departments freely and provide public use. In the bioinformatics software's directory of GNU Project, there exist 15 kinds of software products, and, in the bioinformatics software's directory of the Open Science project, there exists 51 kinds.</p><p>However, the development of the open source software usually aims at solving some specific issues for a particular research field. The academic research is its main purpose, and personal interest is its main driving force. So the program often lacks detail documents and necessary user supports. Installation and configuration of this software will need a certain knowledge and experience of computer programming and system maintenance, which makes this software difficult to be used by most biologists in their research. Even if the user is biological information scientist or even the professional system administrator, it is difficult for them to face many software products with limited documents. In addition, with the rapid increasing of biological information's data scale and the further research for the data, some software will be needed in a research project [<xref rid="B6" ref-type="bibr">6</xref>]. The common bioinformatics software, including both free software from academic unit and expensive commercial software, far cannot satisfy the above requirements. For the data format, the same DNA or protein sequences in different databases have different storage format and use different input/output formats in different applications. The user must first be familiar with the conversion between these formats [<xref rid="B7" ref-type="bibr">7</xref>]. While, there are hundreds of kinds of sequence analysis software products, if the user is not familiar with their application and use methods, he needs to learn how to use the software and how to analyze the results, which is often wrong as well as time consuming. Although there have been many web-based analytical tools [<xref rid="B8" ref-type="bibr">8</xref>], the development of bioinformatics software still cannot get rid of the basic layout which takes the separate calculation method as basis, the individual computer program as the center, and the single calculation results as the goal, and some software's output results are difficult to understand for the biologists.</p><p>With the development of the web service in the cloud computing, we gradually pay more attention on this technology which contains a huge processing power. However, for the various bioinformatics products, even if we improve the processing power with the web service technology, we cannot solve the problem that the users need to spend a lot of time and energy to be familiar with different bioinformatics software's use methods or data organization structure. Therefore, it is necessary to provide unified and single software encapsulation for the bioinformatics software. Through the encapsulation, a unified interface and simple operation will be provided; thus the backstage software implementation details can be shielded off, and the users' requirements can be completed correctly and efficiently.</p><p>The following sections of this paper are organized as follows: <xref ref-type="sec" rid="sec2">Section 2</xref> introduces the bioinformatics software objects to encapsulation and publication; <xref ref-type="sec" rid="sec3">Section 3</xref> puts forward the outline of the bioinformatics software's encapsulation and publication and implements the encapsulation and publication on both Windows and Linux operating systems; <xref ref-type="sec" rid="sec4">Section 4</xref> conducts functional tests for the bioinformatics software to check the correctness of the encapsulation and publication.</p></sec><sec id="sec2"><title>2. Example of Bioinformatics Software</title><p>This paper chooses three bioinformatics software products as example, namely, gene sequences conversion tools <italic>seqret</italic>, gene sequences ORF search tools <italic>getorf</italic>, and the molecular clock based maximum likelihood estimation tools <italic>proml</italic>. Among them, the two executive programs <italic>seqret</italic> and <italic>getorf</italic> are, respectively, encapsulated on both Windows and Linux operating systems. <italic>Proml</italic> is an application running on the Windows platform, so it is only encapsulated on Windows platform.</p><sec id="sec2.1"><title>2.1. Gene Sequences Conversion Tools <italic>Seqret </italic>
</title><p>
<italic>Seqret</italic> is mainly used to transfer the sequence files with different formats. For example, if the data provided by the user needs to be processed by <italic>phylip</italic>'s software encapsulation, but the <italic>phylip</italic>'s software encapsulation only supports the sequence file with <italic>.phy</italic> format, then the transfer of the file sequence's format is necessary. Here, it needs to call <italic>seqret.exe</italic>. Next, the parameters of <italic>seqret</italic> are introduced.</p><p>
<italic>Seqret </italic>
has two main parameters: one parameter is the sign of the input file format and the file name and the other is the sign of the output file format and the file name.</p><p>The described file manner is required to correspond with the description format specified in Uniform Sequence Address (USA). The USA formats are described as follows.<list list-type="roman-lower"><list-item><p>&#x02009;&#x0201c;<italic>file</italic>&#x0201d;: name of the input file. File is a sequence file with&#x02009;&#x02009;<italic>.seq</italic> as extension name.</p></list-item><list-item><p>&#x02009;&#x0201c;<italic>file:entry</italic>&#x0201d;: combination form of file name and sequence ID.</p></list-item><list-item><p>&#x02009;&#x0201c;<italic>format::file</italic>&#x0201d;: combination form of input file's organization format and name.</p></list-item><list-item><p>&#x02009;&#x0201c;<italic>format::file:entry</italic>&#x0201d;: combination form of file's organization format, name, and index ID.</p></list-item><list-item><p>&#x02009;&#x0201c;<italic>database:entry</italic>&#x0201d;: combination form of database name and index ID.</p></list-item><list-item><p>&#x02009;&#x0201c;<italic>database</italic>&#x0201d;: database name.</p></list-item><list-item><p>&#x02009;&#x0201c;@<italic>file</italic>&#x0201d;: read each line in the file as an input sequence.</p></list-item></list>
</p><p>
<italic>Seqret</italic> can recognize the form &#x0201c;<italic>format::file</italic>.&#x0201d; For example, if we have a sequence file <italic>file.seq</italic> of the fasta type, we can express it as &#x0201c;<italic>fasta::file.seq</italic>.&#x0201d;</p><p>In addition, <italic>seqret</italic> still contains two senior parameters: -feature shows the characteristics information of the sequence applied, and <italic>-firstonly</italic> indicates that the program terminates after reading a sequence from the sequence file.</p></sec><sec id="sec2.2"><title>2.2. ORF Search Tools <italic>Getorf </italic>
</title><p>
<italic>Getorf</italic> is used to find the <italic>ORF</italic> in the known RNA sequence and translate the obtained polypeptides.</p><p>The parameters of <italic>getorf</italic> are as follows.<list list-type="simple"><list-item><label>&#x02009;(1)</label><p> Input sequence file: nucleic acid sequence that corresponds with the USA formats.</p></list-item><list-item><label>&#x02009;(2)</label><p> Output sequence file: gene sequence file that includes the <italic>orf</italic> search results.</p></list-item><list-item><label>&#x02009;(3)</label><p> Senior options: -<italic>circular</italic> indicates whether the gene sequence is a ring, -<italic>reverse</italic> indicates whether to find ORF in the gene's completely reverse sequence, and -<italic>flanking </italic> indicates choosing a chain of branched gene sequence between the beginning and ending codons.</p></list-item><list-item><label>&#x02009;(4)</label><p> Additional limited options: -<italic>minsize</italic>, -<italic>maxsize</italic>, -<italic>find</italic>, and -<italic>table</italic>.</p><p>
<list list-type="simple"><list-item><label>&#x02009;(a)</label><p> -<italic>minsize</italic> indicates that the program needs to search a peptide sequence with the length not less than minisize.</p></list-item><list-item><label>&#x02009;(b)</label><p> -<italic>maxsize</italic> indicates that the program needs to search a peptide sequence with the length not more than maxisize.</p></list-item><list-item><label>&#x02009;(c)</label><p> -<italic>find</italic> is followed with digital options. The meaning of specific number is described in <xref ref-type="table" rid="tab1">Table 1</xref>.</p></list-item><list-item><label>&#x02009;(d)</label><p> -<italic>table</italic> is followed with menu number from 0 to 23 to represent the organism's types. Here we do not describe the interpretation of specific number in detail.</p></list-item></list>
</p></list-item></list>
</p></sec><sec id="sec2.3"><title>2.3. Molecular Clock Based Maximum Likelihood Estimation Tools <italic>Proml </italic>
</title><p>
<italic>Proml</italic> is mainly used to construct amino acid sequence tree based on molecular clock maximum likelihood estimation. <italic>Proml</italic> has one input parameter which is a sequence file with <italic>phy</italic> format, and the sequence file includes numbers of amino acid sequences. Although the input parameter of <italic>Proml</italic> is very simple, but it has complex parameters settings, here we leave out the specific set options list.</p></sec></sec><sec id="sec3"><title>3. Framework of Bioinformatics Software's Encapsulation and Publication</title><p>Firstly, according to the characteristics of bioinformatics software, we extract a unified interface to make it easy to integrate a lot of bioinformatics software. Thus, we encapsulate a layer of shell over the bioinformatics software, just as described in <xref ref-type="fig" rid="fig1">Figure 1</xref>. The shell program exposes a simple interface to the outside, thus making it convenient to publish the service.</p><p>Secondly, we embed the encapsulated bioinformatics software in the compiled GRAM service [<xref rid="B9" ref-type="bibr">9</xref>]; GRAM called this application and provided bioinformatics software's service to the outside [<xref rid="B10" ref-type="bibr">10</xref>]. The publishing part usually uses the web service. In the publishing interface, we premise that the users already know the existence of GRAM service, so that we can use the API that is provided by GRAM service to call the application sources that the GRAM contains; then bioinformatics software's publishing is realized.</p><p>Therefore, we form the framework of bioinformatics software's encapsulation and publishing, as <xref ref-type="fig" rid="fig2">Figure 2</xref> shows.</p><p>As shown in <xref ref-type="fig" rid="fig2">Figure 2</xref>, in the upper level of our encapsulated software, GRAM encapsulates another layer, namely, the GRAM component internal service layer. The software is published with GRAM service's publication. During the publication, we use the API that is provided by GRAM to publish the bioinformatics software's function to the users and finally realize the bioinformatics software's publication.</p><sec id="sec3.1"><title>3.1. Software Encapsulation on Windows Platform</title><p>As the software that will be encapsulated is all executable files, we create process to execute the exe files and deal with the interactive process by redirecting the standard input and output. During the encapsulation process, the main part is the application of redirection technology.</p><p>The specific redirecting process is as follows: we assume that there are two anonymous pipelines, two one-way pipelines: pipeline A and pipeline B; each pipeline has one input terminal and one output terminal. </p><p>First step: if we want to execute a command, we need to put this command to the execution file's process. We use <italic>hStdInput</italic> to stand for standard input; it is originally responsible for receiving the user's input from the keyboard; here we hang it up on pipeline A's output terminal and make it responsible for receiving pipeline A's output data.</p><p>Second step: now we have connected pipeline A's output terminal to the input terminal of execution file's process; namely, pipeline A's output terminal is execution file's input terminal, so that, if we write a command to pipeline A's input terminal, the execution file can get our command through pipeline A.</p><p>Third step: as known, it is impossible for pipeline A to receive the output data of execution file, so we need another pipeline, pipeline B, to receive it. We use <italic>hStdOutput</italic> to stand for standard output, it is originally sent to the screen, and here we hang it up on pipeline B's input terminal and make pipeline B responsible for receiving exe file's output data. What is more, <italic>hStdError</italic> is standard error output, it is also originally sent to the screen, and we hang it up on pipeline B's input terminal too.</p><p>Forth step: now pipeline B's input terminal is connected to the output terminal of execution file's process, so that pipeline B's output terminal is bioinformatics software's output terminal; software can receive data from this terminal and send it to the users or use it for further judgment.</p></sec><sec id="sec3.2"><title>3.2. Software Encapsulation on Linux Platform</title><p>The first step: create two pipelines in the parent process: pipeline 0 and pipeline 1; each pipeline has two terminals, respectively, for reading and writing. For each pipeline, two file descriptors will be generated: one is used to read data from specific file and the other is used to write data to the specific file.</p><p>The second step: call <italic>fork</italic>() to create a new child process. So there are two pipelines for both the parent and child processes, including four descriptors, respectively, for reading and writing two specific files. The two specific files are, respectively, indicated by the four descriptors of the parent and child processes. The general situation is shown in <xref ref-type="fig" rid="fig3">Figure 3</xref>.</p><p>The third step: for pipeline 0 and pipeline 1, respectively, turn off one pipeline's reading terminal and the other pipeline's writing terminal between the parent and child processes. For example, turn off pipeline 0's reading terminal and pipeline 1's writing terminal in the parent process; accordingly, turn off pipeline 0's writing terminal, and pipeline 1's reading terminal in the child process. Thus, the parent process can write data to pipeline 0's file through its writing terminal, and then the child process can read its parent process's data from pipeline 0's reading terminal. And similarly, the child process's feedback information can be written to pipeline 1, and then the parent process can receive the child process's information. So the communication between the child process and parent process is realized. The specific procedure is shown in <xref ref-type="fig" rid="fig4">Figure 4</xref>.</p><p>The forth step: we need to redirect the standard input/output of the child process. Here, we need to call function <italic>dup2</italic>() in the child process, change the file that the child process's standard input/output indicates by <italic>dup2</italic>(), and finally finish the redirecting of the standard input/output.</p></sec><sec id="sec3.3"><title>3.3. Bioinformatics Software's Publication</title><p>After encapsulating bioinformatics software, we should publish it next. Firstly, we further encapsulate the software with a GRAM service provided by Globus. Secondly, we publish the GRAM service. By these two steps the bioinformatics software is published.</p><p>We compile a client application by using GRAM component's API, and the users can call the bioinformatics software through this application. Next, we introduce the client's realization in detail.</p><p>Firstly, we take a look at the GRAM API that Globus project team [<xref rid="B11" ref-type="bibr">11</xref>] provides to us. Globus project team publishes an encapsulation named <italic>org.globus.gram</italic>, and this encapsulation realizes all the necessary API functions that are needed when calling the GRAM function. We mainly call the functions of class <italic>Gram</italic> and <italic>GramJobListener</italic> to complete the client program and realize the process that submitting remote services through the GRAM components.</p><p>Secondly, we consider the specific process to submit services. When the users call GRAM services' specific application, the main task is to finish the compiling of the resource description file, namely, forming an RSL file. RSL is a cloud resource description language based on XML language. RSL defines various kinds of labels to describe the resource, methods, and details of the calling process.</p><p>The users' tasks can be divided into two kinds, namely, single job task and multiple jobs task. For example, the RSL file is a description file of single job task. A single job task contains only one job, while a multiple jobs task contains numbers of jobs.</p><p>The submitting modes of user's tasks can be also divided into two kinds, namely, batch mode and no batch mode. In batch mode, the application program will be blocked after the user submits tasks and return after the tasks are completed and the results are returned, while, in no batch mode, the application program returns after the user submits tasks, so that the user can continue to deal with other tasks. If the user wants to observe the specific conditions of the submitted task, he can query the task's status by calling the task examination management interface provided by GRAM.</p><p>The XML documents form the standards and principles of the communication between applications. We united describe the communication content between the client and the server through XML documents, and the specific communication form is described in <xref ref-type="fig" rid="fig5">Figure 5</xref>.</p><p>As shown in <xref ref-type="fig" rid="fig5">Figure 5</xref>, line 1 shows that client program sends the information that the user requires to the stub module called by the client. Line 2 shows that the stub module encapsulates the information into standard format according to the provision way and measure and sends the encapsulated information to the server stub module. Line 3 shows that the server stub module analyzes the received information and gets the information that the user demands and then sends this information to the service realization program, so that the program can deal with the user's requirements. Line 4 shows that the service realization program sends the processed information back to the stub module. Line 5 shows that the server stub module encapsulates the processed information and sends it to the client stub module. Line 6 shows that the client stub module analyzes the information and feeds it back to the client program.</p></sec></sec><sec id="sec4"><title>4. Experiments</title><sec id="sec4.1"><title>4.1. Encapsulation Interface Test on Windows Platform</title><p>First of all, we test the correctness of the bioinformatics software on Windows platform. We encapsulate three application programs, namely, <italic>seqret.exe</italic>, <italic>getorf.exe</italic>, and <italic>proml.exe</italic>. As described in the design, the encapsulation interface has three required parameters, including the file name, the input file, and the output file, and two optional domains, namely, the static input parameter and the dynamic input parameter.</p><p>Firstly, we test the correctness of <italic>seqret's</italic> encapsulation with the three required parameters; the result is shown in <xref ref-type="fig" rid="fig6">Figure 6</xref>. Obviously, the test is successful.</p><p>After calling <italic>seqret's</italic> encapsulation, the corresponding result file <italic>seqret-out.phy</italic> is generated in the directory from which the program runs, and the corresponding log file is also generated in the LogFile folder. The result is shown in <xref ref-type="fig" rid="fig7">Figure 7</xref>.</p><p>Next, we test <italic>proml's</italic> encapsulation. As <italic>proml</italic> is an application program on Windows platform, so we only test its encapsulation on Windows platform. <italic>Proml</italic> chooses the interactive parameters to communicate with the users. In our test, we choose the parameter &#x02013;I and import three interactive parameters: u, 5, and y.</p><p>The test results are shown in <xref ref-type="fig" rid="fig8">Figure 8</xref>.</p><p>The log files record the implementation details of this software's calling process successfully, and its format is the same to the log file of <italic>seqret</italic>; here we leave out the details of the log file.</p></sec><sec id="sec4.2"><title>4.2. GT's Local Task Submitting Test on Linux Platform</title><p>The operating system we use is Red Hat Enterprise Linux Advanced Server 4 [<xref rid="B12" ref-type="bibr">12</xref>], and the GT's version is Globus Toolkit 4.0.2 [<xref rid="B13" ref-type="bibr">13</xref>]. In the submitting test, the description file is shown in <xref ref-type="fig" rid="fig9">Figure 9</xref>.</p><p>Firstly, we submit the task by using the command globusrun-ws of GT's command line tool. Before the submit, we need to generate an agent with the command grid-proxy-init firstly; this is because the agent can help do some necessary operation when the GRAM calls other remote file transfer tasks, and the user's certification is needed to be identified. Therefore, the user's certification is the precondition of GRAM components' application.</p><p>Next, we take the task description file shown in <xref ref-type="fig" rid="fig9">Figure 9</xref> as one of the parameters we input in the command line to submit our task. In the task description file, we call <italic>getorf</italic> and input parameters <italic>sodium_mrna.fasta</italic>, <italic>orf.out</italic>, and -find 3-minsize 2000 as static parameters.</p><p>The result file and log file are as shown in <xref ref-type="fig" rid="figbox1">Box 1</xref>: as the red front shows, the result file and log file are generated successfully. We check the records in the two files, and they are both correct.</p></sec><sec id="sec4.3"><title>4.3. Client Remote Calling Test</title><p>We divide the test types of this part into five kinds: 0 cloud node and its service query, 1 remote submitting of nonbatch mode and single job task, 2 remote submitting of batch mode and single job task, 3 remote submitting of batch mode and multiple jobs task, and 4 query of the status of the task that is submitted with batch mode. Then we show the task submitting test of types 0, 1, 3, and 4 in detail.</p><p>Before the test, we describe the logic of the network on which the test is conducted. Its frame is shown in <xref ref-type="fig" rid="fig10">Figure 10</xref>.</p><p>The red font shows the task submitting node and the cluster master node, the place where our task is processed. Our encapsulated software is stored in the master node. The red arrows indicate the flow of the information.</p><p>We test the task's submitting with test type 1, call <italic>seqret</italic> job, and process the gene sequence transfer job. <xref ref-type="fig" rid="fig11"> Figure 11</xref> shows the process of this test.</p><p>As <xref ref-type="fig" rid="fig11">Figure 11</xref> shows, we can choose the task and their modes in the most left red box, set the task's parameters through the popup dialog box, and then submit the task by Submit Job button. As the submitted task is nonbatch, the application program blocks after the submitting until the remote execution is finished, and the completion signal is returned.</p><p>Next, we login the server and check the result file and the log file; they are both correct. Here, we leave out the details of the inspection.</p><p>Finally, we test the task's submitting with test type 3. We check the task's status by calling the query function.</p><p>As shown in <xref ref-type="fig" rid="fig12">Figure 12</xref>, the list in the bottom shows the tasks' name and parameters in detail, and the upper windows shows the results of the query; from it we can see two items: the job handle and the job state. We can see that our submitted task experiences the process of <italic>Unsubmitted</italic>-&#x0003e;<italic>Active</italic>-&#x0003e;<italic>Done</italic>. </p></sec></sec><sec id="sec5"><title>5. Conclusion</title><p>According to the secure encapsulation and publishing of bioinformatics software, this paper introduces the methods of encapsulating and publishing the existing services in the cloud environment and realizes a prototype system to publish bioinformatics software in the grid and cloud computing environment.</p><p>In the publishing part, the main process is the analysis of the application software's business and data flow. During the analysis, according to the interaction between processes, we use the communication mechanism of the processes to simulate the man-machine interaction by the application of the pipeline's redirection technology. Finally, according to the results of the analysis, we summarize the characteristics of bioinformatics software's external interface and make the interface simple and universal.</p><p>We use the services provided by cloud development tools in the publishing process, write interface processing program for specific application programs, and publish it with corresponding publishing mechanism. Finally, we combine the remote calling of bioinformatics software with cloud environment and form the prototype system of the biological cloud.</p></sec></body><back><ack><title>Acknowledgments</title><p>This work was supported by the National Basic Research Program of China under Grant no. G2011CB302605, the National Natural Science Foundation of China (NSFC) under Grant no. 61173145, and the National High Technology Research and Development Program of China under Grant no. 2011AA010705.</p></ack><ref-list><ref id="B1"><label>1</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gilbert</surname><given-names>D</given-names></name></person-group><article-title>Bioinformatics software resources</article-title><source><italic>Briefings in Bioinformatics</italic></source><year>2004</year><volume>5</volume><issue>3</issue><fpage>300</fpage><lpage>304</lpage><pub-id pub-id-type="other">2-s2.0-16644383857</pub-id><pub-id pub-id-type="pmid">15383216</pub-id></element-citation></ref><ref id="B2"><label>2</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Oehmen</surname><given-names>C</given-names></name><name><surname>Nieplocha</surname><given-names>J</given-names></name></person-group><article-title>ScalaBLAST: a scalable implementation of BLAST for high-performance data-intensive bioinformatics analysis</article-title><source><italic>IEEE Transactions on Parallel and Distributed Systems</italic></source><year>2006</year><volume>17</volume><issue>8</issue><fpage>740</fpage><lpage>749</lpage><pub-id pub-id-type="other">2-s2.0-33746091677</pub-id></element-citation></ref><ref id="B3"><label>3</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Thompson</surname><given-names>JD</given-names></name><name><surname>Higgins</surname><given-names>DG</given-names></name><name><surname>Gibson</surname><given-names>TJ</given-names></name></person-group><article-title>ClustalW: improving the sensitivity of progressive multiple sequence alignment through sequence weighting, positions-specific gap penalties and weight matrix choice</article-title><source><italic>Nucleic Acids Research</italic></source><year>1994</year><volume>22</volume><fpage>4673</fpage><lpage>4680</lpage><pub-id pub-id-type="pmid">7984417</pub-id></element-citation></ref><ref id="B4"><label>4</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Joseph</surname><given-names>F</given-names></name></person-group><source><italic>Inferring Phylogenies</italic></source><year>2003</year><publisher-name>Sinauer Associates</publisher-name></element-citation></ref><ref id="B5"><label>5</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rice</surname><given-names>P</given-names></name><name><surname>Longden</surname><given-names>L</given-names></name><name><surname>Bleasby</surname><given-names>A</given-names></name></person-group><article-title>EMBOSS: the european molecular biology open software suite</article-title><source><italic>Trends in Genetics</italic></source><year>2000</year><volume>16</volume><issue>6</issue><fpage>276</fpage><lpage>277</lpage><pub-id pub-id-type="other">2-s2.0-0034201441</pub-id><pub-id pub-id-type="pmid">10827456</pub-id></element-citation></ref><ref id="B6"><label>6</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Chen</surname><given-names>Y-L</given-names></name><name><surname>Cheng</surname><given-names>B-C</given-names></name><name><surname>Chen</surname><given-names>H-L</given-names></name><etal/></person-group><article-title>A privacy-preserved analytical method for ehealth database with minimized information loss</article-title><source><italic>Journal of Biomedicine and Biotechnology</italic></source><year>2012</year><volume>2012</volume><fpage>9 pages</fpage><pub-id pub-id-type="publisher-id">521267</pub-id></element-citation></ref><ref id="B7"><label>7</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Chen</surname><given-names>J</given-names></name><name><surname>Qian</surname><given-names>F</given-names></name><name><surname>Yan</surname><given-names>W</given-names></name><name><surname>Shen</surname><given-names>B</given-names></name></person-group><article-title>Translational biomedical informatics in the cloud: present and future</article-title><source><italic>BioMed Research International</italic></source><year>2013</year><volume>2013</volume><fpage>8 pages</fpage><pub-id pub-id-type="publisher-id">658925</pub-id></element-citation></ref><ref id="B8"><label>8</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>de Paris</surname><given-names>R</given-names></name><name><surname>Frantz</surname><given-names>FA</given-names></name><name><surname>de Souza</surname><given-names>ON</given-names></name><name><surname>Ruiz</surname><given-names>DD</given-names></name></person-group><article-title>wFReDoW: a cloud-based web environment to handle molecular docking simulations of a fully flexible receptor model</article-title><source><italic>BioMed Research International</italic></source><year>2013</year><volume>2013</volume><fpage>12 pages</fpage><pub-id pub-id-type="publisher-id">469363</pub-id></element-citation></ref><ref id="B9"><label>9</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Sotomayor</surname><given-names>B</given-names></name></person-group><source><italic>GT4 Programmer&#x02019;s Tutorial</italic></source><year>2004</year><publisher-name>Globus Toolkit Develope Team</publisher-name></element-citation></ref><ref id="B10"><label>10</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Ferreira</surname><given-names>L</given-names></name><name><surname>Berstis</surname><given-names>V</given-names></name></person-group><source><italic>Introduction to Grid Computing with Globus</italic></source><year>2003</year><publisher-name>IBM Redbooks</publisher-name></element-citation></ref><ref id="B11"><label>11</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Pedraza</surname><given-names>J</given-names></name><name><surname>Patricio</surname><given-names>MA</given-names></name><name><surname>de As&#x000ed;s</surname><given-names>A</given-names></name><name><surname>Molina</surname><given-names>JM</given-names></name></person-group><article-title>Privacy and legal requirements for developing biometric identification software in context-based applications</article-title><source><italic>International Journal of Bio-Science and Bio-Technology</italic></source><year>2010</year><volume>2</volume><issue>1</issue><fpage>13</fpage><lpage>24</lpage><pub-id pub-id-type="other">2-s2.0-79960724365</pub-id></element-citation></ref><ref id="B12"><label>12</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lee</surname><given-names>D-Y</given-names></name><name><surname>Bae</surname><given-names>S</given-names></name><name><surname>Song</surname><given-names>JH</given-names></name><etal/></person-group><article-title>Self-Organized Software Platform (SOSp)-based mobile chronic disease management with agent-based HL7 interface</article-title><source><italic>International Journal of Bio-Science and Bio-Technology</italic></source><year>2013</year><volume>5</volume><issue>1</issue><fpage>59</fpage><lpage>72</lpage></element-citation></ref><ref id="B13"><label>13</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kim</surname><given-names>H</given-names></name><name><surname>Kim</surname><given-names>Y</given-names></name><name><surname>Lee</surname><given-names>P</given-names></name></person-group><article-title>Reconfiguration mechanisms for virtual organization using remote deployment of grid service</article-title><source><italic>International Journal of Grid and Distributed Computing</italic></source><year>2009</year><volume>2</volume><issue>1</issue><fpage>27</fpage><lpage>38</lpage></element-citation></ref></ref-list></back><floats-group><fig id="fig1" orientation="portrait" position="float"><label>Figure 1</label><caption><p>Encapsulation of the bioinformatics software.</p></caption><graphic xlink:href="BMRI2013-170580.001"/></fig><fig id="fig2" orientation="portrait" position="float"><label>Figure 2</label><caption><p>Framework of bioinformatics software's encapsulation and publication.</p></caption><graphic xlink:href="BMRI2013-170580.002"/></fig><fig id="fig3" orientation="portrait" position="float"><label>Figure 3</label><caption><p>Mapping of parent and child process's file descriptor table.</p></caption><graphic xlink:href="BMRI2013-170580.003"/></fig><fig id="fig4" orientation="portrait" position="float"><label>Figure 4</label><caption><p>Piping communication schemes of the parent and child processes.</p></caption><graphic xlink:href="BMRI2013-170580.004"/></fig><fig id="fig5" orientation="portrait" position="float"><label>Figure 5</label><caption><p>Description of the communication between client and server.</p></caption><graphic xlink:href="BMRI2013-170580.005"/></fig><fig id="fig6" orientation="portrait" position="float"><label>Figure 6</label><caption><p>Schematic diagram of calling <italic>seqret's</italic> encapsulation Windows platform.</p></caption><graphic xlink:href="BMRI2013-170580.006"/></fig><fig id="fig7" orientation="portrait" position="float"><label>Figure 7</label><caption><p>Result of the sequence's transformation.</p></caption><graphic xlink:href="BMRI2013-170580.007"/></fig><fig id="fig8" orientation="portrait" position="float"><label>Figure 8</label><caption><p>Result of file of <italic>proml. </italic>
</p></caption><graphic xlink:href="BMRI2013-170580.008"/></fig><fig id="fig9" orientation="portrait" position="float"><label>Figure 9</label><caption><p>Task description file.</p></caption><graphic xlink:href="BMRI2013-170580.009"/></fig><fig id="fig10" orientation="portrait" position="float"><label>Figure 10</label><caption><p>Frame of the network on which the test is conducted.</p></caption><graphic xlink:href="BMRI2013-170580.010"/></fig><fig id="fig11" orientation="portrait" position="float"><label>Figure 11</label><caption><p>Submitting of no batch mode and single job task.</p></caption><graphic xlink:href="BMRI2013-170580.011"/></fig><fig id="fig12" orientation="portrait" position="float"><label>Figure 12</label><caption><p>Query of the task's status.</p></caption><graphic xlink:href="BMRI2013-170580.012"/></fig><fig id="figbox1" orientation="portrait" position="float"><label>Box 1</label><graphic xlink:href="BMRI2013-170580.013"/></fig><table-wrap id="tab1" orientation="portrait" position="float"><label>Table 1</label><caption><p>Interpretation of -<italic>find's</italic> digital options.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left" rowspan="1" colspan="1">Digital option</th><th align="left" rowspan="1" colspan="1">Interpretation </th></tr></thead><tbody><tr><td align="left" rowspan="1" colspan="1">0</td><td align="left" rowspan="1" colspan="1">Translate the <italic>orf</italic> between adjacent end codons</td></tr><tr><td align="left" rowspan="1" colspan="1">1</td><td align="left" rowspan="1" colspan="1">Output the <italic>orf</italic> between the beginning and ending codons</td></tr><tr><td align="left" rowspan="1" colspan="1">2</td><td align="left" rowspan="1" colspan="1">The nuclear sequences between end codons</td></tr><tr><td align="left" rowspan="1" colspan="1">3</td><td align="left" rowspan="1" colspan="1">The nuclear sequences between the beginning and end codons</td></tr><tr><td align="left" rowspan="1" colspan="1">4</td><td align="left" rowspan="1" colspan="1">The nucleosides side linking with the beginning codon</td></tr><tr><td align="left" rowspan="1" colspan="1">5</td><td align="left" rowspan="1" colspan="1">The nucleosides side linking with the start end codon</td></tr><tr><td align="left" rowspan="1" colspan="1">6</td><td align="left" rowspan="1" colspan="1">The nucleosides side linking with the terminal end codon</td></tr></tbody></table></table-wrap></floats-group></article>